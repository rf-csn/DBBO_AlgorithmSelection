
/************************************************************************
 * WARNING
 *
 * This file is an auto-generated amalgamation. Any changes made to this
 * file will be lost when it is regenerated!
 ************************************************************************/

#line 1 "code-experiments/src/profiler/IOHprofiler_random.c"
/**
 * @file IOHprofiler_random.c
 * @brief Definitions of functions regarding IOHprofiler random numbers.
 *
 * @note This file contains non-C89-standard types (such as uint32_t and uint64_t), which should
 * eventually be fixed.
 */
#ifndef IOH_PROFILER_RANDOM
#define IOH_PROFILER_RANDOM

#include <math.h>

#line 1 "code-experiments/src/profiler/IOHprofiler.h"
/**
 * @file IOHprofiler.h
 * @brief All public IOHprofiler functions and variables are defined in this file.
 *
 * It is the authoritative reference, if any function deviates from the documented behavior it is considered
 * a bug. See the function definitions for their detailed descriptions.
 */

#ifndef __IOHprofiler_H__
#define __IOHprofiler_H__

#include <stddef.h>

/* Definitions of some 32 and 64-bit types (used by the random number generator) */
#ifdef _MSC_VER
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

/* Include definition for NAN among other things */
#include <float.h>
#include <math.h>
#ifndef NAN
/** @brief Definition of NAN to be used only if undefined by the included headers */
#define NAN 8.8888e88
#endif
#ifndef isnan
/** @brief Definition of isnan to be used only if undefined by the included headers */
#define isnan(x) (0)
#endif
#ifndef INFINITY
/** @brief Definition of INFINITY to be used only if undefined by the included headers */
#define INFINITY 1e22
/* why not using 1e99? */
#endif
#ifndef isinf
/** @brief Definition of isinf to be used only if undefined by the included headers */
#define isinf(x) (0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief IOHprofiler's version.
 *
 * Automatically updated by do.py.
 */
/**@{*/
static const char IOHprofiler_version[32] = "";
/**@}*/

/***********************************************************************************************************/
/**
 * @brief IOHprofiler's own pi constant. Simplifies the case, when the value of pi changes.
 */
/**@{*/
static const double IOHprofiler_pi = 3.14159265358979323846;
/**@}*/

/***********************************************************************************************************/

/** @brief Logging level type. */
typedef enum {
    IOHprofiler_ERROR,   /**< @brief only error messages are output */
    IOHprofiler_WARNING, /**< @brief error and warning messages are output */
    IOHprofiler_INFO,    /**< @brief error, warning and info messages are output */
    IOHprofiler_DEBUG    /**< @brief error, warning, info and debug messages are output */
} IOHprofiler_log_level_type_e;

/***********************************************************************************************************/

/** @brief Structure containing a IOHprofiler problem. */
struct IOHprofiler_problem_s;

/**
 * @brief The IOHprofiler problem type.
 *
 * See IOHprofiler_problem_s for more information on its fields. */
typedef struct IOHprofiler_problem_s IOHprofiler_problem_t;

/** @brief Structure containing a IOHprofiler suite. */
struct IOHprofiler_suite_s;

/**
 * @brief The IOHprofiler suite type.
 *
 * See IOHprofiler_suite_s for more information on its fields. */
typedef struct IOHprofiler_suite_s IOHprofiler_suite_t;

/** @brief Structure containing a IOHprofiler observer. */
struct IOHprofiler_observer_s;

/**
 * @brief The IOHprofiler observer type.
 *
 * See IOHprofiler_observer_s for more information on its fields. */
typedef struct IOHprofiler_observer_s IOHprofiler_observer_t;

/** @brief Structure containing a IOHprofiler archive. */
struct IOHprofiler_archive_s;

/**
 * @brief The IOHprofiler archive type.
 *
 * See IOHprofiler_archive_s for more information on its fields. */
typedef struct IOHprofiler_archive_s IOHprofiler_archive_t;

/** @brief Structure containing a IOHprofiler random state. */
struct IOHprofiler_random_state_s;

/**
 * @brief The IOHprofiler random state type.
 *
 * See IOHprofiler_random_state_s for more information on its fields. */
typedef struct IOHprofiler_random_state_s IOHprofiler_random_state_t;

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler suite
 */
/**@{*/

/**
 * @brief Constructs a IOHprofiler suite.
 */
IOHprofiler_suite_t *IOHprofiler_suite(const char *suite_name, const char *suite_instance, const char *suite_options,int number, char** layer_param,char * temp_dim);

/**
 * @brief Frees the given suite.
 */
void IOHprofiler_suite_free(IOHprofiler_suite_t *suite);

/**
 * @brief Returns the next (observed) problem of the suite or NULL if there is no next problem left.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_next_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 *
 * @returns The current problem of the suite.
 */
IOHprofiler_problem_t *IOHprofiler_suite_reset_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 * @brief Returns the problem of the suite defined by problem_index.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_problem(IOHprofiler_suite_t *suite, const size_t problem_index);

/**
 * @brief Returns the number of problems in the given suite.
 */
size_t IOHprofiler_suite_get_number_of_problems(const IOHprofiler_suite_t *suite);

/**
 * @brief Returns the function number in the suite in position function_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_function_from_function_index(const IOHprofiler_suite_t *suite, const size_t function_idx);

/**
 * @brief Returns the dimension number in the suite in position dimension_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_dimension_from_dimension_index(const IOHprofiler_suite_t *suite, const size_t dimension_idx);

/**
 * @brief Returns the instance number in the suite in position instance_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_instance_from_instance_index(const IOHprofiler_suite_t *suite, const size_t instance_idx);
/**@}*/

/**
 * @name Encoding/decoding problem index
 *
 * General schema for encoding/decoding a problem index. Note that the index depends on the number of
 * instances a suite is defined with (it should be called a suite-instance-depending index...).
 * Also, while functions, instances and dimensions start from 1, function_idx, instance_idx and dimension_idx
 * as well as suite_dep_index start from 0!
 *
 * Showing an example with 2 dimensions (2, 3), 5 instances (6, 7, 8, 9, 10) and 2 functions (1, 2):
 *
   \verbatim
   index | instance | function | dimension
   ------+----------+----------+-----------
       0 |        6 |        1 |         2
       1 |        7 |        1 |         2
       2 |        8 |        1 |         2
       3 |        9 |        1 |         2
       4 |       10 |        1 |         2
       5 |        6 |        2 |         2
       6 |        7 |        2 |         2
       7 |        8 |        2 |         2
       8 |        9 |        2 |         2
       9 |       10 |        2 |         2
      10 |        6 |        1 |         3
      11 |        7 |        1 |         3
      12 |        8 |        1 |         3
      13 |        9 |        1 |         3
      14 |       10 |        1 |         3
      15 |        6 |        2 |         2
      16 |        7 |        2 |         3
      17 |        8 |        2 |         3
      18 |        9 |        2 |         3
      19 |       10 |        2 |         3

   index | instance_idx | function_idx | dimension_idx
   ------+--------------+--------------+---------------
       0 |            0 |            0 |             0
       1 |            1 |            0 |             0
       2 |            2 |            0 |             0
       3 |            3 |            0 |             0
       4 |            4 |            0 |             0
       5 |            0 |            1 |             0
       6 |            1 |            1 |             0
       7 |            2 |            1 |             0
       8 |            3 |            1 |             0
       9 |            4 |            1 |             0
      10 |            0 |            0 |             1
      11 |            1 |            0 |             1
      12 |            2 |            0 |             1
      13 |            3 |            0 |             1
      14 |            4 |            0 |             1
      15 |            0 |            1 |             1
      16 |            1 |            1 |             1
      17 |            2 |            1 |             1
      18 |            3 |            1 |             1
      19 |            4 |            1 |             1
   \endverbatim
 */
/**@{*/
/**
 * @brief Computes the index of the problem in the suite that corresponds to the given function, dimension
 * and instance indices.
 */
size_t IOHprofiler_suite_encode_problem_index(const IOHprofiler_suite_t *suite,
                                              const size_t function_idx,
                                              const size_t dimension_idx,
                                              const size_t instance_idx);

/**
 * @brief Computes the function, dimension and instance indexes of the problem with problem_index in the
 * given suite.
 */
void IOHprofiler_suite_decode_problem_index(const IOHprofiler_suite_t *suite,
                                            const size_t problem_index,
                                            size_t *function_idx,
                                            size_t *dimension_idx,
                                            size_t *instance_idx);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler observer
 */
/**@{*/
/**
 * @brief Constructs a IOHprofiler observer.
 */
IOHprofiler_observer_t *IOHprofiler_observer(const char *observer_name, const char *options);

/**
 * @brief Frees the given observer.
 */
void IOHprofiler_observer_free(IOHprofiler_observer_t *observer);

/**
 * @brief Adds an observer to the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_add_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**
 * @brief Removes an observer from the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_remove_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler problem
 */
/**@{*/
/**
 * @brief Evaluates the problem function in point x and save the result in y.
  logger_** functions use number_of_parameters and parameters to log extra informations of algorithms' adaptive parameters.
  If there is no need to log parameters, set number_of_parameters and parameters as 0 and NULL respectively.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Evaluates the problem constraints in point x and save the result in y.
 */
void IOHprofiler_evaluate_constraint(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Recommends a solution as the current best guesses to the problem.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief Frees the given problem.
 */
void IOHprofiler_problem_free(IOHprofiler_problem_t *problem);

void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters);

/**
 * @brief Returns the name of the problem.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the ID of the problem.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of variables i.e. the dimension of the problem.
 */
size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of objectives of the problem.
 */
size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of evaluations done on the problem.
 */
size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns 1 if the final target was hit, 0 otherwise.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the best observed value for the first objective.
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the target value for the first objective.
 */
double depreciated_IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with lower bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with upper bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the problem_index of the problem in its current suite.
 */
size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns an initial solution, i.e. a feasible variable setting, to the problem.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding random numbers
 */
/**@{*/

/**
 * @brief Creates and returns a new random number state using the given seed.
 */
IOHprofiler_random_state_t *IOHprofiler_random_new(uint32_t seed);

/**
 * @brief Frees all memory associated with the random state.
 */
void IOHprofiler_random_free(IOHprofiler_random_state_t *state);

/**
 * @brief Returns one uniform [0, 1) random value from the random number generator associated with the given
 * state.
 */
double IOHprofiler_random_uniform(IOHprofiler_random_state_t *state);

/**
 * @brief Generates an approximately normal random number.
 */
double IOHprofiler_random_normal(IOHprofiler_random_state_t *state);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods managing memory
 */
/**@{*/
/**
 * @brief Safe memory allocation that either succeeds or triggers a IOHprofiler_error.
 */
void *IOHprofiler_allocate_memory(const size_t size);

/**
 * @brief Safe memory allocation for a vector of doubles that either succeeds or triggers a IOHprofiler_error.
 */
double *IOHprofiler_allocate_vector(const size_t size);

/**
 * @brief Safe memory allocation for a vector of int that either succeeds or triggers a IOHprofiler_error.
 */
int *IOHprofiler_allocate_int_vector(const size_t size);

/**
 * @brief Frees the allocated memory.
 */
void IOHprofiler_free_memory(void *data);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler messages
 */
/**@{*/
/**
 * @brief Signals a fatal error.
 */
void IOHprofiler_error(const char *message, ...);

/**
 * @brief Warns about error conditions.
 */
void IOHprofiler_warning(const char *message, ...);

/**
 * @brief Outputs some information.
 */
void IOHprofiler_info(const char *message, ...);

/**
 * @brief Prints only the given message without any prefix and new line.
 *
 * A function similar to IOHprofiler_info but producing no additional text than
 * the given message.
 *
 * The output is only produced if IOHprofiler_log_level >= IOHprofiler_INFO.
 */
void IOHprofiler_info_partial(const char *message, ...);

/**
 * @brief Outputs detailed information usually used for debugging.
 */
void IOHprofiler_debug(const char *message, ...);

/**
 * @brief Sets the IOHprofiler log level to the given value and returns the previous value of the log level.
 */
const char *IOHprofiler_set_log_level(const char *level);
/**@}*/

/***********************************************************************************************************/

/**
 * @brief Constructs a IOHprofiler archive.
 */
IOHprofiler_archive_t *IOHprofiler_archive(const char *suite_name,
                                           const size_t function,
                                           const size_t dimension,
                                           const size_t instance);
/**
 * @brief Adds a solution with objectives (y1, y2) to the archive if none of the existing solutions in the
 * archive dominates it. In this case, returns 1, otherwise the archive is not updated and the method
 * returns 0.
 */

int IOHprofiler_archive_add_solution(IOHprofiler_archive_t *archive, const double y1, const double y2, const char *text);

/**
 * @brief Returns the number of (non-dominated) solutions in the archive (computed first, if needed).
 */
size_t IOHprofiler_archive_get_number_of_solutions(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the hypervolume of the archive (computed first, if needed).
 */
double IOHprofiler_archive_get_hypervolume(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the text of the next (non-dominated) solution in the archive and "" when there are no
 * solutions left. The first two solutions are always the extreme ones.
 */
const char *IOHprofiler_archive_get_next_solution_text(IOHprofiler_archive_t *archive);

/**
 * @brief Frees the archive.
 */
void IOHprofiler_archive_free(IOHprofiler_archive_t *archive);

/***********************************************************************************************************/

/**
 * @name Other useful methods
 */
/**@{*/
/**
 * @brief Removes the given directory and all its contents.
 */
int IOHprofiler_remove_directory(const char *path);

/**
 * @brief Formatted string duplication.
 */
char *IOHprofiler_strdupf(const char *str, ...);
/**@}*/

/***********************************************************************************************************/
typedef int (*int_to_int_func)(int);

struct WModel{
  size_t number_of_layers;
  int *layer1;
  int min1; int_to_int_func l_max1;
  int *layer2;
  int min2;int_to_int_func l_max2;
  int *layer3;
  int min3; int_to_int_func l_max3;
  int *layer4;
  int min4; int_to_int_func l_max4;
  int *counter;
};


#ifdef __cplusplus
}
#endif
#endif
#line 14 "code-experiments/src/profiler/IOHprofiler_random.c"

#define IOHprofiler_NORMAL_POLAR /* Use polar transformation method */

#define IOHprofiler_SHORT_LAG 273
#define IOHprofiler_LONG_LAG 607

/**
 * @brief A structure containing the state of the IOHprofiler random generator.
 */
struct IOHprofiler_random_state_s {
    double x[IOHprofiler_LONG_LAG];
    size_t index;
};

/**
 * @brief A lagged Fibonacci random number generator.
 *
 * This generator is nice because it is reasonably small and directly generates double values. The chosen
 * lags (607 and 273) lead to a generator with a period in excess of 2^607-1.
 */
static void IOHprofiler_random_generate(IOHprofiler_random_state_t *state) {
    size_t i;
    for (i = 0; i < IOHprofiler_SHORT_LAG; ++i) {
        double t = state->x[i] + state->x[i + (IOHprofiler_LONG_LAG - IOHprofiler_SHORT_LAG)];
        if (t >= 1.0)
            t -= 1.0;
        state->x[i] = t;
    }
    for (i = IOHprofiler_SHORT_LAG; i < IOHprofiler_LONG_LAG; ++i) {
        double t = state->x[i] + state->x[i - IOHprofiler_SHORT_LAG];
        if (t >= 1.0)
            t -= 1.0;
        state->x[i] = t;
    }
    state->index = 0;
}

IOHprofiler_random_state_t *IOHprofiler_random_new(uint32_t seed) {
    IOHprofiler_random_state_t *state = (IOHprofiler_random_state_t *)IOHprofiler_allocate_memory(sizeof(*state));
    size_t i;
    /* Expand seed to fill initial state array. */
    for (i = 0; i < IOHprofiler_LONG_LAG; ++i) {
        /* Uses uint64_t to silence the compiler ("shift count negative or too big, undefined behavior" warning) */
        state->x[i] = ((double)seed) / (double)(((uint64_t)1UL << 32) - 1);
        /* Advance seed based on simple RNG from TAOCP */
        seed = (uint32_t)1812433253UL * (seed ^ (seed >> 30)) + ((uint32_t)i + 1);
    }
    state->index = 0;
    return state;
}

void IOHprofiler_random_free(IOHprofiler_random_state_t *state) {
    IOHprofiler_free_memory(state);
}

double IOHprofiler_random_uniform(IOHprofiler_random_state_t *state) {
    /* If we have consumed all random numbers in our archive, it is time to run the actual generator for one
   * iteration to refill the state with 'LONG_LAG' new values. */
    if (state->index >= IOHprofiler_LONG_LAG)
        IOHprofiler_random_generate(state);
    return state->x[state->index++];
}

/**
 * Instead of using the (expensive) polar method, we may cheat and abuse the central limit theorem. The sum
 * of 12 uniform random values has mean 6, variance 1 and is approximately normal. Subtract 6 and you get
 * an approximately N(0, 1) random number.
 */
double IOHprofiler_random_normal(IOHprofiler_random_state_t *state) {
    double normal;
#ifdef IOHprofiler_NORMAL_POLAR
    const double u1 = IOHprofiler_random_uniform(state);
    const double u2 = IOHprofiler_random_uniform(state);
    normal = sqrt(-2 * log(u1)) * cos(2 * IOHprofiler_pi * u2);
#else
    int i;
    normal = 0.0;
    for (i = 0; i < 12; ++i) {
        normal += IOHprofiler_random_uniform(state);
    }
    normal -= 6.0;
#endif
    return normal;
}

/* Be hygienic (for amalgamation) and undef lags. */
#undef IOHprofiler_SHORT_LAG
#undef IOHprofiler_LONG_LAG
#endif
#line 1 "code-experiments/src/profiler/IOHprofiler_suite.c"
/**
 * @file IOHprofiler_suite.c
 * @brief Definitions of functions regarding IOHprofiler suites.
 *
 * When a new suite is added, the functions IOHprofiler_suite_initialize, IOHprofiler_suite_get_instances_by_year and
 * IOHprofiler_suite_get_problem_from_indices need to be updated.
 *
 */

#ifndef IOH_PROFILER_SUITE
#define IOH_PROFILER_SUITE
#endif

#include <time.h>
#line 16 "code-experiments/src/profiler/IOHprofiler_suite.c"
#line 1 "code-experiments/src/profiler/IOHprofiler_internal.h"
/**
 * @file IOHprofiler_internal.h
 * @brief Definitions of internal IOHprofiler structures and typedefs.
 *
 * These are used throughout the IOHprofiler code base but should not be used by any external code.
 */

#ifndef __IOHprofiler_INTERNAL__
#define __IOHprofiler_INTERNAL__

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************************************/
/**
 * @brief The data free function type.
 *
 * This is a template for functions that free the contents of data (used to free the contents of data
 * fields in IOHprofiler_problem, IOHprofiler_suite and IOHprofiler_observer).
 */
typedef void (*IOHprofiler_data_free_function_t)(void *data);

/**
 * @brief The problem free function type.
 *
 * This is a template for functions that free the problem structure.
 */
typedef void (*IOHprofiler_problem_free_function_t)(IOHprofiler_problem_t *problem);

/**
 * @brief The initial solution function type.
 *
 * This is a template for functions that return an initial solution of the problem.
 */
typedef void (*IOHprofiler_initial_solution_function_t)(const IOHprofiler_problem_t *problem, int *x);

/**
 * @brief The evaluate function type.
 *
 * This is a template for functions that perform an evaluation of the problem (to evaluate the problem
 * function, the problems constraints etc.).
 */
typedef void (*IOHprofiler_evaluate_function_t)(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief The recommend solutions function type.
 *
 * This is a template for functions that log a recommended solution.
 */
typedef void (*IOHprofiler_recommend_function_t)(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief The allocate logger function type.
 *
 * This is a template for functions that allocate a logger (wrap a logger around the given problem and return
 * the wrapped problem).
 */
typedef IOHprofiler_problem_t *(*IOHprofiler_logger_allocate_function_t)(IOHprofiler_observer_t *observer,
                                                                         IOHprofiler_problem_t *problem);

/**
 * @brief The transformed IOHprofiler problem data type.
 *
 * This is a type of a generic structure for a transformed ("outer") IOHprofiler_problem. It makes possible the
 * wrapping of problems as layers of an onion. Initialized in the IOHprofiler_problem_transformed_allocate function,
 * it makes the current ("outer") transformed problem a "derived problem class", which inherits from the
 * "inner" problem, the "base class".
 *
 * From the perspective of the inner problem:
 * - data holds the meta-information to administer the inheritance
 * - data->data holds the additional fields of the derived class (the outer problem)
 * - data->inner_problem points to the inner problem (now we have a linked list)
 */
typedef struct {
    IOHprofiler_problem_t *inner_problem;                /**< @brief Pointer to the inner problem */
    void *data;                                          /**< @brief Pointer to data, which enables further
                                                  wrapping of the problem */
    IOHprofiler_data_free_function_t data_free_function; /**< @brief Function to free the contents of data */
} IOHprofiler_problem_transformed_data_t;

/**
 * @brief The free logger function type.
 *
 * This is a template for functions that free a logger.
 */
typedef void (*IOHprofiler_logger_free_function_t)(void *logger);

/**
 * @brief The stacked IOHprofiler problem data type.
 *
 * This is a type of a structure used when stacking two problems (especially useful for constructing
 * multi-objective problems).
 */
typedef struct {
    IOHprofiler_problem_t *problem1; /**< @brief Pointer to the first problem (objective) */
    IOHprofiler_problem_t *problem2; /**< @brief Pointer to the second problem (objective) */
} IOHprofiler_problem_stacked_data_t;

/**
 * @brief The option keys data type.
 *
 * This is a type of a structure used to contain a set of known option keys (used by suites and observers).
 */
typedef struct {
    size_t count; /**< @brief Number of option keys */
    char **keys;  /**< @brief Pointer to option keys */
} IOHprofiler_option_keys_t;

/***********************************************************************************************************/

/**
 * @brief The IOHprofiler problem structure.
 *
 * This is one of the main structures in IOHprofiler. It contains information about a problem to be optimized. The
 * problems can be wrapped around each other (similar to the onion layers) by means of the data field and
 * the IOHprofiler_problem_transformed_data_t structure creating some kind of "object inheritance". Even the logger
 * is considered as just another IOHprofiler_problem instance wrapped around the original problem.
 */
struct IOHprofiler_problem_s {
    IOHprofiler_initial_solution_function_t initial_solution;  /**< @brief  The function for creating an initial solution. */
    IOHprofiler_evaluate_function_t evaluate_function;         /**< @brief  The function for evaluating the problem. */
    IOHprofiler_recommend_function_t recommend_solution;       /**< @brief  The function for recommending a solution. */
    IOHprofiler_problem_free_function_t problem_free_function; /**< @brief  The function for freeing this problem. */

    size_t dimension; /**< @brief Number of variables expected before any transformation, used for logging files. */
    size_t number_of_variables;  /**< @brief Number of variables expected by the function, i.e.
                                       problem dimension */
    size_t number_of_objectives; /**< @brief Number of objectives. */
    size_t number_of_parameters; /**<  IOHprofiler @brief Number of parameters. */

    int *smallest_values_of_interest; /**< @brief The lower bounds of the ROI in the decision space. */
    int *largest_values_of_interest;  /**< @brief The upper bounds of the ROI in the decision space. */

    double *best_value;  /**< @brief Optimal (smallest) function value */
    double *nadir_value; /**< @brief The nadir point (defined when number_of_objectives > 1) */
    int *best_parameter; /**< @brief Optimal decision vector (defined only when unique) */
    double *parameters;  /** IOHprofiler @brief parameters setting */
    double *raw_fitness;

    char *problem_name; /**< @brief Problem name. */
    char *problem_id;   /**< @brief Problem ID (unique in the containing suite) */
    char *problem_type; /**< @brief Problem type */

    size_t evaluations; /**< @brief Number of evaluations performed on the problem. */

    /* Convenience fields for output generation */

    double final_target_delta[1];       /**< @brief Final target delta. */
    double best_observed_fvalue[1];     /**< @brief The best observed value so far. */
    size_t best_observed_evaluation[1]; /**< @brief The evaluation when the best value so far was achieved. */

    /* Fields depending on the containing benchmark suite */

    IOHprofiler_suite_t *suite; /**< @brief Pointer to the containing suite (NULL if not given) */
    size_t suite_dep_index;     /**< @brief Suite-depending problem index (starting from 0) */
    size_t suite_dep_function;  /**< @brief Suite-depending function */
    size_t suite_dep_instance;  /**< @brief Suite-depending instance */

    void *data; /**< @brief Pointer to a data instance @see IOHprofiler_problem_transformed_data_t */
};

/**
 * @brief The IOHprofiler observer structure.
 *
 * An observer observes the whole benchmark process. It is independent of suites and problems. Each time a
 * new problem of the suite is being observed, the observer initializes a new logger (wraps the observed
 * problem with the corresponding logger).
 */
struct IOHprofiler_observer_s {
    int is_active;         /**< @brief Whether the observer is active (the logger will log some output). */
    char *observer_name;   /**< @brief Name of the observer for identification purposes. */
    char *result_folder;   /**< @brief Name of the result folder. */
    char *algorithm_name;  /**< @brief Name of the algorithm to be used in logger output. */
    char *algorithm_info;  /**< @brief Additional information on the algorithm to be used in logger output. */
    char *parameters_name; /**< @brief Name of recorded parameters to be used in logger output. */
    size_t number_target_triggers;
    /**< @brief The number of targets between each 10**i and 10**(i+1). */
    double target_precision; /**< @brief The minimal precision used for targets. */
    size_t number_evaluation_triggers;
    /**< @brief The number of triggers between each 10**i and 10**(i+1) evaluation number. */
    char *base_evaluation_triggers;
    /**< @brief The "base evaluations" used to evaluations that trigger logging. */
    size_t number_interval_triggers;
    /**< @brief The size of interval between two triggers. */
    char *complete_triggers; /**< @brief The symbol for recording all evaluation. */

    int precision_x; /**< @brief Output precision for decision variables. */
    int precision_f; /**< @brief Output precision for function values. */
    void *data;      /**< @brief Void pointer that can be used to point to data specific to an observer. */

    IOHprofiler_data_free_function_t data_free_function;             /**< @brief  The function for freeing this observer. */
    IOHprofiler_logger_allocate_function_t logger_allocate_function; /**< @brief  The function for allocating the logger. */
    IOHprofiler_logger_free_function_t logger_free_function;         /**< @brief  The function for freeing the logger. */
};

/**
 * @brief The IOHprofiler suite structure.
 *
 * A suite is a collection of problems constructed by a Cartesian product of the suite's optimization
 * functions, dimensions and instances. The functions and dimensions are fixed for a suite with some name,
 * while the instances are defined dynamically. The suite can be filtered - only the chosen functions,
 * dimensions and instances will be taken into account when iterating through the suite.
 */
struct IOHprofiler_suite_s {
    char *suite_name; /**< @brief Name of the suite. */

    size_t number_of_dimensions; /**< @brief Number of dimensions contained in the suite. */
    size_t *dimensions;          /**< @brief The dimensions contained in the suite. */

    size_t number_of_functions; /**< @brief Number of functions contained in the suite. */
    size_t *functions;          /**< @brief The functions contained in the suite. */

    size_t number_of_instances; /**< @brief Number of instances contained in the suite. */
    char *default_instances;    /**< @brief The instances contained in the suite by default. */
    size_t *instances;          /**< @brief The instances contained in the suite. */

    IOHprofiler_problem_t *current_problem; /**< @brief Pointer to the currently tackled problem. */
    long current_dimension_idx;             /**< @brief The dimension index of the currently tackled problem. */
    long current_function_idx;              /**< @brief The function index of the currently tackled problem. */
    long current_instance_idx;              /**< @brief The instance index of the currently tackled problem. */

    void *data; /**< @brief Void pointer that can be used to point to data specific to a suite. */

    IOHprofiler_data_free_function_t data_free_function; /**< @brief The function for freeing this suite. */
};

#ifdef __cplusplus
}
#endif
#endif
#line 17 "code-experiments/src/profiler/IOHprofiler_suite.c"
#line 1 "code-experiments/src/profiler/IOHprofiler_utilities.c"
/**
 * @file IOHprofiler_utilities.c
 * @brief Definitions of miscellaneous functions used throughout the IOHprofiler framework.
 */
#ifndef IOH_PROFILER_UTILITIES
#define IOH_PROFILER_UTILITIES

#line 1 "code-experiments/src/profiler/IOHprofiler_platform.h"
/**
 * @file IOHprofiler_platform.h
 * @brief Automatic platform-dependent configuration of the IOHprofiler framework.
 *
 * Some platforms and standard conforming compilers require extra defines or includes to provide some
 * functionality.
 *
 * Because most feature defines need to be set before the first system header is included and we do not
 * know when a system header is included for the first time in the amalgamation, all internal files
 * that need these definitions should include this file before any system headers.
 */

#ifndef __COCO_PLATFORM__
#define __COCO_PLATFORM__

#include <stddef.h>

/* Definitions of IOHprofiler_PATH_MAX, IOHprofiler_path_separator, HAVE_GFA and HAVE_STAT heavily used by functions in
 * IOHprofiler_utilities.c */
#if defined(_WIN32) || defined(_WIN64) || defined(__MINGW64__) || defined(__CYGWIN__)
#include <windows.h>
static const char *IOHprofiler_path_separator = "\\";
#define IOHprofiler_PATH_MAX MAX_PATH
#define HAVE_GFA 1
#elif defined(__gnu_linux__)
#include <linux/limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__APPLE__)
#include <sys/stat.h>
#include <sys/syslimits.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__FreeBSD__)
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif (defined(__sun) || defined(sun)) && (defined(__SVR4) || defined(__svr4__))
/* Solaris */
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#else
#error Unknown platform
#endif
#if !defined(IOHprofiler_PATH_MAX)
#error IOHprofiler_PATH_MAX undefined
#endif

/* Definitions needed for creating and removing directories */
/* Separately handle the special case of Microsoft Visual Studio 2008 with x86_64-w64-mingw32-gcc */
#if _MSC_VER
#include <direct.h>
#elif defined(__MINGW32__) || defined(__MINGW64__)
#include <dirent.h>
#else
#include <dirent.h>

#ifdef __cplusplus
extern "C" {
#endif

/* To silence the compiler (implicit-function-declaration warning). */
/** @cond */
int rmdir(const char *pathname);
int unlink(const char *file_name);
int mkdir(const char *pathname, mode_t mode);
/** @endcond */
#endif

/* Definition of the S_IRWXU constant needed to set file permissions */
#if defined(HAVE_GFA)
#define S_IRWXU 0700
#endif

/* To silence the Visual Studio compiler (C4996 warnings in the python build). */
#ifdef _MSC_VER
#pragma warning(disable : 4996)
#endif

#ifdef __cplusplus
}
#endif

#endif
#line 9 "code-experiments/src/profiler/IOHprofiler_utilities.c"

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#line 18 "code-experiments/src/profiler/IOHprofiler_utilities.c"
#line 19 "code-experiments/src/profiler/IOHprofiler_utilities.c"
#line 1 "code-experiments/src/profiler/IOHprofiler_string.c"
/**
 * @file IOHprofiler_string.c
 * @brief Definitions of functions that manipulate strings.
 */
#ifndef IOH_PROFILER_STRING
#define IOH_PROFILER_STRING

#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#line 13 "code-experiments/src/profiler/IOHprofiler_string.c"

static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements);

/**
 * @brief Creates a duplicate copy of string and returns a pointer to it.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strdup(const char *string) {
    size_t len;
    char *duplicate;
    if (string == NULL)
        return NULL;
    len = strlen(string);
    duplicate = (char *)IOHprofiler_allocate_memory(len + 1);
    memcpy(duplicate, string, len + 1);
    return duplicate;
}

/**
 * @brief The length of the buffer used in the IOHprofiler_vstrdupf function.
 *
 * @note This should be handled differently!
 */
#define IOHprofiler_VSTRDUPF_BUFLEN 444

/**
 * @brief Formatted string duplication, with va_list arguments.
 */
static char *IOHprofiler_vstrdupf(const char *str, va_list args) {
    static char buf[IOHprofiler_VSTRDUPF_BUFLEN];
    long written;
    /* apparently args can only be used once, therefore
   * len = vsnprintf(NULL, 0, str, args) to find out the
   * length does not work. Therefore we use a buffer
   * which limits the max length. Longer strings should
   * never appear anyway, so this is rather a non-issue. */

#if 0
  written = vsnprintf(buf, IOHprofiler_VSTRDUPF_BUFLEN - 2, str, args);
  if (written < 0)
  IOHprofiler_error("IOHprofiler_vstrdupf(): vsnprintf failed on '%s'", str);
#else /* less safe alternative, if vsnprintf is not available */
    assert(strlen(str) < IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2);
    if (strlen(str) >= IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2)
        IOHprofiler_error("IOHprofiler_vstrdupf(): string is too long");
    written = vsprintf(buf, str, args);
    if (written < 0)
        IOHprofiler_error("IOHprofiler_vstrdupf(): vsprintf failed on '%s'", str);
#endif
    if (written > IOHprofiler_VSTRDUPF_BUFLEN - 3)
        IOHprofiler_error("IOHprofiler_vstrdupf(): A suspiciously long string is tried to being duplicated '%s'", buf);
    return IOHprofiler_strdup(buf);
}

#undef IOHprofiler_VSTRDUPF_BUFLEN

/**
 * Optional arguments are used like in sprintf.
 */
char *IOHprofiler_strdupf(const char *str, ...) {
    va_list args;
    char *s;

    va_start(args, str);
    s = IOHprofiler_vstrdupf(str, args);
    va_end(args);
    return s;
}

/**
 * @brief Returns a concatenate copy of string1 + string2.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strconcat(const char *s1, const char *s2) {
    size_t len1 = strlen(s1);
    size_t len2 = strlen(s2);
    char *s = (char *)IOHprofiler_allocate_memory(len1 + len2 + 1);

    memcpy(s, s1, len1);
    memcpy(&s[len1], s2, len2 + 1);
    return s;
}

/**
 * @brief Returns the first index where seq occurs in base and -1 if it doesn't.
 *
 * @note If there is an equivalent standard C function, this can/should be removed.
 */
static long IOHprofiler_strfind(const char *base, const char *seq) {
    const size_t strlen_seq = strlen(seq);
    const size_t last_first_idx = strlen(base) - strlen(seq);
    size_t i, j;

    if (strlen(base) < strlen(seq))
        return -1;

    for (i = 0; i <= last_first_idx; ++i) {
        if (base[i] == seq[0]) {
            for (j = 0; j < strlen_seq; ++j) {
                if (base[i + j] != seq[j])
                    break;
            }
            if (j == strlen_seq) {
                if (i > 1e9)
                    IOHprofiler_error("IOHprofiler_strfind(): strange values observed i=%lu, j=%lu, strlen(base)=%lu",
                                      (unsigned long)i, (unsigned long)j, (unsigned long)strlen(base));
                return (long)i;
            }
        }
    }
    return -1;
}

/**
 * @brief Splits a string based on the given delimiter.
 *
 * Returns a pointer to the resulting substrings with NULL as the last one.
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char **IOHprofiler_string_split(const char *string, const char delimiter) {
    char **result;
    char *str_copy, *ptr, *token;
    char str_delimiter[2];
    size_t i;
    size_t count = 1;

    str_copy = IOHprofiler_strdup(string);

    /* Counts the parts between delimiters */
    ptr = str_copy;
    while (*ptr != '\0') {
        if (*ptr == delimiter) {
            count++;
        }
        ptr++;
    }
    /* Makes room for an empty string that will be appended at the end */
    count++;

    result = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));

    /* Iterates through tokens
   * NOTE: strtok() ignores multiple delimiters, therefore the final number of detected substrings might be
   * lower than the count. This is OK. */
    i = 0;
    /* A char* delimiter needs to be used, otherwise strtok() can surprise */
    str_delimiter[0] = delimiter;
    str_delimiter[1] = '\0';
    token = strtok(str_copy, str_delimiter);
    while (token) {
        assert(i < count);
        *(result + i++) = IOHprofiler_strdup(token);
        token = strtok(NULL, str_delimiter);
    }
    *(result + i) = NULL;

    IOHprofiler_free_memory(str_copy);

    return result;
}

/**
 * @brief Creates and returns a string with removed characters between from and to.
 *
 * If you wish to remove characters from the beginning of the string, set from to "".
 * If you wish to remove characters until the end of the string, set to to "".
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_remove_from_string(const char *string, const char *from, const char *to) {
    char *result, *start, *stop;

    result = IOHprofiler_strdup(string);

    if (strcmp(from, "") == 0) {
        /* Remove from the start */
        start = result;
    } else
        start = strstr(result, from);

    if (strcmp(to, "") == 0) {
        /* Remove until the end */
        stop = result + strlen(result);
    } else
        stop = strstr(result, to);

    if ((start == NULL) || (stop == NULL) || (stop < start)) {
        IOHprofiler_error("IOHprofiler_remove_from_string(): failed to remove characters between %s and %s from string %s",
                          from, to, string);
        return NULL; /* Never reached */
    }

    memmove(start, stop, strlen(stop) + 1);

    return result;
}

/**
 * @brief Returns the numbers defined by the ranges.
 *
 * Reads ranges from a string of positive ranges separated by commas. For example: "-3,5-6,8-". Returns the
 * numbers that are defined by the ranges if min and max are used as their extremes. If the ranges with open
 * beginning/end are not allowed, use 0 as min/max. The returned string has an appended 0 to mark its end.
 * A maximum of max_count values is returned. If there is a problem with one of the ranges, the parsing stops
 * and the current result is returned. The memory of the returned object needs to be freed by the caller.
 */
static size_t *IOHprofiler_string_parse_ranges(const char *string,
                                               const size_t min,
                                               const size_t max,
                                               const char *name,
                                               const size_t max_count) {
    char *ptr, *dash = NULL;
    char **ranges, **numbers;
    size_t i, j, count;
    size_t num[2];

    size_t *result;
    size_t i_result = 0;

    char *str = IOHprofiler_strdup(string);

    /* Check for empty string */
    if ((str == NULL) || (strlen(str) == 0)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): cannot parse empty ranges");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    ptr = str;
    /* Check for disallowed characters */
    while (*ptr != '\0') {
        if ((*ptr != '-') && (*ptr != ',') && !isdigit((unsigned char)*ptr)) {
            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - cannot parse ranges with '%c'", str,
                                *ptr);
            IOHprofiler_free_memory(str);
            return NULL;
        } else
            ptr++;
    }
    /* Check for incorrect boundaries */
    if ((max > 0) && (min > max)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): incorrect boundaries");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    result = IOHprofiler_allocate_vector_size_t(max_count + 1);

    /* Split string to ranges w.r.t commas */
    ranges = IOHprofiler_string_split(str, ',');
    IOHprofiler_free_memory(str);
    if (ranges) {
        /* Go over the current range */
        for (i = 0; *(ranges + i); i++) {
            ptr = *(ranges + i);
            /* Count the number of '-' */
            count = 0;
            while (*ptr != '\0') {
                if (*ptr == '-') {
                    if (count == 0)
                        /* Remember the position of the first '-' */
                        dash = ptr;
                    count++;
                }
                ptr++;
            }
            /* Point again to the start of the range */
            ptr = *(ranges + i);

            /* Check for incorrect number of '-' */
            if (count > 1) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - too many '-'s", string);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            } else if (count == 0) {
                /* Range is in the format: n (no range) */
                num[0] = (size_t)strtol(ptr, NULL, 10);
                num[1] = num[0];
            } else {
                /* Range is in one of the following formats: n-m / -n / n- / - */

                /* Split current range to numbers w.r.t '-' */
                numbers = IOHprofiler_string_split(ptr, '-');
                j = 0;
                if (numbers) {
                    /* Read the numbers */
                    for (j = 0; *(numbers + j); j++) {
                        assert(j < 2);
                        num[j] = (size_t)strtol(*(numbers + j), NULL, 10);
                        IOHprofiler_free_memory(*(numbers + j));
                    }
                }
                IOHprofiler_free_memory(numbers);

                if (j == 0) {
                    /* Range is in the format - (open ends) */
                    if ((min == 0) || (max == 0)) {
                        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open ends; some ranges ignored", name);
                        /* Cleanup */
                        for (j = i; *(ranges + j); j++)
                            IOHprofiler_free_memory(*(ranges + j));
                        IOHprofiler_free_memory(ranges);
                        if (i_result == 0) {
                            IOHprofiler_free_memory(result);
                            return NULL;
                        }
                        result[i_result] = 0;
                        return result;
                    }
                    num[0] = min;
                    num[1] = max;
                } else if (j == 1) {
                    if (dash - *(ranges + i) == 0) {
                        /* Range is in the format -n */
                        if (min == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open beginning; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = num[0];
                        num[0] = min;
                    } else {
                        /* Range is in the format n- */
                        if (max == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open end; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = max;
                    }
                }
                /* if (j == 2), range is in the format n-m and there is nothing to do */
            }

            /* Make sure the boundaries are taken into account */
            if ((min > 0) && (num[0] < min)) {
                num[0] = min;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be >= %lu", name,
                                    (unsigned long)min);
              }
            if ((max > 0) && (num[1] > max)) {
                num[1] = max;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be <= %lu", name, (unsigned long) max);
            }
            if (num[0] > num[1]) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges not within boundaries; some ranges ignored", name);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            }

            /* Write in result */
            for (j = num[0]; j <= num[1]; j++) {
                if (i_result > max_count - 1)
                    break;
                result[i_result++] = j;
            }

            IOHprofiler_free_memory(*(ranges + i));
            *(ranges + i) = NULL;
        }
    }

    IOHprofiler_free_memory(ranges);

    if (i_result == 0) {
        IOHprofiler_free_memory(result);
        return NULL;
    }

    result[i_result] = 0;
    return result;
}

/**
 * @brief Trims the given string (removes any leading and trailing spaces).
 *
 * If the string contains any leading spaces, the contents are shifted so that if it was dynamically
 * allocated, it can be still freed on the returned pointer.
 */
static char *IOHprofiler_string_trim(char *string) {
    size_t len = 0;
    char *frontp = string;
    char *endp = NULL;

    if (string == NULL) {
        return NULL;
    }
    if (string[0] == '\0') {
        return string;
    }

    len = strlen(string);
    endp = string + len;

    /* Move the front and back pointers to address the first non-whitespace characters from each end. */
    while (isspace((unsigned char)*frontp)) {
        ++frontp;
    }
    if (endp != frontp) {
        while (isspace((unsigned char)*(--endp)) && endp != frontp) {
        }
    }

    if (string + len - 1 != endp)
        *(endp + 1) = '\0';
    else if (frontp != string && endp == frontp)
        *string = '\0';

    /* Shift the string. Note the reuse of endp to mean the front of the string buffer now. */
    endp = string;
    if (frontp != string) {
        while (*frontp) {
            *endp++ = *frontp++;
        }
        *endp = '\0';
    }

    return string;
}
#endif
#line 20 "code-experiments/src/profiler/IOHprofiler_utilities.c"

/***********************************************************************************************************/

/**
 * @brief Initializes the logging level to IOHprofiler_INFO.
 */
static IOHprofiler_log_level_type_e IOHprofiler_log_level = IOHprofiler_INFO;

/**
 * @param log_level Denotes the level of information given to the user through the standard output and
 * error streams. Can take on the values:
 * - "error" (only error messages are output),
 * - "warning" (only error and warning messages are output),
 * - "info" (only error, warning and info messages are output) and
 * - "debug" (all messages are output).
 * - "" does not set a new value
 * The default value is info.
 *
 * @return The previous IOHprofiler_log_level value as an immutable string.
 */
const char *IOHprofiler_set_log_level(const char *log_level) {
    IOHprofiler_log_level_type_e previous_log_level = IOHprofiler_log_level;

    if (strcmp(log_level, "error") == 0)
        IOHprofiler_log_level = IOHprofiler_ERROR;
    else if (strcmp(log_level, "warning") == 0)
        IOHprofiler_log_level = IOHprofiler_WARNING;
    else if (strcmp(log_level, "info") == 0)
        IOHprofiler_log_level = IOHprofiler_INFO;
    else if (strcmp(log_level, "debug") == 0)
        IOHprofiler_log_level = IOHprofiler_DEBUG;
    else if (strcmp(log_level, "") == 0) {
        /* Do nothing */
    } else {
        IOHprofiler_warning("IOHprofiler_set_log_level(): unknown level %s", log_level);
    }

    if (previous_log_level == IOHprofiler_ERROR)
        return "error";
    else if (previous_log_level == IOHprofiler_WARNING)
        return "warning";
    else if (previous_log_level == IOHprofiler_INFO)
        return "info";
    else if (previous_log_level == IOHprofiler_DEBUG)
        return "debug";
    else {
        IOHprofiler_error("IOHprofiler_set_log_level(): unknown previous log level");
        return "";
    }
}

/***********************************************************************************************************/

/**
 * @name Methods regarding file, directory and path manipulations
 */
/**@{*/
/**
 * @brief Creates a platform-dependent path from the given strings.
 *
 * @note The last argument must be NULL.
 * @note The first parameter must be able to accommodate path_max_length characters and the length
 * of the joined path must not exceed path_max_length characters.
 * @note Should work cross-platform.
 *
 * Usage examples:
 * - IOHprofiler_join_path(base_path, 100, folder1, folder2, folder3, NULL) creates base_path/folder1/folder2/folder3
 * - IOHprofiler_join_path(base_path, 100, folder1, file_name, NULL) creates base_path/folder1/file_name
 * @param path The base path; it's also where the joined path is stored to.
 * @param path_max_length The maximum length of the path.
 * @param ... Additional strings, must end with NULL
 */
static void IOHprofiler_join_path(char *path, const size_t path_max_length, ...) {
    const size_t path_separator_length = strlen(IOHprofiler_path_separator);
    va_list args;
    char *path_component;
    size_t path_length = strlen(path);

    va_start(args, path_max_length);
    while (NULL != (path_component = va_arg(args, char *))) {
        size_t component_length = strlen(path_component);
        if (path_length + path_separator_length + component_length >= path_max_length) {
            IOHprofiler_error("IOHprofiler_join_path() failed because the ${path} is too short.");
            return; /* never reached */
        }
        /* Both should be safe because of the above check. */
        if (strlen(path) > 0)
            strncat(path, IOHprofiler_path_separator, path_max_length - strlen(path) - 1);
        strncat(path, path_component, path_max_length - strlen(path) - 1);
    }
    va_end(args);
}

/**
 * @brief Checks if the given directory exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a directory and 0 otherwise.
 */
static int IOHprofiler_directory_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Checks if the given file exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a file and 0 otherwise.
 */
static int IOHprofiler_file_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES) && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && !S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Calls the right mkdir() method (depending on the platform).
 *
 * @param path The directory path.
 *
 * @return 0 on successful completion, and -1 on error.
 */
static int IOHprofiler_mkdir(const char *path) {
#if _MSC_VER
    return _mkdir(path);
#elif defined(__MINGW32__) || defined(__MINGW64__)
    return mkdir(path);
#else
    return mkdir(path, S_IRWXU);
#endif
}

/**
 * @brief Creates a directory with full privileges for the user.
 *
 * @note Should work cross-platform.
 *
 * @param path The directory path.
 */
static void IOHprofiler_create_directory(const char *path) {
    char *tmp = NULL;
    char *p;
    size_t len = strlen(path);
    char path_sep = IOHprofiler_path_separator[0];

    /* Nothing to do if the path exists. */
    if (IOHprofiler_directory_exists(path))
        return;

    tmp = IOHprofiler_strdup(path);
    /* Remove possible trailing slash */
    if (tmp[len - 1] == path_sep)
        tmp[len - 1] = 0;
    for (p = tmp + 1; *p; p++) {
        if (*p == path_sep) {
            *p = 0;
            if (!IOHprofiler_directory_exists(tmp)) {
                if (0 != IOHprofiler_mkdir(tmp))
                    IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
            }
            *p = path_sep;
        }
    }
    if (0 != IOHprofiler_mkdir(tmp))
        IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
    IOHprofiler_free_memory(tmp);
    return;
}

/* Commented to silence the compiler (unused function warning) */
#if 0

#endif

/**
 * @brief Creates a unique directory from the given path.
 *
 * If the given path does not yet exit, it is left as is, otherwise it is changed(!) by appending a number
 * to it. If path already exists, path-01 will be tried. If this one exists as well, path-02 will be tried,
 * and so on. If path-99 exists as well, the function throws an error.
 */
static void IOHprofiler_create_unique_directory(char **path) {
    int counter = 1;
    char *new_path;

    /* Create the path if it does not yet exist */
    if (!IOHprofiler_directory_exists(*path)) {
        IOHprofiler_create_directory(*path);
        return;
    }

    while (counter < 999) {
        new_path = IOHprofiler_strdupf("%s-%03d", *path, counter);

        if (!IOHprofiler_directory_exists(new_path)) {
            IOHprofiler_free_memory(*path);
            *path = new_path;
            IOHprofiler_create_directory(*path);
            return;
        } else {
            counter++;
            IOHprofiler_free_memory(new_path);
        }
    }

    IOHprofiler_error("IOHprofiler_create_unique_path(): could not create a unique path with name %s", *path);
    return; /* Never reached */
}

/**
 * The method should work across different platforms/compilers.
 *
 * @path The path to the directory
 *
 * @return 0 on successful completion, and -1 on error.
 */
int IOHprofiler_remove_directory(const char *path) {
#if _MSC_VER
    WIN32_FIND_DATA find_data_file;
    HANDLE find_handle = NULL;
    char *buf;
    int r = -1;
    int r2 = -1;

    buf = IOHprofiler_strdupf("%s\\*.*", path);
    /* Nothing to do if the folder does not exist */
    if ((find_handle = FindFirstFile(buf, &find_data_file)) == INVALID_HANDLE_VALUE) {
        IOHprofiler_free_memory(buf);
        return 0;
    }
    IOHprofiler_free_memory(buf);

    do {
        r = 0;

        /* Skip the names "." and ".." as we don't want to recurse on them */
        if (strcmp(find_data_file.cFileName, ".") != 0 && strcmp(find_data_file.cFileName, "..") != 0) {
            /* Build the new path using the argument path the file/folder name we just found */
            buf = IOHprofiler_strdupf("%s\\%s", path, find_data_file.cFileName);

            if (find_data_file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                /* Buf is a directory, recurse on it */
                r2 = IOHprofiler_remove_directory(buf);
            } else {
                /* Buf is a file, delete it */
                /* Careful, DeleteFile returns 0 if it fails and nonzero otherwise! */
                r2 = -(DeleteFile(buf) == 0);
            }

            IOHprofiler_free_memory(buf);
        }

        r = r2;

    } while (FindNextFile(find_handle, &find_data_file)); /* Find the next file */

    FindClose(find_handle);

    if (!r) {
        /* Path is an empty directory, delete it */
        /* Careful, RemoveDirectory returns 0 if it fails and nonzero otherwise! */
        r = -(RemoveDirectory(path) == 0);
    }

    return r;
#else
    DIR *d = opendir(path);
    int r = -1;
    int r2 = -1;
    char *buf;

    /* Nothing to do if the folder does not exist */
    if (!IOHprofiler_directory_exists(path))
        return 0;

    if (d) {
        struct dirent *p;

        r = 0;

        while (!r && (p = readdir(d))) {
            /* Skip the names "." and ".." as we don't want to recurse on them */
            if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, "..")) {
                continue;
            }

            buf = IOHprofiler_strdupf("%s/%s", path, p->d_name);
            if (buf) {
                if (IOHprofiler_directory_exists(buf)) {
                    /* Buf is a directory, recurse on it */
                    r2 = IOHprofiler_remove_directory(buf);
                } else {
                    /* Buf is a file, delete it */
                    r2 = unlink(buf);
                }
            }
            IOHprofiler_free_memory(buf);

            r = r2;
        }

        closedir(d);
    }

    if (!r) {
        /* Path is an empty directory, delete it */
        r = rmdir(path);
    }

    return r;
#endif
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding memory allocations
 */
/**@{*/
double *IOHprofiler_allocate_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(double);
    return (double *)IOHprofiler_allocate_memory(block_size);
}

int *IOHprofiler_allocate_int_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(int);
    return (int *)IOHprofiler_allocate_memory(block_size);
}
/**
 * @brief Allocates memory for a vector and sets all its elements to value.
 */
static double *IOHprofiler_allocate_vector_with_value(const size_t number_of_elements, double value) {
    const size_t block_size = number_of_elements * sizeof(double);
    double *vector = (double *)IOHprofiler_allocate_memory(block_size);
    size_t i;

    for (i = 0; i < number_of_elements; i++)
        vector[i] = value;

    return vector;
}

/**
 * @brief Safe memory allocation for a vector with size_t elements that either succeeds or triggers a
 * IOHprofiler_error.
 */
static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(size_t);
    return (size_t *)IOHprofiler_allocate_memory(block_size);
}

static char *IOHprofiler_allocate_string(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(char);
    return (char *)IOHprofiler_allocate_memory(block_size);
}

static double *IOHprofiler_duplicate_vector(const double *src, const size_t number_of_elements) {
    size_t i;
    double *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}

static int *IOHprofiler_duplicate_int_vector(const int *src, const size_t number_of_elements) {
    size_t i;
    int *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_int_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding string options
 */
/**@{*/

/**
 * @brief Allocates an option keys structure holding the given number of option keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_allocate(const size_t count, const char **keys) {
    size_t i;
    IOHprofiler_option_keys_t *option_keys;

    if ((count == 0) || (keys == NULL))
        return NULL;

    option_keys = (IOHprofiler_option_keys_t *)IOHprofiler_allocate_memory(sizeof(*option_keys));

    option_keys->keys = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));
    for (i = 0; i < count; i++) {
        assert(keys[i]);
        option_keys->keys[i] = IOHprofiler_strdup(keys[i]);
    }
    option_keys->count = count;

    return option_keys;
}

/**
 * @brief Frees the given option keys structure.
 */
static void IOHprofiler_option_keys_free(IOHprofiler_option_keys_t *option_keys) {
    size_t i;

    if (option_keys) {
        for (i = 0; i < option_keys->count; i++) {
            IOHprofiler_free_memory(option_keys->keys[i]);
        }
        IOHprofiler_free_memory(option_keys->keys);
        IOHprofiler_free_memory(option_keys);
    }
}

/**
 * @brief Returns redundant option keys (the ones present in given_option_keys but not in known_option_keys).
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_get_redundant(const IOHprofiler_option_keys_t *known_option_keys,
                                                                        const IOHprofiler_option_keys_t *given_option_keys) {
    size_t i, j, count = 0;
    int found;
    char **redundant_keys;
    IOHprofiler_option_keys_t *redundant_option_keys;

    assert(known_option_keys != NULL);
    assert(given_option_keys != NULL);

    /* Find the redundant keys */
    redundant_keys = (char **)IOHprofiler_allocate_memory(given_option_keys->count * sizeof(char *));
    for (i = 0; i < given_option_keys->count; i++) {
        found = 0;
        for (j = 0; j < known_option_keys->count; j++) {
            if (strcmp(given_option_keys->keys[i], known_option_keys->keys[j]) == 0) {
                found = 1;
                break;
            }
        }
        if (!found) {
            redundant_keys[count++] = IOHprofiler_strdup(given_option_keys->keys[i]);
        }
    }
    redundant_option_keys = IOHprofiler_option_keys_allocate(count, (const char **)redundant_keys);

    /* Free memory */
    for (i = 0; i < count; i++) {
        IOHprofiler_free_memory(redundant_keys[i]);
    }
    IOHprofiler_free_memory(redundant_keys);

    return redundant_option_keys;
}

/**
 * @brief Adds additional option keys to the given basic option keys (changes the basic keys).
 */
static void IOHprofiler_option_keys_add(IOHprofiler_option_keys_t **basic_option_keys,
                                        const IOHprofiler_option_keys_t *additional_option_keys) {
    size_t i, j;
    size_t new_count;
    char **new_keys;
    IOHprofiler_option_keys_t *new_option_keys;

    assert(*basic_option_keys != NULL);
    if (additional_option_keys == NULL)
        return;

    /* Construct the union of both keys */
    new_count = (*basic_option_keys)->count + additional_option_keys->count;
    new_keys = (char **)IOHprofiler_allocate_memory(new_count * sizeof(char *));
    for (i = 0; i < (*basic_option_keys)->count; i++) {
        new_keys[i] = IOHprofiler_strdup((*basic_option_keys)->keys[i]);
    }
    for (j = 0; j < additional_option_keys->count; j++) {
        new_keys[(*basic_option_keys)->count + j] = IOHprofiler_strdup(additional_option_keys->keys[j]);
    }
    new_option_keys = IOHprofiler_option_keys_allocate(new_count, (const char **)new_keys);

    /* Free the old basic keys */
    IOHprofiler_option_keys_free(*basic_option_keys);
    *basic_option_keys = new_option_keys;
    for (i = 0; i < new_count; i++) {
        IOHprofiler_free_memory(new_keys[i]);
    }
    IOHprofiler_free_memory(new_keys);
}

/**
 * @brief Creates an instance of option keys from the given string of options containing keys and values
 * separated by colons.
 *
 * @note Relies heavily on the "key: value" format and might fail if the number of colons doesn't match the
 * number of keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys(const char *option_string) {
    size_t i;
    char **keys;
    IOHprofiler_option_keys_t *option_keys = NULL;
    char *string_to_parse, *key;

    /* Check for empty string */
    if ((option_string == NULL) || (strlen(option_string) == 0)) {
        return NULL;
    }

    /* Split the options w.r.t ':' */
    keys = IOHprofiler_string_split(option_string, ':');

    if (keys) {
        /* Keys now contain something like this: "values_of_previous_key this_key" except for the first, which
     * contains only the key and the last, which contains only the previous values */
        for (i = 0; *(keys + i); i++) {
            string_to_parse = IOHprofiler_strdup(*(keys + i));

            /* Remove any leading and trailing spaces */
            string_to_parse = IOHprofiler_string_trim(string_to_parse);

            /* Stop if this is the last substring (contains a value and no key) */
            if ((i > 0) && (*(keys + i + 1) == NULL)) {
                IOHprofiler_free_memory(string_to_parse);
                break;
            }

            /* Disregard everything before the last space */
            key = strrchr(string_to_parse, ' ');
            if ((key == NULL) || (i == 0)) {
                /* No spaces left (or this is the first key), everything is the key */
                key = string_to_parse;
            } else {
                /* Move to the start of the key (one char after the space) */
                key++;
            }

            /* Put the key in keys */
            IOHprofiler_free_memory(*(keys + i));
            *(keys + i) = IOHprofiler_strdup(key);
            IOHprofiler_free_memory(string_to_parse);
        }

        option_keys = IOHprofiler_option_keys_allocate(i, (const char **)keys);

        /* Free the keys */
        for (i = 0; *(keys + i); i++) {
            IOHprofiler_free_memory(*(keys + i));
        }
        IOHprofiler_free_memory(keys);
    }

    return option_keys;
}

/**
 * @brief Creates and returns a string containing the info_string and all keys from option_keys.
 *
 * Can be used to output information about the given option_keys.
 */
static char *IOHprofiler_option_keys_get_output_string(const IOHprofiler_option_keys_t *option_keys,
                                                       const char *info_string) {
    size_t i;
    char *string = NULL, *new_string;

    if ((option_keys != NULL) && (option_keys->count > 0)) {
        string = IOHprofiler_strdup(info_string);
        for (i = 0; i < option_keys->count; i++) {
            new_string = IOHprofiler_strdupf("%s %s\n", string, option_keys->keys[i]);
            IOHprofiler_free_memory(string);
            string = new_string;
        }
    }

    return string;
}

/**
 * @brief Parses options in the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - value needs to be a single string (no spaces allowed)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read(const char *options, const char *name, const char *format, void *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing whitespaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    return sscanf(&options[i2], format, pointer);
}

/**
 * @brief Reads an integer from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be an integer
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_int(const char *options, const char *name, int *pointer) {
    return IOHprofiler_options_read(options, name, " %i", pointer);
}

/**
 * @brief Reads a size_t from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a size_t
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_size_t(const char *options, const char *name, size_t *pointer) {
    return IOHprofiler_options_read(options, name, "%lu", pointer);
}

/**
 * @brief Reads a double value from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a double
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_double(const char *options, const char *name, double *pointer) {
    return IOHprofiler_options_read(options, name, "%lf", pointer);
}

/**
 * @brief Reads a string from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a string - either a single word or multiple words
 * in double quotes
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_string(const char *options, const char *name, char *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    if (options[i2] == '\"') {
        /* The value starts with a quote: read everything between two quotes into a string */
        return sscanf(&options[i2], "\"%[^\"]\"", pointer);
    } else
        return sscanf(&options[i2], "%s", pointer);
}

/**
 * @brief Reads (possibly delimited) values from options using the form "name1: value1,value2,value3 name2: value4",
 * i.e. reads all characters from the corresponding name up to the next whitespace or end of string.
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_values(const char *options, const char *name, char *pointer) {
    long i1, i2;
    int i;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    i = 0;
    while (!isspace((unsigned char)options[i2 + i]) && (options[i2 + i] != '\0')) {
        pointer[i] = options[i2 + i];
        i++;
    }
    pointer[i] = '\0';
    return i;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods implementing functions on double values not contained in C89 standard
 */
/**@{*/

/**
 * @brief Rounds the given double to the nearest integer.
 */
static double IOHprofiler_double_round(const double number) {
    return floor(number + 0.5);
}

/**
 * @brief Returns the maximum of a and b.
 */
static double IOHprofiler_double_max(const double a, const double b) {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Returns the minimum of a and b.
 */
static double IOHprofiler_double_min(const double a, const double b) {
    if (a <= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Performs a "safer" double to size_t conversion.
 */
static size_t IOHprofiler_double_to_size_t(const double number) {
    return (size_t)IOHprofiler_double_round(number);
}

/**
 * @brief  Returns 1 if |a - b| < precision and 0 otherwise.
 */
static int IOHprofiler_double_almost_equal(const double a, const double b, const double precision) {
    return (fabs(a - b) < precision);
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods handling NAN and INFINITY
 */
/**@{*/

/**
 * @brief Returns 1 if x is NAN and 0 otherwise.
 */
static int IOHprofiler_is_nan(const int x) {
    /*return (isnan(x) || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
*/
    return (0 || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
}

/**
 * @brief Returns 1 if the input vector of dimension dim contains any NAN values and 0 otherwise.
 */
static int IOHprofiler_vector_contains_nan(const int *x, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        if (IOHprofiler_is_nan(x[i]))
            return 1;
    }
    return 0;
}

/**
 * @brief Sets all dim values of y to NAN.
 */
static void IOHprofiler_vector_set_to_nan(double *y, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        y[i] = NAN;
    }
}

/**
 * @brief Returns 1 if x is INFINITY and 0 otherwise.
 */
static int IOHprofiler_is_inf(const int x) {
    if (IOHprofiler_is_nan(x))
        return 0;
    /*return (isinf(x) || (x <= -INFINITY) || (x >= INFINITY));*/
    return (0 || (x <= -INFINITY) || (x >= INFINITY));
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Miscellaneous methods
 */
/**@{*/

/**
 * @brief Returns the current time as a string.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_current_time_get_string(void) {
    time_t timer;
    char *time_string = IOHprofiler_allocate_string(30);
    struct tm *tm_info;
    time(&timer);
    tm_info = localtime(&timer);
    assert(tm_info != NULL);
    strftime(time_string, 30, "%d.%m.%y %H:%M:%S", tm_info);
    return time_string;
}

/**
 * @brief Returns the number of positive numbers pointed to by numbers (the count stops when the first
 * 0 is encountered of max_count numbers have been read).
 *
 * If there are more than max_count numbers, a IOHprofiler_error is raised. The name argument is used
 * only to provide more informative output in case of any problems.
 */
static size_t IOHprofiler_count_numbers(const size_t *numbers, const size_t max_count, const char *name) {
    size_t count = 0;
    while ((count < max_count) && (numbers[count] != 0)) {
        count++;
    }
    if (count == max_count) {
        IOHprofiler_error("IOHprofiler_count_numbers(): over %lu numbers in %s", (unsigned long)max_count, name);
        return 0; /* Never reached*/
    }

    return count;
}

/**@}*/

/***********************************************************************************************************/
#endif
#line 18 "code-experiments/src/profiler/IOHprofiler_suite.c"

/** the source files for additional suites*/
#line 1 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
/**
 * @file suite_IOHprofiler.c
 * @brief Implementation of the IOHprofiler suite containing 24 noiseless single-objective functions in 6
 * dimensions.
 */

#ifndef IOHPROFILER
#define IOHPROFILER
#line 1 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler.h"
/**
 * @file IOHprofiler.h
 * @brief All public IOHprofiler functions and variables are defined in this file.
 *
 * It is the authoritative reference, if any function deviates from the documented behavior it is considered
 * a bug. See the function definitions for their detailed descriptions.
 */

#ifndef __IOHprofiler_H__
#define __IOHprofiler_H__

#include <stddef.h>

/* Definitions of some 32 and 64-bit types (used by the random number generator) */
#ifdef _MSC_VER
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

/* Include definition for NAN among other things */
#include <float.h>
#include <math.h>
#ifndef NAN
/** @brief Definition of NAN to be used only if undefined by the included headers */
#define NAN 8.8888e88
#endif
#ifndef isnan
/** @brief Definition of isnan to be used only if undefined by the included headers */
#define isnan(x) (0)
#endif
#ifndef INFINITY
/** @brief Definition of INFINITY to be used only if undefined by the included headers */
#define INFINITY 1e22
/* why not using 1e99? */
#endif
#ifndef isinf
/** @brief Definition of isinf to be used only if undefined by the included headers */
#define isinf(x) (0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief IOHprofiler's version.
 *
 * Automatically updated by do.py.
 */
/**@{*/
static const char IOHprofiler_version[32] = "";
/**@}*/

/***********************************************************************************************************/
/**
 * @brief IOHprofiler's own pi constant. Simplifies the case, when the value of pi changes.
 */
/**@{*/
static const double IOHprofiler_pi = 3.14159265358979323846;
/**@}*/

/***********************************************************************************************************/

/** @brief Logging level type. */
typedef enum {
    IOHprofiler_ERROR,   /**< @brief only error messages are output */
    IOHprofiler_WARNING, /**< @brief error and warning messages are output */
    IOHprofiler_INFO,    /**< @brief error, warning and info messages are output */
    IOHprofiler_DEBUG    /**< @brief error, warning, info and debug messages are output */
} IOHprofiler_log_level_type_e;

/***********************************************************************************************************/

/** @brief Structure containing a IOHprofiler problem. */
struct IOHprofiler_problem_s;

/**
 * @brief The IOHprofiler problem type.
 *
 * See IOHprofiler_problem_s for more information on its fields. */
typedef struct IOHprofiler_problem_s IOHprofiler_problem_t;

/** @brief Structure containing a IOHprofiler suite. */
struct IOHprofiler_suite_s;

/**
 * @brief The IOHprofiler suite type.
 *
 * See IOHprofiler_suite_s for more information on its fields. */
typedef struct IOHprofiler_suite_s IOHprofiler_suite_t;

/** @brief Structure containing a IOHprofiler observer. */
struct IOHprofiler_observer_s;

/**
 * @brief The IOHprofiler observer type.
 *
 * See IOHprofiler_observer_s for more information on its fields. */
typedef struct IOHprofiler_observer_s IOHprofiler_observer_t;

/** @brief Structure containing a IOHprofiler archive. */
struct IOHprofiler_archive_s;

/**
 * @brief The IOHprofiler archive type.
 *
 * See IOHprofiler_archive_s for more information on its fields. */
typedef struct IOHprofiler_archive_s IOHprofiler_archive_t;

/** @brief Structure containing a IOHprofiler random state. */
struct IOHprofiler_random_state_s;

/**
 * @brief The IOHprofiler random state type.
 *
 * See IOHprofiler_random_state_s for more information on its fields. */
typedef struct IOHprofiler_random_state_s IOHprofiler_random_state_t;

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler suite
 */
/**@{*/

/**
 * @brief Constructs a IOHprofiler suite.
 */
IOHprofiler_suite_t *IOHprofiler_suite(const char *suite_name, const char *suite_instance, const char *suite_options,int number, char** layer_param,char * temp_dim);

/**
 * @brief Frees the given suite.
 */
void IOHprofiler_suite_free(IOHprofiler_suite_t *suite);

/**
 * @brief Returns the next (observed) problem of the suite or NULL if there is no next problem left.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_next_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 *
 * @returns The current problem of the suite.
 */
IOHprofiler_problem_t *IOHprofiler_suite_reset_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 * @brief Returns the problem of the suite defined by problem_index.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_problem(IOHprofiler_suite_t *suite, const size_t problem_index);

/**
 * @brief Returns the number of problems in the given suite.
 */
size_t IOHprofiler_suite_get_number_of_problems(const IOHprofiler_suite_t *suite);

/**
 * @brief Returns the function number in the suite in position function_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_function_from_function_index(const IOHprofiler_suite_t *suite, const size_t function_idx);

/**
 * @brief Returns the dimension number in the suite in position dimension_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_dimension_from_dimension_index(const IOHprofiler_suite_t *suite, const size_t dimension_idx);

/**
 * @brief Returns the instance number in the suite in position instance_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_instance_from_instance_index(const IOHprofiler_suite_t *suite, const size_t instance_idx);
/**@}*/

/**
 * @name Encoding/decoding problem index
 *
 * General schema for encoding/decoding a problem index. Note that the index depends on the number of
 * instances a suite is defined with (it should be called a suite-instance-depending index...).
 * Also, while functions, instances and dimensions start from 1, function_idx, instance_idx and dimension_idx
 * as well as suite_dep_index start from 0!
 *
 * Showing an example with 2 dimensions (2, 3), 5 instances (6, 7, 8, 9, 10) and 2 functions (1, 2):
 *
   \verbatim
   index | instance | function | dimension
   ------+----------+----------+-----------
       0 |        6 |        1 |         2
       1 |        7 |        1 |         2
       2 |        8 |        1 |         2
       3 |        9 |        1 |         2
       4 |       10 |        1 |         2
       5 |        6 |        2 |         2
       6 |        7 |        2 |         2
       7 |        8 |        2 |         2
       8 |        9 |        2 |         2
       9 |       10 |        2 |         2
      10 |        6 |        1 |         3
      11 |        7 |        1 |         3
      12 |        8 |        1 |         3
      13 |        9 |        1 |         3
      14 |       10 |        1 |         3
      15 |        6 |        2 |         2
      16 |        7 |        2 |         3
      17 |        8 |        2 |         3
      18 |        9 |        2 |         3
      19 |       10 |        2 |         3

   index | instance_idx | function_idx | dimension_idx
   ------+--------------+--------------+---------------
       0 |            0 |            0 |             0
       1 |            1 |            0 |             0
       2 |            2 |            0 |             0
       3 |            3 |            0 |             0
       4 |            4 |            0 |             0
       5 |            0 |            1 |             0
       6 |            1 |            1 |             0
       7 |            2 |            1 |             0
       8 |            3 |            1 |             0
       9 |            4 |            1 |             0
      10 |            0 |            0 |             1
      11 |            1 |            0 |             1
      12 |            2 |            0 |             1
      13 |            3 |            0 |             1
      14 |            4 |            0 |             1
      15 |            0 |            1 |             1
      16 |            1 |            1 |             1
      17 |            2 |            1 |             1
      18 |            3 |            1 |             1
      19 |            4 |            1 |             1
   \endverbatim
 */
/**@{*/
/**
 * @brief Computes the index of the problem in the suite that corresponds to the given function, dimension
 * and instance indices.
 */
size_t IOHprofiler_suite_encode_problem_index(const IOHprofiler_suite_t *suite,
                                              const size_t function_idx,
                                              const size_t dimension_idx,
                                              const size_t instance_idx);

/**
 * @brief Computes the function, dimension and instance indexes of the problem with problem_index in the
 * given suite.
 */
void IOHprofiler_suite_decode_problem_index(const IOHprofiler_suite_t *suite,
                                            const size_t problem_index,
                                            size_t *function_idx,
                                            size_t *dimension_idx,
                                            size_t *instance_idx);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler observer
 */
/**@{*/
/**
 * @brief Constructs a IOHprofiler observer.
 */
IOHprofiler_observer_t *IOHprofiler_observer(const char *observer_name, const char *options);

/**
 * @brief Frees the given observer.
 */
void IOHprofiler_observer_free(IOHprofiler_observer_t *observer);

/**
 * @brief Adds an observer to the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_add_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**
 * @brief Removes an observer from the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_remove_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler problem
 */
/**@{*/
/**
 * @brief Evaluates the problem function in point x and save the result in y.
  logger_** functions use number_of_parameters and parameters to log extra informations of algorithms' adaptive parameters.
  If there is no need to log parameters, set number_of_parameters and parameters as 0 and NULL respectively.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Evaluates the problem constraints in point x and save the result in y.
 */
void IOHprofiler_evaluate_constraint(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Recommends a solution as the current best guesses to the problem.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief Frees the given problem.
 */
void IOHprofiler_problem_free(IOHprofiler_problem_t *problem);

void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters);

/**
 * @brief Returns the name of the problem.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the ID of the problem.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of variables i.e. the dimension of the problem.
 */
size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of objectives of the problem.
 */
size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of evaluations done on the problem.
 */
size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns 1 if the final target was hit, 0 otherwise.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the best observed value for the first objective.
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the target value for the first objective.
 */
double depreciated_IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with lower bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with upper bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the problem_index of the problem in its current suite.
 */
size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns an initial solution, i.e. a feasible variable setting, to the problem.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding random numbers
 */
/**@{*/

/**
 * @brief Creates and returns a new random number state using the given seed.
 */
IOHprofiler_random_state_t *IOHprofiler_random_new(uint32_t seed);

/**
 * @brief Frees all memory associated with the random state.
 */
void IOHprofiler_random_free(IOHprofiler_random_state_t *state);

/**
 * @brief Returns one uniform [0, 1) random value from the random number generator associated with the given
 * state.
 */
double IOHprofiler_random_uniform(IOHprofiler_random_state_t *state);

/**
 * @brief Generates an approximately normal random number.
 */
double IOHprofiler_random_normal(IOHprofiler_random_state_t *state);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods managing memory
 */
/**@{*/
/**
 * @brief Safe memory allocation that either succeeds or triggers a IOHprofiler_error.
 */
void *IOHprofiler_allocate_memory(const size_t size);

/**
 * @brief Safe memory allocation for a vector of doubles that either succeeds or triggers a IOHprofiler_error.
 */
double *IOHprofiler_allocate_vector(const size_t size);

/**
 * @brief Safe memory allocation for a vector of int that either succeeds or triggers a IOHprofiler_error.
 */
int *IOHprofiler_allocate_int_vector(const size_t size);

/**
 * @brief Frees the allocated memory.
 */
void IOHprofiler_free_memory(void *data);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler messages
 */
/**@{*/
/**
 * @brief Signals a fatal error.
 */
void IOHprofiler_error(const char *message, ...);

/**
 * @brief Warns about error conditions.
 */
void IOHprofiler_warning(const char *message, ...);

/**
 * @brief Outputs some information.
 */
void IOHprofiler_info(const char *message, ...);

/**
 * @brief Prints only the given message without any prefix and new line.
 *
 * A function similar to IOHprofiler_info but producing no additional text than
 * the given message.
 *
 * The output is only produced if IOHprofiler_log_level >= IOHprofiler_INFO.
 */
void IOHprofiler_info_partial(const char *message, ...);

/**
 * @brief Outputs detailed information usually used for debugging.
 */
void IOHprofiler_debug(const char *message, ...);

/**
 * @brief Sets the IOHprofiler log level to the given value and returns the previous value of the log level.
 */
const char *IOHprofiler_set_log_level(const char *level);
/**@}*/

/***********************************************************************************************************/

/**
 * @brief Constructs a IOHprofiler archive.
 */
IOHprofiler_archive_t *IOHprofiler_archive(const char *suite_name,
                                           const size_t function,
                                           const size_t dimension,
                                           const size_t instance);
/**
 * @brief Adds a solution with objectives (y1, y2) to the archive if none of the existing solutions in the
 * archive dominates it. In this case, returns 1, otherwise the archive is not updated and the method
 * returns 0.
 */

int IOHprofiler_archive_add_solution(IOHprofiler_archive_t *archive, const double y1, const double y2, const char *text);

/**
 * @brief Returns the number of (non-dominated) solutions in the archive (computed first, if needed).
 */
size_t IOHprofiler_archive_get_number_of_solutions(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the hypervolume of the archive (computed first, if needed).
 */
double IOHprofiler_archive_get_hypervolume(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the text of the next (non-dominated) solution in the archive and "" when there are no
 * solutions left. The first two solutions are always the extreme ones.
 */
const char *IOHprofiler_archive_get_next_solution_text(IOHprofiler_archive_t *archive);

/**
 * @brief Frees the archive.
 */
void IOHprofiler_archive_free(IOHprofiler_archive_t *archive);

/***********************************************************************************************************/

/**
 * @name Other useful methods
 */
/**@{*/
/**
 * @brief Removes the given directory and all its contents.
 */
int IOHprofiler_remove_directory(const char *path);

/**
 * @brief Formatted string duplication.
 */
char *IOHprofiler_strdupf(const char *str, ...);
/**@}*/

/***********************************************************************************************************/
typedef int (*int_to_int_func)(int);

struct WModel{
  size_t number_of_layers;
  int *layer1;
  int min1; int_to_int_func l_max1;
  int *layer2;
  int min2;int_to_int_func l_max2;
  int *layer3;
  int min3; int_to_int_func l_max3;
  int *layer4;
  int min4; int_to_int_func l_max4;
  int *counter;
};


#ifdef __cplusplus
}
#endif
#endif
#line 10 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#endif

#line 1 "code-experiments/src/profiler/../suite/PBO/f_binary.c"
/*
 * @Binary Funtion
 */

/**
 * @file f_binary.c
 * @brief Implementation of the binary function and problem.
 */

#include <assert.h>
#include <math.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 17 "code-experiments/src/profiler/../suite/PBO/f_binary.c"
#endif

#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 1 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_problem.c"
/**
 * @file IOHprofiler_problem.c
 * @brief Definitions of functions regarding IOHprofiler problems.
 */
#ifndef IOH_PROFILER_PROBLEM
#define IOH_PROFILER_PROBLEM

#include <float.h>
#line 10 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_problem.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_internal.h"
/**
 * @file IOHprofiler_internal.h
 * @brief Definitions of internal IOHprofiler structures and typedefs.
 *
 * These are used throughout the IOHprofiler code base but should not be used by any external code.
 */

#ifndef __IOHprofiler_INTERNAL__
#define __IOHprofiler_INTERNAL__

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************************************/
/**
 * @brief The data free function type.
 *
 * This is a template for functions that free the contents of data (used to free the contents of data
 * fields in IOHprofiler_problem, IOHprofiler_suite and IOHprofiler_observer).
 */
typedef void (*IOHprofiler_data_free_function_t)(void *data);

/**
 * @brief The problem free function type.
 *
 * This is a template for functions that free the problem structure.
 */
typedef void (*IOHprofiler_problem_free_function_t)(IOHprofiler_problem_t *problem);

/**
 * @brief The initial solution function type.
 *
 * This is a template for functions that return an initial solution of the problem.
 */
typedef void (*IOHprofiler_initial_solution_function_t)(const IOHprofiler_problem_t *problem, int *x);

/**
 * @brief The evaluate function type.
 *
 * This is a template for functions that perform an evaluation of the problem (to evaluate the problem
 * function, the problems constraints etc.).
 */
typedef void (*IOHprofiler_evaluate_function_t)(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief The recommend solutions function type.
 *
 * This is a template for functions that log a recommended solution.
 */
typedef void (*IOHprofiler_recommend_function_t)(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief The allocate logger function type.
 *
 * This is a template for functions that allocate a logger (wrap a logger around the given problem and return
 * the wrapped problem).
 */
typedef IOHprofiler_problem_t *(*IOHprofiler_logger_allocate_function_t)(IOHprofiler_observer_t *observer,
                                                                         IOHprofiler_problem_t *problem);

/**
 * @brief The transformed IOHprofiler problem data type.
 *
 * This is a type of a generic structure for a transformed ("outer") IOHprofiler_problem. It makes possible the
 * wrapping of problems as layers of an onion. Initialized in the IOHprofiler_problem_transformed_allocate function,
 * it makes the current ("outer") transformed problem a "derived problem class", which inherits from the
 * "inner" problem, the "base class".
 *
 * From the perspective of the inner problem:
 * - data holds the meta-information to administer the inheritance
 * - data->data holds the additional fields of the derived class (the outer problem)
 * - data->inner_problem points to the inner problem (now we have a linked list)
 */
typedef struct {
    IOHprofiler_problem_t *inner_problem;                /**< @brief Pointer to the inner problem */
    void *data;                                          /**< @brief Pointer to data, which enables further
                                                  wrapping of the problem */
    IOHprofiler_data_free_function_t data_free_function; /**< @brief Function to free the contents of data */
} IOHprofiler_problem_transformed_data_t;

/**
 * @brief The free logger function type.
 *
 * This is a template for functions that free a logger.
 */
typedef void (*IOHprofiler_logger_free_function_t)(void *logger);

/**
 * @brief The stacked IOHprofiler problem data type.
 *
 * This is a type of a structure used when stacking two problems (especially useful for constructing
 * multi-objective problems).
 */
typedef struct {
    IOHprofiler_problem_t *problem1; /**< @brief Pointer to the first problem (objective) */
    IOHprofiler_problem_t *problem2; /**< @brief Pointer to the second problem (objective) */
} IOHprofiler_problem_stacked_data_t;

/**
 * @brief The option keys data type.
 *
 * This is a type of a structure used to contain a set of known option keys (used by suites and observers).
 */
typedef struct {
    size_t count; /**< @brief Number of option keys */
    char **keys;  /**< @brief Pointer to option keys */
} IOHprofiler_option_keys_t;

/***********************************************************************************************************/

/**
 * @brief The IOHprofiler problem structure.
 *
 * This is one of the main structures in IOHprofiler. It contains information about a problem to be optimized. The
 * problems can be wrapped around each other (similar to the onion layers) by means of the data field and
 * the IOHprofiler_problem_transformed_data_t structure creating some kind of "object inheritance". Even the logger
 * is considered as just another IOHprofiler_problem instance wrapped around the original problem.
 */
struct IOHprofiler_problem_s {
    IOHprofiler_initial_solution_function_t initial_solution;  /**< @brief  The function for creating an initial solution. */
    IOHprofiler_evaluate_function_t evaluate_function;         /**< @brief  The function for evaluating the problem. */
    IOHprofiler_recommend_function_t recommend_solution;       /**< @brief  The function for recommending a solution. */
    IOHprofiler_problem_free_function_t problem_free_function; /**< @brief  The function for freeing this problem. */

    size_t dimension; /**< @brief Number of variables expected before any transformation, used for logging files. */
    size_t number_of_variables;  /**< @brief Number of variables expected by the function, i.e.
                                       problem dimension */
    size_t number_of_objectives; /**< @brief Number of objectives. */
    size_t number_of_parameters; /**<  IOHprofiler @brief Number of parameters. */

    int *smallest_values_of_interest; /**< @brief The lower bounds of the ROI in the decision space. */
    int *largest_values_of_interest;  /**< @brief The upper bounds of the ROI in the decision space. */

    double *best_value;  /**< @brief Optimal (smallest) function value */
    double *nadir_value; /**< @brief The nadir point (defined when number_of_objectives > 1) */
    int *best_parameter; /**< @brief Optimal decision vector (defined only when unique) */
    double *parameters;  /** IOHprofiler @brief parameters setting */
    double *raw_fitness;

    char *problem_name; /**< @brief Problem name. */
    char *problem_id;   /**< @brief Problem ID (unique in the containing suite) */
    char *problem_type; /**< @brief Problem type */

    size_t evaluations; /**< @brief Number of evaluations performed on the problem. */

    /* Convenience fields for output generation */

    double final_target_delta[1];       /**< @brief Final target delta. */
    double best_observed_fvalue[1];     /**< @brief The best observed value so far. */
    size_t best_observed_evaluation[1]; /**< @brief The evaluation when the best value so far was achieved. */

    /* Fields depending on the containing benchmark suite */

    IOHprofiler_suite_t *suite; /**< @brief Pointer to the containing suite (NULL if not given) */
    size_t suite_dep_index;     /**< @brief Suite-depending problem index (starting from 0) */
    size_t suite_dep_function;  /**< @brief Suite-depending function */
    size_t suite_dep_instance;  /**< @brief Suite-depending instance */

    void *data; /**< @brief Pointer to a data instance @see IOHprofiler_problem_transformed_data_t */
};

/**
 * @brief The IOHprofiler observer structure.
 *
 * An observer observes the whole benchmark process. It is independent of suites and problems. Each time a
 * new problem of the suite is being observed, the observer initializes a new logger (wraps the observed
 * problem with the corresponding logger).
 */
struct IOHprofiler_observer_s {
    int is_active;         /**< @brief Whether the observer is active (the logger will log some output). */
    char *observer_name;   /**< @brief Name of the observer for identification purposes. */
    char *result_folder;   /**< @brief Name of the result folder. */
    char *algorithm_name;  /**< @brief Name of the algorithm to be used in logger output. */
    char *algorithm_info;  /**< @brief Additional information on the algorithm to be used in logger output. */
    char *parameters_name; /**< @brief Name of recorded parameters to be used in logger output. */
    size_t number_target_triggers;
    /**< @brief The number of targets between each 10**i and 10**(i+1). */
    double target_precision; /**< @brief The minimal precision used for targets. */
    size_t number_evaluation_triggers;
    /**< @brief The number of triggers between each 10**i and 10**(i+1) evaluation number. */
    char *base_evaluation_triggers;
    /**< @brief The "base evaluations" used to evaluations that trigger logging. */
    size_t number_interval_triggers;
    /**< @brief The size of interval between two triggers. */
    char *complete_triggers; /**< @brief The symbol for recording all evaluation. */

    int precision_x; /**< @brief Output precision for decision variables. */
    int precision_f; /**< @brief Output precision for function values. */
    void *data;      /**< @brief Void pointer that can be used to point to data specific to an observer. */

    IOHprofiler_data_free_function_t data_free_function;             /**< @brief  The function for freeing this observer. */
    IOHprofiler_logger_allocate_function_t logger_allocate_function; /**< @brief  The function for allocating the logger. */
    IOHprofiler_logger_free_function_t logger_free_function;         /**< @brief  The function for freeing the logger. */
};

/**
 * @brief The IOHprofiler suite structure.
 *
 * A suite is a collection of problems constructed by a Cartesian product of the suite's optimization
 * functions, dimensions and instances. The functions and dimensions are fixed for a suite with some name,
 * while the instances are defined dynamically. The suite can be filtered - only the chosen functions,
 * dimensions and instances will be taken into account when iterating through the suite.
 */
struct IOHprofiler_suite_s {
    char *suite_name; /**< @brief Name of the suite. */

    size_t number_of_dimensions; /**< @brief Number of dimensions contained in the suite. */
    size_t *dimensions;          /**< @brief The dimensions contained in the suite. */

    size_t number_of_functions; /**< @brief Number of functions contained in the suite. */
    size_t *functions;          /**< @brief The functions contained in the suite. */

    size_t number_of_instances; /**< @brief Number of instances contained in the suite. */
    char *default_instances;    /**< @brief The instances contained in the suite by default. */
    size_t *instances;          /**< @brief The instances contained in the suite. */

    IOHprofiler_problem_t *current_problem; /**< @brief Pointer to the currently tackled problem. */
    long current_dimension_idx;             /**< @brief The dimension index of the currently tackled problem. */
    long current_function_idx;              /**< @brief The function index of the currently tackled problem. */
    long current_instance_idx;              /**< @brief The instance index of the currently tackled problem. */

    void *data; /**< @brief Void pointer that can be used to point to data specific to a suite. */

    IOHprofiler_data_free_function_t data_free_function; /**< @brief The function for freeing this suite. */
};

#ifdef __cplusplus
}
#endif
#endif
#line 11 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_problem.c"

#line 1 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_utilities.c"
/**
 * @file IOHprofiler_utilities.c
 * @brief Definitions of miscellaneous functions used throughout the IOHprofiler framework.
 */
#ifndef IOH_PROFILER_UTILITIES
#define IOH_PROFILER_UTILITIES

#line 1 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_platform.h"
/**
 * @file IOHprofiler_platform.h
 * @brief Automatic platform-dependent configuration of the IOHprofiler framework.
 *
 * Some platforms and standard conforming compilers require extra defines or includes to provide some
 * functionality.
 *
 * Because most feature defines need to be set before the first system header is included and we do not
 * know when a system header is included for the first time in the amalgamation, all internal files
 * that need these definitions should include this file before any system headers.
 */

#ifndef __COCO_PLATFORM__
#define __COCO_PLATFORM__

#include <stddef.h>

/* Definitions of IOHprofiler_PATH_MAX, IOHprofiler_path_separator, HAVE_GFA and HAVE_STAT heavily used by functions in
 * IOHprofiler_utilities.c */
#if defined(_WIN32) || defined(_WIN64) || defined(__MINGW64__) || defined(__CYGWIN__)
#include <windows.h>
static const char *IOHprofiler_path_separator = "\\";
#define IOHprofiler_PATH_MAX MAX_PATH
#define HAVE_GFA 1
#elif defined(__gnu_linux__)
#include <linux/limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__APPLE__)
#include <sys/stat.h>
#include <sys/syslimits.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__FreeBSD__)
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif (defined(__sun) || defined(sun)) && (defined(__SVR4) || defined(__svr4__))
/* Solaris */
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#else
#error Unknown platform
#endif
#if !defined(IOHprofiler_PATH_MAX)
#error IOHprofiler_PATH_MAX undefined
#endif

/* Definitions needed for creating and removing directories */
/* Separately handle the special case of Microsoft Visual Studio 2008 with x86_64-w64-mingw32-gcc */
#if _MSC_VER
#include <direct.h>
#elif defined(__MINGW32__) || defined(__MINGW64__)
#include <dirent.h>
#else
#include <dirent.h>

#ifdef __cplusplus
extern "C" {
#endif

/* To silence the compiler (implicit-function-declaration warning). */
/** @cond */
int rmdir(const char *pathname);
int unlink(const char *file_name);
int mkdir(const char *pathname, mode_t mode);
/** @endcond */
#endif

/* Definition of the S_IRWXU constant needed to set file permissions */
#if defined(HAVE_GFA)
#define S_IRWXU 0700
#endif

/* To silence the Visual Studio compiler (C4996 warnings in the python build). */
#ifdef _MSC_VER
#pragma warning(disable : 4996)
#endif

#ifdef __cplusplus
}
#endif

#endif
#line 9 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_utilities.c"

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#line 18 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_utilities.c"
#line 19 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_utilities.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_string.c"
/**
 * @file IOHprofiler_string.c
 * @brief Definitions of functions that manipulate strings.
 */
#ifndef IOH_PROFILER_STRING
#define IOH_PROFILER_STRING

#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#line 13 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_string.c"

static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements);

/**
 * @brief Creates a duplicate copy of string and returns a pointer to it.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strdup(const char *string) {
    size_t len;
    char *duplicate;
    if (string == NULL)
        return NULL;
    len = strlen(string);
    duplicate = (char *)IOHprofiler_allocate_memory(len + 1);
    memcpy(duplicate, string, len + 1);
    return duplicate;
}

/**
 * @brief The length of the buffer used in the IOHprofiler_vstrdupf function.
 *
 * @note This should be handled differently!
 */
#define IOHprofiler_VSTRDUPF_BUFLEN 444

/**
 * @brief Formatted string duplication, with va_list arguments.
 */
static char *IOHprofiler_vstrdupf(const char *str, va_list args) {
    static char buf[IOHprofiler_VSTRDUPF_BUFLEN];
    long written;
    /* apparently args can only be used once, therefore
   * len = vsnprintf(NULL, 0, str, args) to find out the
   * length does not work. Therefore we use a buffer
   * which limits the max length. Longer strings should
   * never appear anyway, so this is rather a non-issue. */

#if 0
  written = vsnprintf(buf, IOHprofiler_VSTRDUPF_BUFLEN - 2, str, args);
  if (written < 0)
  IOHprofiler_error("IOHprofiler_vstrdupf(): vsnprintf failed on '%s'", str);
#else /* less safe alternative, if vsnprintf is not available */
    assert(strlen(str) < IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2);
    if (strlen(str) >= IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2)
        IOHprofiler_error("IOHprofiler_vstrdupf(): string is too long");
    written = vsprintf(buf, str, args);
    if (written < 0)
        IOHprofiler_error("IOHprofiler_vstrdupf(): vsprintf failed on '%s'", str);
#endif
    if (written > IOHprofiler_VSTRDUPF_BUFLEN - 3)
        IOHprofiler_error("IOHprofiler_vstrdupf(): A suspiciously long string is tried to being duplicated '%s'", buf);
    return IOHprofiler_strdup(buf);
}

#undef IOHprofiler_VSTRDUPF_BUFLEN

/**
 * Optional arguments are used like in sprintf.
 */
char *IOHprofiler_strdupf(const char *str, ...) {
    va_list args;
    char *s;

    va_start(args, str);
    s = IOHprofiler_vstrdupf(str, args);
    va_end(args);
    return s;
}

/**
 * @brief Returns a concatenate copy of string1 + string2.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strconcat(const char *s1, const char *s2) {
    size_t len1 = strlen(s1);
    size_t len2 = strlen(s2);
    char *s = (char *)IOHprofiler_allocate_memory(len1 + len2 + 1);

    memcpy(s, s1, len1);
    memcpy(&s[len1], s2, len2 + 1);
    return s;
}

/**
 * @brief Returns the first index where seq occurs in base and -1 if it doesn't.
 *
 * @note If there is an equivalent standard C function, this can/should be removed.
 */
static long IOHprofiler_strfind(const char *base, const char *seq) {
    const size_t strlen_seq = strlen(seq);
    const size_t last_first_idx = strlen(base) - strlen(seq);
    size_t i, j;

    if (strlen(base) < strlen(seq))
        return -1;

    for (i = 0; i <= last_first_idx; ++i) {
        if (base[i] == seq[0]) {
            for (j = 0; j < strlen_seq; ++j) {
                if (base[i + j] != seq[j])
                    break;
            }
            if (j == strlen_seq) {
                if (i > 1e9)
                    IOHprofiler_error("IOHprofiler_strfind(): strange values observed i=%lu, j=%lu, strlen(base)=%lu",
                                      (unsigned long)i, (unsigned long)j, (unsigned long)strlen(base));
                return (long)i;
            }
        }
    }
    return -1;
}

/**
 * @brief Splits a string based on the given delimiter.
 *
 * Returns a pointer to the resulting substrings with NULL as the last one.
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char **IOHprofiler_string_split(const char *string, const char delimiter) {
    char **result;
    char *str_copy, *ptr, *token;
    char str_delimiter[2];
    size_t i;
    size_t count = 1;

    str_copy = IOHprofiler_strdup(string);

    /* Counts the parts between delimiters */
    ptr = str_copy;
    while (*ptr != '\0') {
        if (*ptr == delimiter) {
            count++;
        }
        ptr++;
    }
    /* Makes room for an empty string that will be appended at the end */
    count++;

    result = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));

    /* Iterates through tokens
   * NOTE: strtok() ignores multiple delimiters, therefore the final number of detected substrings might be
   * lower than the count. This is OK. */
    i = 0;
    /* A char* delimiter needs to be used, otherwise strtok() can surprise */
    str_delimiter[0] = delimiter;
    str_delimiter[1] = '\0';
    token = strtok(str_copy, str_delimiter);
    while (token) {
        assert(i < count);
        *(result + i++) = IOHprofiler_strdup(token);
        token = strtok(NULL, str_delimiter);
    }
    *(result + i) = NULL;

    IOHprofiler_free_memory(str_copy);

    return result;
}

/**
 * @brief Creates and returns a string with removed characters between from and to.
 *
 * If you wish to remove characters from the beginning of the string, set from to "".
 * If you wish to remove characters until the end of the string, set to to "".
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_remove_from_string(const char *string, const char *from, const char *to) {
    char *result, *start, *stop;

    result = IOHprofiler_strdup(string);

    if (strcmp(from, "") == 0) {
        /* Remove from the start */
        start = result;
    } else
        start = strstr(result, from);

    if (strcmp(to, "") == 0) {
        /* Remove until the end */
        stop = result + strlen(result);
    } else
        stop = strstr(result, to);

    if ((start == NULL) || (stop == NULL) || (stop < start)) {
        IOHprofiler_error("IOHprofiler_remove_from_string(): failed to remove characters between %s and %s from string %s",
                          from, to, string);
        return NULL; /* Never reached */
    }

    memmove(start, stop, strlen(stop) + 1);

    return result;
}

/**
 * @brief Returns the numbers defined by the ranges.
 *
 * Reads ranges from a string of positive ranges separated by commas. For example: "-3,5-6,8-". Returns the
 * numbers that are defined by the ranges if min and max are used as their extremes. If the ranges with open
 * beginning/end are not allowed, use 0 as min/max. The returned string has an appended 0 to mark its end.
 * A maximum of max_count values is returned. If there is a problem with one of the ranges, the parsing stops
 * and the current result is returned. The memory of the returned object needs to be freed by the caller.
 */
static size_t *IOHprofiler_string_parse_ranges(const char *string,
                                               const size_t min,
                                               const size_t max,
                                               const char *name,
                                               const size_t max_count) {
    char *ptr, *dash = NULL;
    char **ranges, **numbers;
    size_t i, j, count;
    size_t num[2];

    size_t *result;
    size_t i_result = 0;

    char *str = IOHprofiler_strdup(string);

    /* Check for empty string */
    if ((str == NULL) || (strlen(str) == 0)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): cannot parse empty ranges");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    ptr = str;
    /* Check for disallowed characters */
    while (*ptr != '\0') {
        if ((*ptr != '-') && (*ptr != ',') && !isdigit((unsigned char)*ptr)) {
            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - cannot parse ranges with '%c'", str,
                                *ptr);
            IOHprofiler_free_memory(str);
            return NULL;
        } else
            ptr++;
    }
    /* Check for incorrect boundaries */
    if ((max > 0) && (min > max)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): incorrect boundaries");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    result = IOHprofiler_allocate_vector_size_t(max_count + 1);

    /* Split string to ranges w.r.t commas */
    ranges = IOHprofiler_string_split(str, ',');
    IOHprofiler_free_memory(str);
    if (ranges) {
        /* Go over the current range */
        for (i = 0; *(ranges + i); i++) {
            ptr = *(ranges + i);
            /* Count the number of '-' */
            count = 0;
            while (*ptr != '\0') {
                if (*ptr == '-') {
                    if (count == 0)
                        /* Remember the position of the first '-' */
                        dash = ptr;
                    count++;
                }
                ptr++;
            }
            /* Point again to the start of the range */
            ptr = *(ranges + i);

            /* Check for incorrect number of '-' */
            if (count > 1) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - too many '-'s", string);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            } else if (count == 0) {
                /* Range is in the format: n (no range) */
                num[0] = (size_t)strtol(ptr, NULL, 10);
                num[1] = num[0];
            } else {
                /* Range is in one of the following formats: n-m / -n / n- / - */

                /* Split current range to numbers w.r.t '-' */
                numbers = IOHprofiler_string_split(ptr, '-');
                j = 0;
                if (numbers) {
                    /* Read the numbers */
                    for (j = 0; *(numbers + j); j++) {
                        assert(j < 2);
                        num[j] = (size_t)strtol(*(numbers + j), NULL, 10);
                        IOHprofiler_free_memory(*(numbers + j));
                    }
                }
                IOHprofiler_free_memory(numbers);

                if (j == 0) {
                    /* Range is in the format - (open ends) */
                    if ((min == 0) || (max == 0)) {
                        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open ends; some ranges ignored", name);
                        /* Cleanup */
                        for (j = i; *(ranges + j); j++)
                            IOHprofiler_free_memory(*(ranges + j));
                        IOHprofiler_free_memory(ranges);
                        if (i_result == 0) {
                            IOHprofiler_free_memory(result);
                            return NULL;
                        }
                        result[i_result] = 0;
                        return result;
                    }
                    num[0] = min;
                    num[1] = max;
                } else if (j == 1) {
                    if (dash - *(ranges + i) == 0) {
                        /* Range is in the format -n */
                        if (min == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open beginning; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = num[0];
                        num[0] = min;
                    } else {
                        /* Range is in the format n- */
                        if (max == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open end; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = max;
                    }
                }
                /* if (j == 2), range is in the format n-m and there is nothing to do */
            }

            /* Make sure the boundaries are taken into account */
            if ((min > 0) && (num[0] < min)) {
                num[0] = min;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be >= %lu", name,
                                    (unsigned long)min);
              }
            if ((max > 0) && (num[1] > max)) {
                num[1] = max;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be <= %lu", name, (unsigned long) max);
            }
            if (num[0] > num[1]) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges not within boundaries; some ranges ignored", name);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            }

            /* Write in result */
            for (j = num[0]; j <= num[1]; j++) {
                if (i_result > max_count - 1)
                    break;
                result[i_result++] = j;
            }

            IOHprofiler_free_memory(*(ranges + i));
            *(ranges + i) = NULL;
        }
    }

    IOHprofiler_free_memory(ranges);

    if (i_result == 0) {
        IOHprofiler_free_memory(result);
        return NULL;
    }

    result[i_result] = 0;
    return result;
}

/**
 * @brief Trims the given string (removes any leading and trailing spaces).
 *
 * If the string contains any leading spaces, the contents are shifted so that if it was dynamically
 * allocated, it can be still freed on the returned pointer.
 */
static char *IOHprofiler_string_trim(char *string) {
    size_t len = 0;
    char *frontp = string;
    char *endp = NULL;

    if (string == NULL) {
        return NULL;
    }
    if (string[0] == '\0') {
        return string;
    }

    len = strlen(string);
    endp = string + len;

    /* Move the front and back pointers to address the first non-whitespace characters from each end. */
    while (isspace((unsigned char)*frontp)) {
        ++frontp;
    }
    if (endp != frontp) {
        while (isspace((unsigned char)*(--endp)) && endp != frontp) {
        }
    }

    if (string + len - 1 != endp)
        *(endp + 1) = '\0';
    else if (frontp != string && endp == frontp)
        *string = '\0';

    /* Shift the string. Note the reuse of endp to mean the front of the string buffer now. */
    endp = string;
    if (frontp != string) {
        while (*frontp) {
            *endp++ = *frontp++;
        }
        *endp = '\0';
    }

    return string;
}
#endif
#line 20 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_utilities.c"

/***********************************************************************************************************/

/**
 * @brief Initializes the logging level to IOHprofiler_INFO.
 */
static IOHprofiler_log_level_type_e IOHprofiler_log_level = IOHprofiler_INFO;

/**
 * @param log_level Denotes the level of information given to the user through the standard output and
 * error streams. Can take on the values:
 * - "error" (only error messages are output),
 * - "warning" (only error and warning messages are output),
 * - "info" (only error, warning and info messages are output) and
 * - "debug" (all messages are output).
 * - "" does not set a new value
 * The default value is info.
 *
 * @return The previous IOHprofiler_log_level value as an immutable string.
 */
const char *IOHprofiler_set_log_level(const char *log_level) {
    IOHprofiler_log_level_type_e previous_log_level = IOHprofiler_log_level;

    if (strcmp(log_level, "error") == 0)
        IOHprofiler_log_level = IOHprofiler_ERROR;
    else if (strcmp(log_level, "warning") == 0)
        IOHprofiler_log_level = IOHprofiler_WARNING;
    else if (strcmp(log_level, "info") == 0)
        IOHprofiler_log_level = IOHprofiler_INFO;
    else if (strcmp(log_level, "debug") == 0)
        IOHprofiler_log_level = IOHprofiler_DEBUG;
    else if (strcmp(log_level, "") == 0) {
        /* Do nothing */
    } else {
        IOHprofiler_warning("IOHprofiler_set_log_level(): unknown level %s", log_level);
    }

    if (previous_log_level == IOHprofiler_ERROR)
        return "error";
    else if (previous_log_level == IOHprofiler_WARNING)
        return "warning";
    else if (previous_log_level == IOHprofiler_INFO)
        return "info";
    else if (previous_log_level == IOHprofiler_DEBUG)
        return "debug";
    else {
        IOHprofiler_error("IOHprofiler_set_log_level(): unknown previous log level");
        return "";
    }
}

/***********************************************************************************************************/

/**
 * @name Methods regarding file, directory and path manipulations
 */
/**@{*/
/**
 * @brief Creates a platform-dependent path from the given strings.
 *
 * @note The last argument must be NULL.
 * @note The first parameter must be able to accommodate path_max_length characters and the length
 * of the joined path must not exceed path_max_length characters.
 * @note Should work cross-platform.
 *
 * Usage examples:
 * - IOHprofiler_join_path(base_path, 100, folder1, folder2, folder3, NULL) creates base_path/folder1/folder2/folder3
 * - IOHprofiler_join_path(base_path, 100, folder1, file_name, NULL) creates base_path/folder1/file_name
 * @param path The base path; it's also where the joined path is stored to.
 * @param path_max_length The maximum length of the path.
 * @param ... Additional strings, must end with NULL
 */
static void IOHprofiler_join_path(char *path, const size_t path_max_length, ...) {
    const size_t path_separator_length = strlen(IOHprofiler_path_separator);
    va_list args;
    char *path_component;
    size_t path_length = strlen(path);

    va_start(args, path_max_length);
    while (NULL != (path_component = va_arg(args, char *))) {
        size_t component_length = strlen(path_component);
        if (path_length + path_separator_length + component_length >= path_max_length) {
            IOHprofiler_error("IOHprofiler_join_path() failed because the ${path} is too short.");
            return; /* never reached */
        }
        /* Both should be safe because of the above check. */
        if (strlen(path) > 0)
            strncat(path, IOHprofiler_path_separator, path_max_length - strlen(path) - 1);
        strncat(path, path_component, path_max_length - strlen(path) - 1);
    }
    va_end(args);
}

/**
 * @brief Checks if the given directory exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a directory and 0 otherwise.
 */
static int IOHprofiler_directory_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Checks if the given file exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a file and 0 otherwise.
 */
static int IOHprofiler_file_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES) && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && !S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Calls the right mkdir() method (depending on the platform).
 *
 * @param path The directory path.
 *
 * @return 0 on successful completion, and -1 on error.
 */
static int IOHprofiler_mkdir(const char *path) {
#if _MSC_VER
    return _mkdir(path);
#elif defined(__MINGW32__) || defined(__MINGW64__)
    return mkdir(path);
#else
    return mkdir(path, S_IRWXU);
#endif
}

/**
 * @brief Creates a directory with full privileges for the user.
 *
 * @note Should work cross-platform.
 *
 * @param path The directory path.
 */
static void IOHprofiler_create_directory(const char *path) {
    char *tmp = NULL;
    char *p;
    size_t len = strlen(path);
    char path_sep = IOHprofiler_path_separator[0];

    /* Nothing to do if the path exists. */
    if (IOHprofiler_directory_exists(path))
        return;

    tmp = IOHprofiler_strdup(path);
    /* Remove possible trailing slash */
    if (tmp[len - 1] == path_sep)
        tmp[len - 1] = 0;
    for (p = tmp + 1; *p; p++) {
        if (*p == path_sep) {
            *p = 0;
            if (!IOHprofiler_directory_exists(tmp)) {
                if (0 != IOHprofiler_mkdir(tmp))
                    IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
            }
            *p = path_sep;
        }
    }
    if (0 != IOHprofiler_mkdir(tmp))
        IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
    IOHprofiler_free_memory(tmp);
    return;
}

/* Commented to silence the compiler (unused function warning) */
#if 0

#endif

/**
 * @brief Creates a unique directory from the given path.
 *
 * If the given path does not yet exit, it is left as is, otherwise it is changed(!) by appending a number
 * to it. If path already exists, path-01 will be tried. If this one exists as well, path-02 will be tried,
 * and so on. If path-99 exists as well, the function throws an error.
 */
static void IOHprofiler_create_unique_directory(char **path) {
    int counter = 1;
    char *new_path;

    /* Create the path if it does not yet exist */
    if (!IOHprofiler_directory_exists(*path)) {
        IOHprofiler_create_directory(*path);
        return;
    }

    while (counter < 999) {
        new_path = IOHprofiler_strdupf("%s-%03d", *path, counter);

        if (!IOHprofiler_directory_exists(new_path)) {
            IOHprofiler_free_memory(*path);
            *path = new_path;
            IOHprofiler_create_directory(*path);
            return;
        } else {
            counter++;
            IOHprofiler_free_memory(new_path);
        }
    }

    IOHprofiler_error("IOHprofiler_create_unique_path(): could not create a unique path with name %s", *path);
    return; /* Never reached */
}

/**
 * The method should work across different platforms/compilers.
 *
 * @path The path to the directory
 *
 * @return 0 on successful completion, and -1 on error.
 */
int IOHprofiler_remove_directory(const char *path) {
#if _MSC_VER
    WIN32_FIND_DATA find_data_file;
    HANDLE find_handle = NULL;
    char *buf;
    int r = -1;
    int r2 = -1;

    buf = IOHprofiler_strdupf("%s\\*.*", path);
    /* Nothing to do if the folder does not exist */
    if ((find_handle = FindFirstFile(buf, &find_data_file)) == INVALID_HANDLE_VALUE) {
        IOHprofiler_free_memory(buf);
        return 0;
    }
    IOHprofiler_free_memory(buf);

    do {
        r = 0;

        /* Skip the names "." and ".." as we don't want to recurse on them */
        if (strcmp(find_data_file.cFileName, ".") != 0 && strcmp(find_data_file.cFileName, "..") != 0) {
            /* Build the new path using the argument path the file/folder name we just found */
            buf = IOHprofiler_strdupf("%s\\%s", path, find_data_file.cFileName);

            if (find_data_file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                /* Buf is a directory, recurse on it */
                r2 = IOHprofiler_remove_directory(buf);
            } else {
                /* Buf is a file, delete it */
                /* Careful, DeleteFile returns 0 if it fails and nonzero otherwise! */
                r2 = -(DeleteFile(buf) == 0);
            }

            IOHprofiler_free_memory(buf);
        }

        r = r2;

    } while (FindNextFile(find_handle, &find_data_file)); /* Find the next file */

    FindClose(find_handle);

    if (!r) {
        /* Path is an empty directory, delete it */
        /* Careful, RemoveDirectory returns 0 if it fails and nonzero otherwise! */
        r = -(RemoveDirectory(path) == 0);
    }

    return r;
#else
    DIR *d = opendir(path);
    int r = -1;
    int r2 = -1;
    char *buf;

    /* Nothing to do if the folder does not exist */
    if (!IOHprofiler_directory_exists(path))
        return 0;

    if (d) {
        struct dirent *p;

        r = 0;

        while (!r && (p = readdir(d))) {
            /* Skip the names "." and ".." as we don't want to recurse on them */
            if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, "..")) {
                continue;
            }

            buf = IOHprofiler_strdupf("%s/%s", path, p->d_name);
            if (buf) {
                if (IOHprofiler_directory_exists(buf)) {
                    /* Buf is a directory, recurse on it */
                    r2 = IOHprofiler_remove_directory(buf);
                } else {
                    /* Buf is a file, delete it */
                    r2 = unlink(buf);
                }
            }
            IOHprofiler_free_memory(buf);

            r = r2;
        }

        closedir(d);
    }

    if (!r) {
        /* Path is an empty directory, delete it */
        r = rmdir(path);
    }

    return r;
#endif
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding memory allocations
 */
/**@{*/
double *IOHprofiler_allocate_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(double);
    return (double *)IOHprofiler_allocate_memory(block_size);
}

int *IOHprofiler_allocate_int_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(int);
    return (int *)IOHprofiler_allocate_memory(block_size);
}
/**
 * @brief Allocates memory for a vector and sets all its elements to value.
 */
static double *IOHprofiler_allocate_vector_with_value(const size_t number_of_elements, double value) {
    const size_t block_size = number_of_elements * sizeof(double);
    double *vector = (double *)IOHprofiler_allocate_memory(block_size);
    size_t i;

    for (i = 0; i < number_of_elements; i++)
        vector[i] = value;

    return vector;
}

/**
 * @brief Safe memory allocation for a vector with size_t elements that either succeeds or triggers a
 * IOHprofiler_error.
 */
static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(size_t);
    return (size_t *)IOHprofiler_allocate_memory(block_size);
}

static char *IOHprofiler_allocate_string(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(char);
    return (char *)IOHprofiler_allocate_memory(block_size);
}

static double *IOHprofiler_duplicate_vector(const double *src, const size_t number_of_elements) {
    size_t i;
    double *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}

static int *IOHprofiler_duplicate_int_vector(const int *src, const size_t number_of_elements) {
    size_t i;
    int *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_int_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding string options
 */
/**@{*/

/**
 * @brief Allocates an option keys structure holding the given number of option keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_allocate(const size_t count, const char **keys) {
    size_t i;
    IOHprofiler_option_keys_t *option_keys;

    if ((count == 0) || (keys == NULL))
        return NULL;

    option_keys = (IOHprofiler_option_keys_t *)IOHprofiler_allocate_memory(sizeof(*option_keys));

    option_keys->keys = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));
    for (i = 0; i < count; i++) {
        assert(keys[i]);
        option_keys->keys[i] = IOHprofiler_strdup(keys[i]);
    }
    option_keys->count = count;

    return option_keys;
}

/**
 * @brief Frees the given option keys structure.
 */
static void IOHprofiler_option_keys_free(IOHprofiler_option_keys_t *option_keys) {
    size_t i;

    if (option_keys) {
        for (i = 0; i < option_keys->count; i++) {
            IOHprofiler_free_memory(option_keys->keys[i]);
        }
        IOHprofiler_free_memory(option_keys->keys);
        IOHprofiler_free_memory(option_keys);
    }
}

/**
 * @brief Returns redundant option keys (the ones present in given_option_keys but not in known_option_keys).
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_get_redundant(const IOHprofiler_option_keys_t *known_option_keys,
                                                                        const IOHprofiler_option_keys_t *given_option_keys) {
    size_t i, j, count = 0;
    int found;
    char **redundant_keys;
    IOHprofiler_option_keys_t *redundant_option_keys;

    assert(known_option_keys != NULL);
    assert(given_option_keys != NULL);

    /* Find the redundant keys */
    redundant_keys = (char **)IOHprofiler_allocate_memory(given_option_keys->count * sizeof(char *));
    for (i = 0; i < given_option_keys->count; i++) {
        found = 0;
        for (j = 0; j < known_option_keys->count; j++) {
            if (strcmp(given_option_keys->keys[i], known_option_keys->keys[j]) == 0) {
                found = 1;
                break;
            }
        }
        if (!found) {
            redundant_keys[count++] = IOHprofiler_strdup(given_option_keys->keys[i]);
        }
    }
    redundant_option_keys = IOHprofiler_option_keys_allocate(count, (const char **)redundant_keys);

    /* Free memory */
    for (i = 0; i < count; i++) {
        IOHprofiler_free_memory(redundant_keys[i]);
    }
    IOHprofiler_free_memory(redundant_keys);

    return redundant_option_keys;
}

/**
 * @brief Adds additional option keys to the given basic option keys (changes the basic keys).
 */
static void IOHprofiler_option_keys_add(IOHprofiler_option_keys_t **basic_option_keys,
                                        const IOHprofiler_option_keys_t *additional_option_keys) {
    size_t i, j;
    size_t new_count;
    char **new_keys;
    IOHprofiler_option_keys_t *new_option_keys;

    assert(*basic_option_keys != NULL);
    if (additional_option_keys == NULL)
        return;

    /* Construct the union of both keys */
    new_count = (*basic_option_keys)->count + additional_option_keys->count;
    new_keys = (char **)IOHprofiler_allocate_memory(new_count * sizeof(char *));
    for (i = 0; i < (*basic_option_keys)->count; i++) {
        new_keys[i] = IOHprofiler_strdup((*basic_option_keys)->keys[i]);
    }
    for (j = 0; j < additional_option_keys->count; j++) {
        new_keys[(*basic_option_keys)->count + j] = IOHprofiler_strdup(additional_option_keys->keys[j]);
    }
    new_option_keys = IOHprofiler_option_keys_allocate(new_count, (const char **)new_keys);

    /* Free the old basic keys */
    IOHprofiler_option_keys_free(*basic_option_keys);
    *basic_option_keys = new_option_keys;
    for (i = 0; i < new_count; i++) {
        IOHprofiler_free_memory(new_keys[i]);
    }
    IOHprofiler_free_memory(new_keys);
}

/**
 * @brief Creates an instance of option keys from the given string of options containing keys and values
 * separated by colons.
 *
 * @note Relies heavily on the "key: value" format and might fail if the number of colons doesn't match the
 * number of keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys(const char *option_string) {
    size_t i;
    char **keys;
    IOHprofiler_option_keys_t *option_keys = NULL;
    char *string_to_parse, *key;

    /* Check for empty string */
    if ((option_string == NULL) || (strlen(option_string) == 0)) {
        return NULL;
    }

    /* Split the options w.r.t ':' */
    keys = IOHprofiler_string_split(option_string, ':');

    if (keys) {
        /* Keys now contain something like this: "values_of_previous_key this_key" except for the first, which
     * contains only the key and the last, which contains only the previous values */
        for (i = 0; *(keys + i); i++) {
            string_to_parse = IOHprofiler_strdup(*(keys + i));

            /* Remove any leading and trailing spaces */
            string_to_parse = IOHprofiler_string_trim(string_to_parse);

            /* Stop if this is the last substring (contains a value and no key) */
            if ((i > 0) && (*(keys + i + 1) == NULL)) {
                IOHprofiler_free_memory(string_to_parse);
                break;
            }

            /* Disregard everything before the last space */
            key = strrchr(string_to_parse, ' ');
            if ((key == NULL) || (i == 0)) {
                /* No spaces left (or this is the first key), everything is the key */
                key = string_to_parse;
            } else {
                /* Move to the start of the key (one char after the space) */
                key++;
            }

            /* Put the key in keys */
            IOHprofiler_free_memory(*(keys + i));
            *(keys + i) = IOHprofiler_strdup(key);
            IOHprofiler_free_memory(string_to_parse);
        }

        option_keys = IOHprofiler_option_keys_allocate(i, (const char **)keys);

        /* Free the keys */
        for (i = 0; *(keys + i); i++) {
            IOHprofiler_free_memory(*(keys + i));
        }
        IOHprofiler_free_memory(keys);
    }

    return option_keys;
}

/**
 * @brief Creates and returns a string containing the info_string and all keys from option_keys.
 *
 * Can be used to output information about the given option_keys.
 */
static char *IOHprofiler_option_keys_get_output_string(const IOHprofiler_option_keys_t *option_keys,
                                                       const char *info_string) {
    size_t i;
    char *string = NULL, *new_string;

    if ((option_keys != NULL) && (option_keys->count > 0)) {
        string = IOHprofiler_strdup(info_string);
        for (i = 0; i < option_keys->count; i++) {
            new_string = IOHprofiler_strdupf("%s %s\n", string, option_keys->keys[i]);
            IOHprofiler_free_memory(string);
            string = new_string;
        }
    }

    return string;
}

/**
 * @brief Parses options in the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - value needs to be a single string (no spaces allowed)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read(const char *options, const char *name, const char *format, void *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing whitespaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    return sscanf(&options[i2], format, pointer);
}

/**
 * @brief Reads an integer from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be an integer
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_int(const char *options, const char *name, int *pointer) {
    return IOHprofiler_options_read(options, name, " %i", pointer);
}

/**
 * @brief Reads a size_t from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a size_t
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_size_t(const char *options, const char *name, size_t *pointer) {
    return IOHprofiler_options_read(options, name, "%lu", pointer);
}

/**
 * @brief Reads a double value from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a double
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_double(const char *options, const char *name, double *pointer) {
    return IOHprofiler_options_read(options, name, "%lf", pointer);
}

/**
 * @brief Reads a string from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a string - either a single word or multiple words
 * in double quotes
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_string(const char *options, const char *name, char *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    if (options[i2] == '\"') {
        /* The value starts with a quote: read everything between two quotes into a string */
        return sscanf(&options[i2], "\"%[^\"]\"", pointer);
    } else
        return sscanf(&options[i2], "%s", pointer);
}

/**
 * @brief Reads (possibly delimited) values from options using the form "name1: value1,value2,value3 name2: value4",
 * i.e. reads all characters from the corresponding name up to the next whitespace or end of string.
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_values(const char *options, const char *name, char *pointer) {
    long i1, i2;
    int i;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    i = 0;
    while (!isspace((unsigned char)options[i2 + i]) && (options[i2 + i] != '\0')) {
        pointer[i] = options[i2 + i];
        i++;
    }
    pointer[i] = '\0';
    return i;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods implementing functions on double values not contained in C89 standard
 */
/**@{*/

/**
 * @brief Rounds the given double to the nearest integer.
 */
static double IOHprofiler_double_round(const double number) {
    return floor(number + 0.5);
}

/**
 * @brief Returns the maximum of a and b.
 */
static double IOHprofiler_double_max(const double a, const double b) {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Returns the minimum of a and b.
 */
static double IOHprofiler_double_min(const double a, const double b) {
    if (a <= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Performs a "safer" double to size_t conversion.
 */
static size_t IOHprofiler_double_to_size_t(const double number) {
    return (size_t)IOHprofiler_double_round(number);
}

/**
 * @brief  Returns 1 if |a - b| < precision and 0 otherwise.
 */
static int IOHprofiler_double_almost_equal(const double a, const double b, const double precision) {
    return (fabs(a - b) < precision);
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods handling NAN and INFINITY
 */
/**@{*/

/**
 * @brief Returns 1 if x is NAN and 0 otherwise.
 */
static int IOHprofiler_is_nan(const int x) {
    /*return (isnan(x) || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
*/
    return (0 || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
}

/**
 * @brief Returns 1 if the input vector of dimension dim contains any NAN values and 0 otherwise.
 */
static int IOHprofiler_vector_contains_nan(const int *x, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        if (IOHprofiler_is_nan(x[i]))
            return 1;
    }
    return 0;
}

/**
 * @brief Sets all dim values of y to NAN.
 */
static void IOHprofiler_vector_set_to_nan(double *y, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        y[i] = NAN;
    }
}

/**
 * @brief Returns 1 if x is INFINITY and 0 otherwise.
 */
static int IOHprofiler_is_inf(const int x) {
    if (IOHprofiler_is_nan(x))
        return 0;
    /*return (isinf(x) || (x <= -INFINITY) || (x >= INFINITY));*/
    return (0 || (x <= -INFINITY) || (x >= INFINITY));
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Miscellaneous methods
 */
/**@{*/

/**
 * @brief Returns the current time as a string.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_current_time_get_string(void) {
    time_t timer;
    char *time_string = IOHprofiler_allocate_string(30);
    struct tm *tm_info;
    time(&timer);
    tm_info = localtime(&timer);
    assert(tm_info != NULL);
    strftime(time_string, 30, "%d.%m.%y %H:%M:%S", tm_info);
    return time_string;
}

/**
 * @brief Returns the number of positive numbers pointed to by numbers (the count stops when the first
 * 0 is encountered of max_count numbers have been read).
 *
 * If there are more than max_count numbers, a IOHprofiler_error is raised. The name argument is used
 * only to provide more informative output in case of any problems.
 */
static size_t IOHprofiler_count_numbers(const size_t *numbers, const size_t max_count, const char *name) {
    size_t count = 0;
    while ((count < max_count) && (numbers[count] != 0)) {
        count++;
    }
    if (count == max_count) {
        IOHprofiler_error("IOHprofiler_count_numbers(): over %lu numbers in %s", (unsigned long)max_count, name);
        return 0; /* Never reached*/
    }

    return count;
}

/**@}*/

/***********************************************************************************************************/
#endif
#line 13 "code-experiments/src/profiler/../suite/PBO/../../profiler/IOHprofiler_problem.c"

/**
 * Evaluates the problem function, increases the number of evaluations and updates the best observed value
 * and the best observed evaluation number.
 *
 * @note Both x and y must point to correctly sized allocated memory regions.
 *
 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 * @param y The objective vector that is the result of the evaluation (in single-objective problems only the
 * first vector item is being set). Currently multi-objective is not supported.
 * @param number_of_parameters The number of parameters need to be logged. Set as zero by default.
 * @param parameters The list of parameters. Set as NULL by default.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {

    assert(problem != NULL);
    assert(problem->evaluate_function != NULL);
    problem->evaluate_function(problem, x, y);
    problem->evaluations++; /* each derived class has its own counter, only the most outer will be visible */

    /* A little bit of bookkeeping */
    if (y[0] > problem->best_observed_fvalue[0]) {
        problem->best_observed_fvalue[0] = y[0];
        problem->best_observed_evaluation[0] = problem->evaluations;
    }
}

/**
 * Evaluates and logs the given solution (as the IOHprofiler_evaluate_function), but does not return the evaluated
 * value.
 *
 * @note None of the observers implements this function yet!
 * @note x must point to a correctly sized allocated memory region.

 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    assert(problem != NULL);
    if (problem->recommend_solution == NULL) {
        IOHprofiler_error("IOHprofiler_recommend_solutions(): No recommend solution function implemented for problem %s",
                          problem->problem_id);
    }
    problem->recommend_solution(problem, x);
}

/**
 * @brief Allocates a new IOHprofiler_problem_t for the given number of variables and number of objectives.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate(const size_t number_of_variables,
                                                           const size_t number_of_objectives) {
    IOHprofiler_problem_t *problem;
    problem = (IOHprofiler_problem_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    /* Initialize fields to sane/safe defaults */
    problem->initial_solution = NULL;
    problem->evaluate_function = NULL;
    problem->recommend_solution = NULL;
    problem->problem_free_function = NULL;
    problem->dimension = number_of_variables;
    problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = number_of_objectives;
    problem->number_of_parameters = 0;
    problem->parameters = NULL;
    problem->smallest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->largest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_parameter = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_value = IOHprofiler_allocate_vector(number_of_objectives);
    problem->raw_fitness = IOHprofiler_allocate_vector(number_of_objectives);
    if (number_of_objectives > 1)
        problem->nadir_value = IOHprofiler_allocate_vector(number_of_objectives);
    else
        problem->nadir_value = NULL;
    problem->problem_name = NULL;
    problem->problem_id = NULL;
    problem->problem_type = NULL;
    problem->evaluations = 0;
    problem->final_target_delta[0] = 1e-8; /* in case to be modified by the benchmark */
    problem->best_observed_fvalue[0] = DBL_MIN_EXP;
    problem->best_observed_evaluation[0] = 0;
    problem->suite = NULL; /* To be initialized in the IOHprofiler_suite_get_problem_from_indices() function */
    problem->suite_dep_index = 0;
    problem->suite_dep_function = 0;
    problem->suite_dep_instance = 0;
    problem->data = NULL;
    return problem;
}

/**
 * @brief Creates a duplicate of the 'other' problem for all fields except for data, which points to NULL.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_duplicate(const IOHprofiler_problem_t *other) {
    size_t i;
    IOHprofiler_problem_t *problem;
    problem = IOHprofiler_problem_allocate(other->number_of_variables, other->number_of_objectives);

    problem->dimension = other->dimension;
    problem->initial_solution = other->initial_solution;
    problem->evaluate_function = other->evaluate_function;
    problem->recommend_solution = other->recommend_solution;
    problem->problem_free_function = other->problem_free_function;

    for (i = 0; i < problem->number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = other->smallest_values_of_interest[i];
        problem->largest_values_of_interest[i] = other->largest_values_of_interest[i];
        if (other->best_parameter)
            problem->best_parameter[i] = other->best_parameter[i];
    }

    if (other->best_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->best_value[i] = other->best_value[i];
        }

    if (other->nadir_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->nadir_value[i] = other->nadir_value[i];
        }

    if (other->raw_fitness)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->raw_fitness[i] = other->raw_fitness[i];
        }

    problem->number_of_parameters = other->number_of_parameters;
    for (i = 0; i < problem->number_of_parameters; ++i) {
        problem->parameters[i] = other->parameters[i];
    }

    problem->problem_name = IOHprofiler_strdup(other->problem_name);
    problem->problem_id = IOHprofiler_strdup(other->problem_id);
    problem->problem_type = IOHprofiler_strdup(other->problem_type);

    problem->evaluations = other->evaluations;
    problem->final_target_delta[0] = other->final_target_delta[0];
    problem->best_observed_fvalue[0] = other->best_observed_fvalue[0];
    problem->best_observed_evaluation[0] = other->best_observed_evaluation[0];

    problem->suite = other->suite;
    problem->suite_dep_index = other->suite_dep_index;
    problem->suite_dep_function = other->suite_dep_function;
    problem->suite_dep_instance = other->suite_dep_instance;

    problem->data = NULL;

    return problem;
}

/**
 * @brief Allocates a problem using scalar values for smallest_value_of_interest, largest_value_of_interest
 * and best_parameter.
 * Note that the number of objectives is set as 1 by default.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate_from_scalars(const char *problem_name,
                                                                        IOHprofiler_evaluate_function_t evaluate_function,
                                                                        IOHprofiler_problem_free_function_t problem_free_function,
                                                                        const size_t number_of_variables,
                                                                        const int smallest_value_of_interest,
                                                                        const int largest_value_of_interest,
                                                                        const int best_parameter) {
    size_t i;

    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate(number_of_variables, 1);

    problem->problem_name = IOHprofiler_strdup(problem_name);
    /*problem->dimension = number_of_variables;
    */problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = 1;
    problem->evaluate_function = evaluate_function;
    problem->problem_free_function = problem_free_function;

    for (i = 0; i < number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = smallest_value_of_interest;
        problem->largest_values_of_interest[i] = largest_value_of_interest;
        problem->best_parameter[i] = best_parameter;
    }
    return problem;
}

void IOHprofiler_problem_free(IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (problem->problem_free_function != NULL) {
        problem->problem_free_function(problem);
    } else {
        /* Best guess at freeing all relevant structures */
        if (problem->smallest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->smallest_values_of_interest);
        if (problem->largest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->largest_values_of_interest);
        if (problem->best_parameter != NULL)
            IOHprofiler_free_memory(problem->best_parameter);
        if (problem->best_value != NULL)
            IOHprofiler_free_memory(problem->best_value);
        if (problem->raw_fitness != NULL)
            IOHprofiler_free_memory(problem->raw_fitness);
        if (problem->nadir_value != NULL)
            IOHprofiler_free_memory(problem->nadir_value);
        if (problem->problem_name != NULL)
            IOHprofiler_free_memory(problem->problem_name);
        if (problem->problem_id != NULL)
            IOHprofiler_free_memory(problem->problem_id);
        if (problem->problem_type != NULL)
            IOHprofiler_free_memory(problem->problem_type);
        if (problem->data != NULL)
            IOHprofiler_free_memory(problem->data);
        if (problem->parameters != NULL)
            IOHprofiler_free_memory(problem->parameters);
        problem->smallest_values_of_interest = NULL;
        problem->largest_values_of_interest = NULL;
        problem->best_parameter = NULL;
        problem->best_value = NULL;
        problem->raw_fitness = NULL;
        problem->nadir_value = NULL;
        problem->suite = NULL;
        problem->data = NULL;
        problem->parameters = NULL;
        IOHprofiler_free_memory(problem);
    }
}

/**
 * @brief Checks whether the given string is in the right format to be a problem_id.
 *
 * No non-alphanumeric characters besides '-', '_' and '.' are allowed.
 */
static int IOHprofiler_problem_id_is_fine(const char *id, ...) {
    va_list args;
    const int reject = 0;
    const int accept = 1;
    const char *cp;
    char *s;
    int result = accept;

    va_start(args, id);
    s = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    for (cp = s; *cp != '\0'; ++cp) {
        if (('A' <= *cp) && (*cp <= 'Z'))
            continue;
        if (('a' <= *cp) && (*cp <= 'z'))
            continue;
        if ((*cp == '_') || (*cp == '-'))
            continue;
        if (('0' <= *cp) && (*cp <= '9'))
            continue;
        result = reject;
    }
    IOHprofiler_free_memory(s);
    return result;
}

/**
 * @brief Sets the problem_parameters.
 *
 */
void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters) {
    size_t i;
    if (number_of_parameters != 0) {
        problem->number_of_parameters = number_of_parameters;
        if (problem->parameters != NULL) {
            IOHprofiler_free_memory(problem->parameters);
        }
        problem->parameters = IOHprofiler_allocate_vector(number_of_parameters);
        for (i = 0; i < problem->number_of_parameters; ++i) {
            problem->parameters[i] = parameters[i];
        }
    }
}

/**
 * @brief Sets the problem_id using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation and verifies that the problem_id is in the correct format.
 */
static void IOHprofiler_problem_set_id(IOHprofiler_problem_t *problem, const char *id, ...) {
    va_list args;

    va_start(args, id);
    if (problem->problem_id != NULL)
        IOHprofiler_free_memory(problem->problem_id);
    problem->problem_id = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    if (!IOHprofiler_problem_id_is_fine(problem->problem_id)) {
        IOHprofiler_error("Problem id should only contain standard chars, not like '%s'", problem->problem_id);
    }
}

/**
 * @brief Sets the problem_name using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_name(IOHprofiler_problem_t *problem, const char *name, ...) {
    va_list args;

    va_start(args, name);
    if (problem->problem_name != NULL)
        IOHprofiler_free_memory(problem->problem_name);
    problem->problem_name = IOHprofiler_vstrdupf(name, args);
    va_end(args);
}

/**
 * @brief Sets the problem_type using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_type(IOHprofiler_problem_t *problem, const char *type, ...) {
    va_list args;

    va_start(args, type);
    if (problem->problem_type != NULL)
        IOHprofiler_free_memory(problem->problem_type);
    problem->problem_type = IOHprofiler_vstrdupf(type, args);
    va_end(args);
}

size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->evaluations;
}

/**
 * @brief Returns 1 if the best parameter is not (close to) zero and 0 otherwise.
 */
static int IOHprofiler_problem_best_parameter_not_zero(const IOHprofiler_problem_t *problem) {
    size_t i = 0;
    int best_is_zero = 1;

    if (IOHprofiler_vector_contains_nan(problem->best_parameter, problem->number_of_variables))
        return 1;

    while (i < problem->number_of_variables && best_is_zero) {
        best_is_zero = IOHprofiler_double_almost_equal(problem->best_parameter[i], 0, 1e-9);
        i++;
    }

    return !best_is_zero;
}

/**
 * @note Can be used to prevent unnecessary burning of CPU time.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (IOHprofiler_problem_get_number_of_objectives(problem) != 1 ||
        IOHprofiler_problem_get_evaluations(problem) < 1)
        return 0;
    if (problem->best_value == NULL)
        return 0;
    return problem->best_observed_fvalue[0] >= problem->best_value[0] - problem->final_target_delta[0] ? 1 : 0;
}

/**
 * @note Tentative...
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->best_observed_fvalue[0];
}

/**
 * @note This function breaks the black-box property: the returned  value is not
 * meant to be used by the optimization algorithm.
 */
double IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->best_value != NULL);
    assert(problem->final_target_delta != NULL);
    return problem->best_value[0] + problem->final_target_delta[0];
}

/**
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_name != NULL);
    return problem->problem_name;
}

/**
 * The ID is guaranteed to contain only characters in the set [a-z0-9_-]. It should therefore be safe to use
 * it to construct filenames or other identifiers.
 *
 * Each problem ID should be unique within each benchmark suite.
 *
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_id != NULL);
    return problem->problem_id;
}

const char *IOHprofiler_problem_get_type(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_type != NULL);
    return problem->problem_type;
}

size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->dimension > 0);
    return problem->dimension;
}

size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->number_of_objectives > 0);
    return problem->number_of_objectives;
}
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->smallest_values_of_interest != NULL);
    return problem->smallest_values_of_interest;
}

const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->largest_values_of_interest != NULL);
    return problem->largest_values_of_interest;
}

/**
 * If a special method for setting an initial solution to the problem does not exist, the center of the
 * problem's region of interest is the initial solution.
 * @param problem The given IOHprofiler problem.
 * @param initial_solution The pointer to the initial solution being set by this method.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution) {
    assert(problem != NULL);
    if (problem->initial_solution != NULL) {
        problem->initial_solution(problem, initial_solution);
    } else {
        size_t i;
        assert(problem->smallest_values_of_interest != NULL);
        assert(problem->largest_values_of_interest != NULL);
        for (i = 0; i < problem->number_of_variables; ++i)
            initial_solution[i] = (int)(problem->smallest_values_of_interest[i] + 0.5 * (problem->largest_values_of_interest[i] - problem->smallest_values_of_interest[i]));
    }
}

static IOHprofiler_suite_t *IOHprofiler_problem_get_suite(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite;
}

static void IOHprofiler_problem_set_suite(IOHprofiler_problem_t *problem, IOHprofiler_suite_t *suite) {
    assert(problem != NULL);
    problem->suite = suite;
}

size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite_dep_index;
}

static size_t IOHprofiler_problem_get_suite_dep_function(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_function > 0);
    return problem->suite_dep_function;
}

static size_t IOHprofiler_problem_get_suite_dep_instance(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_instance > 0);
    return problem->suite_dep_instance;
}

/**
 * @brief Returns the data of the transformed problem.
 */
static void *IOHprofiler_problem_transformed_get_data(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->data != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->data;
}

/**
 * @brief Returns the inner problem of the transformed problem.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_get_inner_problem(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the inner problem.
 */
static void IOHprofiler_problem_transformed_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_evaluate_function(data->inner_problem, x, y);
}

/**
 * @brief Calls the IOHprofiler_recommend_solution function on the inner problem.
 */
static void IOHprofiler_problem_transformed_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_recommend_solution(data->inner_problem, x);
}

/**
 * @brief Frees only the data of the transformed problem leaving the inner problem intact.
 *
 * @note If there is no other pointer to the inner problem, access to it will be lost.
 */
static void IOHprofiler_problem_transformed_free_data(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;

    if (data->data != NULL) {
        if (data->data_free_function != NULL) {
            data->data_free_function(data->data);
            data->data_free_function = NULL;
        }
        IOHprofiler_free_memory(data->data);
        data->data = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}

/**
 * @brief Frees the transformed problem.
 */
static void IOHprofiler_problem_transformed_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);
    if (data->inner_problem != NULL) {
        IOHprofiler_problem_free(data->inner_problem);
        data->inner_problem = NULL;
    }
    IOHprofiler_problem_transformed_free_data(problem);
}

/**
 * @brief Allocates a transformed problem that wraps the inner_problem.
 *
 * By default all methods will dispatch to the inner_problem. A prefix is prepended to the problem name
 * in order to reflect the transformation somewhere.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_allocate(IOHprofiler_problem_t *inner_problem,
                                                                       void *user_data,
                                                                       IOHprofiler_data_free_function_t data_free_function,
                                                                       const char *name_prefix) {
    IOHprofiler_problem_transformed_data_t *problem;
    IOHprofiler_problem_t *inner_copy;
    char *old_name = IOHprofiler_strdup(inner_problem->problem_name);

    problem = (IOHprofiler_problem_transformed_data_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    problem->inner_problem = inner_problem;
    problem->data = user_data;
    problem->data_free_function = data_free_function;

    inner_copy = IOHprofiler_problem_duplicate(inner_problem);
    inner_copy->evaluate_function = IOHprofiler_problem_transformed_evaluate_function;
    inner_copy->recommend_solution = IOHprofiler_problem_transformed_recommend_solution;
    inner_copy->problem_free_function = IOHprofiler_problem_transformed_free;
    inner_copy->data = problem;

    IOHprofiler_problem_set_name(inner_copy, "%s(%s)", name_prefix, old_name);
    IOHprofiler_free_memory(old_name);

    return inner_copy;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the underlying problems.
 */
static void IOHprofiler_problem_stacked_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_stacked_data_t *data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    assert(
        IOHprofiler_problem_get_number_of_objectives(problem) == IOHprofiler_problem_get_number_of_objectives(data->problem1) + IOHprofiler_problem_get_number_of_objectives(data->problem2));

    IOHprofiler_evaluate_function(data->problem1, x, &y[0]);
    IOHprofiler_evaluate_function(data->problem2, x, &y[IOHprofiler_problem_get_number_of_objectives(data->problem1)]);
}

/**
 * @brief Frees the stacked problem.
 */
static void IOHprofiler_problem_stacked_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_stacked_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    if (data->problem1 != NULL) {
        IOHprofiler_problem_free(data->problem1);
        data->problem1 = NULL;
    }
    if (data->problem2 != NULL) {
        IOHprofiler_problem_free(data->problem2);
        data->problem2 = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_binary.c"
#endif

#line 1 "code-experiments/src/profiler/../suite/PBO/suite_PBO_legacy_code.c"
/**
 * @file suite_IOHprofiler_legacy_code.c
 * @brief Legacy code from required to replicate the IOHprofiler functions.
 *
 * All of this code should only be used by the suite_IOHprofiler functions to provide compatibility to the
 * legacy code. New test beds should strive to use the new IOHprofiler facilities for random number generation etc.
 */

#ifndef SUITE_PBO_LEGACY_CODE
#define SUITE_PBO_LEGACY_CODE
#include <assert.h>
#include <math.h>
#include <stdio.h>
#ifndef IOHPROFILER
#define IOHPROFILER
#line 17 "code-experiments/src/profiler/../suite/PBO/suite_PBO_legacy_code.c"
#endif

/** @brief Maximal dimension used in IOHprofiler. */
#define SUITE_IOHprofiler_MAX_DIM 5000

/** @brief Computes the minimum of the two values. */
static double IOHprofiler_fmin(double a, double b) {
    return (a < b) ? a : b;
}

/** @brief Computes the maximum of the two values. */
static double IOHprofiler_fmax(double a, double b) {
    return (a > b) ? a : b;
}

/** @brief Rounds the given value. */
static double IOHprofiler_round(double x) {
    return floor(x + 0.5);
}

/**
 * @brief Allocates a n by m matrix structured as an array of pointers to double arrays.
 */
static double **IOHprofiler_allocate_matrix(const size_t n, const size_t m) {
    double **matrix = NULL;
    size_t i;
    matrix = (double **)IOHprofiler_allocate_memory(sizeof(double *) * n);
    for (i = 0; i < n; ++i) {
        matrix[i] = IOHprofiler_allocate_vector(m);
    }
    return matrix;
}

/**
 * @brief Frees the matrix structured as an array of pointers to double arrays.
 */
static void IOHprofiler_free_matrix(double **matrix, const size_t n) {
    size_t i;
    for (i = 0; i < n; ++i) {
        if (matrix[i] != NULL) {
            IOHprofiler_free_memory(matrix[i]);
            matrix[i] = NULL;
        }
    }
    IOHprofiler_free_memory(matrix);
}

/**
 * @brief Generates N uniform random numbers using inseed as the seed and stores them in r.
 */
static void IOHprofiler_unif(double *r, size_t N, long inseed) {
    long aktseed;
   long tmp;
    long rgrand[32];
    long aktrand;
    long i;
    if (inseed < 0)
        inseed = -inseed;
    if (inseed < 1)
        inseed = 1;
   aktseed = inseed;
    for (i = 39; i >= 0; i--) {
        tmp = (int)floor((double)aktseed / (double)127773);
        aktseed = 16807 * (aktseed - tmp * 127773) - 2836 * tmp;
        if (aktseed < 0)
            aktseed = aktseed + 2147483647;
        if (i < 32)
            rgrand[i] = aktseed;
    }
    IOHprofiler_random_state_t *random_generator=IOHprofiler_random_new(aktseed);
    for(i=0;i<N;i++){
       r[i]=IOHprofiler_random_uniform(random_generator);
    }
    IOHprofiler_random_free(random_generator);
}
    /* generates N uniform numbers with starting seed */
/*    long aktseed;
    long tmp;
    long rgrand[32];
    long aktrand;
    long i;

    if (inseed < 0)
        inseed = -inseed;
    if (inseed < 1)
        inseed = 1;
    aktseed = inseed;
    for (i = 39; i >= 0; i--) {
        tmp = (int)floor((double)aktseed / (double)127773);
        aktseed = 16807 * (aktseed - tmp * 127773) - 2836 * tmp;
        if (aktseed < 0)
            aktseed = aktseed + 2147483647;
        if (i < 32)
            rgrand[i] = aktseed;
    }
    aktrand = rgrand[0];
    for (i = 0; i < N; i++) {
        tmp = (int)floor((double)aktseed / (double)127773);
        aktseed = 16807 * (aktseed - tmp * 127773) - 2836 * tmp;
        if (aktseed < 0)
            aktseed = aktseed + 2147483647;
        tmp = (int)floor((double)aktrand / (double)67108865);
        aktrand = rgrand[tmp];
        rgrand[tmp] = aktseed;
        r[i] = (double)aktrand / 2.147483647e9;
        if (r[i] == 0.) {
            r[i] = 1e-99;
        }
    }
    return;
}*/

/**
 * @brief Converts from packed matrix storage to an array of array of double representation.
 */
static double **IOHprofiler_reshape(double **B, double *vector, const size_t m, const size_t n) {
    size_t i, j;
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            B[i][j] = vector[j * m + i];
        }
    }
    return B;
}

/**
 * @brief Generates N Gaussian random numbers using the given seed and stores them in g.
 */
static void IOHprofiler_gauss(double *g, const size_t N, const long seed) {
    size_t i;
    double uniftmp[6000];
    assert(2 * N < 6000);
    IOHprofiler_unif(uniftmp, 2 * N, seed);

    for (i = 0; i < N; i++) {
        g[i] = sqrt(-2 * log(uniftmp[i])) * cos(2 * IOHprofiler_pi * uniftmp[N + i]);
        if (g[i] == 0.)
            g[i] = 1e-99;
    }
    return;
}

/**
 * @brief Computes a DIM by DIM rotation matrix based on seed and stores it in B.
 */
static void IOHprofiler_compute_rotation(double **B, const long seed, const size_t DIM) {
    /* To ensure temporary data fits into gvec */
    double prod;
    double gvect[2000];
    long i, j, k; /* Loop over pairs of column vectors. */

    assert(DIM * DIM < 2000);

    IOHprofiler_gauss(gvect, DIM * DIM, seed);
    IOHprofiler_reshape(B, gvect, DIM, DIM);
    /*1st coordinate is row, 2nd is column.*/

    for (i = 0; i < DIM; i++) {
        for (j = 0; j < i; j++) {
            prod = 0;
            for (k = 0; k < DIM; k++)
                prod += B[k][i] * B[k][j];
            for (k = 0; k < DIM; k++)
                B[k][i] -= prod * B[k][j];
        }
        prod = 0;
        for (k = 0; k < DIM; k++)
            prod += B[k][i] * B[k][i];
        for (k = 0; k < DIM; k++)
            B[k][i] /= sqrt(prod);
    }
}

static void IOHprofiler_copy_rotation_matrix(double **rot, double *M, double *b, const size_t DIM) {
    size_t row, column;
    double *current_row;

    for (row = 0; row < DIM; ++row) {
        current_row = M + row * DIM;
        for (column = 0; column < DIM; ++column) {
            current_row[column] = rot[row][column];
        }
        b[row] = 0.0;
    }
}

/**
 * @brief Randomly computes the location of the global optimum.
 */
static void IOHprofiler_compute_xopt(int *xopt, const long seed, const size_t DIM) {
    long i;
    double *xopttemp;
    xopttemp = IOHprofiler_allocate_vector(DIM);
    IOHprofiler_unif(xopttemp, DIM, seed);
    for (i = 0; i < DIM; i++) {
        xopt[i] = (int)(2 * floor(1e4 * xopttemp[i]) / 1e4 / 1);
    }
    IOHprofiler_free_memory(xopttemp);
}

/**
 * @brief Randomly computes the location of the global optimum.
 */
static void IOHprofiler_compute_xopt_double(double *xopt, const long seed, const size_t DIM) {
    long i;
    IOHprofiler_unif(xopt, DIM, seed);
    for (i = 0; i < DIM; i++) {
        xopt[i] = floor(1e4 * xopt[i]) / 1e4;
        if (xopt[i] == 0.0)
            xopt[i] = -1e-5;
    }
}

/**
 * @brief Randomly chooses the objective offset for the given function and instance.
 */
static double IOHprofiler_compute_fopt(const size_t function, const size_t instance) {
  long rseed, rrseed;
  double gval, gval2;


  rseed = (long) function;

  rrseed = rseed + (long) (10000 * instance);
  IOHprofiler_gauss(&gval, 1, rrseed);
  IOHprofiler_gauss(&gval2, 1, rrseed + 1);
  return IOHprofiler_fmin(1000., IOHprofiler_fmax(-1000., IOHprofiler_round(100. * 100. * gval / gval2) / 100.));
}
#endif
#line 25 "code-experiments/src/profiler/../suite/PBO/f_binary.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_shift.c"
/**
 * @file transform_obj_shift.c
 * @brief Implementation of shifting the objective value by the given offset.
 */
#ifndef TRANSFORM_OBJ_SHIFT
#define TRANSFORM_OBJ_SHIFT

#include <assert.h>

#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler.h"
/**
 * @file IOHprofiler.h
 * @brief All public IOHprofiler functions and variables are defined in this file.
 *
 * It is the authoritative reference, if any function deviates from the documented behavior it is considered
 * a bug. See the function definitions for their detailed descriptions.
 */

#ifndef __IOHprofiler_H__
#define __IOHprofiler_H__

#include <stddef.h>

/* Definitions of some 32 and 64-bit types (used by the random number generator) */
#ifdef _MSC_VER
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

/* Include definition for NAN among other things */
#include <float.h>
#include <math.h>
#ifndef NAN
/** @brief Definition of NAN to be used only if undefined by the included headers */
#define NAN 8.8888e88
#endif
#ifndef isnan
/** @brief Definition of isnan to be used only if undefined by the included headers */
#define isnan(x) (0)
#endif
#ifndef INFINITY
/** @brief Definition of INFINITY to be used only if undefined by the included headers */
#define INFINITY 1e22
/* why not using 1e99? */
#endif
#ifndef isinf
/** @brief Definition of isinf to be used only if undefined by the included headers */
#define isinf(x) (0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief IOHprofiler's version.
 *
 * Automatically updated by do.py.
 */
/**@{*/
static const char IOHprofiler_version[32] = "";
/**@}*/

/***********************************************************************************************************/
/**
 * @brief IOHprofiler's own pi constant. Simplifies the case, when the value of pi changes.
 */
/**@{*/
static const double IOHprofiler_pi = 3.14159265358979323846;
/**@}*/

/***********************************************************************************************************/

/** @brief Logging level type. */
typedef enum {
    IOHprofiler_ERROR,   /**< @brief only error messages are output */
    IOHprofiler_WARNING, /**< @brief error and warning messages are output */
    IOHprofiler_INFO,    /**< @brief error, warning and info messages are output */
    IOHprofiler_DEBUG    /**< @brief error, warning, info and debug messages are output */
} IOHprofiler_log_level_type_e;

/***********************************************************************************************************/

/** @brief Structure containing a IOHprofiler problem. */
struct IOHprofiler_problem_s;

/**
 * @brief The IOHprofiler problem type.
 *
 * See IOHprofiler_problem_s for more information on its fields. */
typedef struct IOHprofiler_problem_s IOHprofiler_problem_t;

/** @brief Structure containing a IOHprofiler suite. */
struct IOHprofiler_suite_s;

/**
 * @brief The IOHprofiler suite type.
 *
 * See IOHprofiler_suite_s for more information on its fields. */
typedef struct IOHprofiler_suite_s IOHprofiler_suite_t;

/** @brief Structure containing a IOHprofiler observer. */
struct IOHprofiler_observer_s;

/**
 * @brief The IOHprofiler observer type.
 *
 * See IOHprofiler_observer_s for more information on its fields. */
typedef struct IOHprofiler_observer_s IOHprofiler_observer_t;

/** @brief Structure containing a IOHprofiler archive. */
struct IOHprofiler_archive_s;

/**
 * @brief The IOHprofiler archive type.
 *
 * See IOHprofiler_archive_s for more information on its fields. */
typedef struct IOHprofiler_archive_s IOHprofiler_archive_t;

/** @brief Structure containing a IOHprofiler random state. */
struct IOHprofiler_random_state_s;

/**
 * @brief The IOHprofiler random state type.
 *
 * See IOHprofiler_random_state_s for more information on its fields. */
typedef struct IOHprofiler_random_state_s IOHprofiler_random_state_t;

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler suite
 */
/**@{*/

/**
 * @brief Constructs a IOHprofiler suite.
 */
IOHprofiler_suite_t *IOHprofiler_suite(const char *suite_name, const char *suite_instance, const char *suite_options,int number, char** layer_param,char * temp_dim);

/**
 * @brief Frees the given suite.
 */
void IOHprofiler_suite_free(IOHprofiler_suite_t *suite);

/**
 * @brief Returns the next (observed) problem of the suite or NULL if there is no next problem left.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_next_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 *
 * @returns The current problem of the suite.
 */
IOHprofiler_problem_t *IOHprofiler_suite_reset_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 * @brief Returns the problem of the suite defined by problem_index.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_problem(IOHprofiler_suite_t *suite, const size_t problem_index);

/**
 * @brief Returns the number of problems in the given suite.
 */
size_t IOHprofiler_suite_get_number_of_problems(const IOHprofiler_suite_t *suite);

/**
 * @brief Returns the function number in the suite in position function_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_function_from_function_index(const IOHprofiler_suite_t *suite, const size_t function_idx);

/**
 * @brief Returns the dimension number in the suite in position dimension_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_dimension_from_dimension_index(const IOHprofiler_suite_t *suite, const size_t dimension_idx);

/**
 * @brief Returns the instance number in the suite in position instance_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_instance_from_instance_index(const IOHprofiler_suite_t *suite, const size_t instance_idx);
/**@}*/

/**
 * @name Encoding/decoding problem index
 *
 * General schema for encoding/decoding a problem index. Note that the index depends on the number of
 * instances a suite is defined with (it should be called a suite-instance-depending index...).
 * Also, while functions, instances and dimensions start from 1, function_idx, instance_idx and dimension_idx
 * as well as suite_dep_index start from 0!
 *
 * Showing an example with 2 dimensions (2, 3), 5 instances (6, 7, 8, 9, 10) and 2 functions (1, 2):
 *
   \verbatim
   index | instance | function | dimension
   ------+----------+----------+-----------
       0 |        6 |        1 |         2
       1 |        7 |        1 |         2
       2 |        8 |        1 |         2
       3 |        9 |        1 |         2
       4 |       10 |        1 |         2
       5 |        6 |        2 |         2
       6 |        7 |        2 |         2
       7 |        8 |        2 |         2
       8 |        9 |        2 |         2
       9 |       10 |        2 |         2
      10 |        6 |        1 |         3
      11 |        7 |        1 |         3
      12 |        8 |        1 |         3
      13 |        9 |        1 |         3
      14 |       10 |        1 |         3
      15 |        6 |        2 |         2
      16 |        7 |        2 |         3
      17 |        8 |        2 |         3
      18 |        9 |        2 |         3
      19 |       10 |        2 |         3

   index | instance_idx | function_idx | dimension_idx
   ------+--------------+--------------+---------------
       0 |            0 |            0 |             0
       1 |            1 |            0 |             0
       2 |            2 |            0 |             0
       3 |            3 |            0 |             0
       4 |            4 |            0 |             0
       5 |            0 |            1 |             0
       6 |            1 |            1 |             0
       7 |            2 |            1 |             0
       8 |            3 |            1 |             0
       9 |            4 |            1 |             0
      10 |            0 |            0 |             1
      11 |            1 |            0 |             1
      12 |            2 |            0 |             1
      13 |            3 |            0 |             1
      14 |            4 |            0 |             1
      15 |            0 |            1 |             1
      16 |            1 |            1 |             1
      17 |            2 |            1 |             1
      18 |            3 |            1 |             1
      19 |            4 |            1 |             1
   \endverbatim
 */
/**@{*/
/**
 * @brief Computes the index of the problem in the suite that corresponds to the given function, dimension
 * and instance indices.
 */
size_t IOHprofiler_suite_encode_problem_index(const IOHprofiler_suite_t *suite,
                                              const size_t function_idx,
                                              const size_t dimension_idx,
                                              const size_t instance_idx);

/**
 * @brief Computes the function, dimension and instance indexes of the problem with problem_index in the
 * given suite.
 */
void IOHprofiler_suite_decode_problem_index(const IOHprofiler_suite_t *suite,
                                            const size_t problem_index,
                                            size_t *function_idx,
                                            size_t *dimension_idx,
                                            size_t *instance_idx);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler observer
 */
/**@{*/
/**
 * @brief Constructs a IOHprofiler observer.
 */
IOHprofiler_observer_t *IOHprofiler_observer(const char *observer_name, const char *options);

/**
 * @brief Frees the given observer.
 */
void IOHprofiler_observer_free(IOHprofiler_observer_t *observer);

/**
 * @brief Adds an observer to the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_add_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**
 * @brief Removes an observer from the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_remove_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler problem
 */
/**@{*/
/**
 * @brief Evaluates the problem function in point x and save the result in y.
  logger_** functions use number_of_parameters and parameters to log extra informations of algorithms' adaptive parameters.
  If there is no need to log parameters, set number_of_parameters and parameters as 0 and NULL respectively.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Evaluates the problem constraints in point x and save the result in y.
 */
void IOHprofiler_evaluate_constraint(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Recommends a solution as the current best guesses to the problem.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief Frees the given problem.
 */
void IOHprofiler_problem_free(IOHprofiler_problem_t *problem);

void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters);

/**
 * @brief Returns the name of the problem.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the ID of the problem.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of variables i.e. the dimension of the problem.
 */
size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of objectives of the problem.
 */
size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of evaluations done on the problem.
 */
size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns 1 if the final target was hit, 0 otherwise.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the best observed value for the first objective.
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the target value for the first objective.
 */
double depreciated_IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with lower bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with upper bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the problem_index of the problem in its current suite.
 */
size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns an initial solution, i.e. a feasible variable setting, to the problem.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding random numbers
 */
/**@{*/

/**
 * @brief Creates and returns a new random number state using the given seed.
 */
IOHprofiler_random_state_t *IOHprofiler_random_new(uint32_t seed);

/**
 * @brief Frees all memory associated with the random state.
 */
void IOHprofiler_random_free(IOHprofiler_random_state_t *state);

/**
 * @brief Returns one uniform [0, 1) random value from the random number generator associated with the given
 * state.
 */
double IOHprofiler_random_uniform(IOHprofiler_random_state_t *state);

/**
 * @brief Generates an approximately normal random number.
 */
double IOHprofiler_random_normal(IOHprofiler_random_state_t *state);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods managing memory
 */
/**@{*/
/**
 * @brief Safe memory allocation that either succeeds or triggers a IOHprofiler_error.
 */
void *IOHprofiler_allocate_memory(const size_t size);

/**
 * @brief Safe memory allocation for a vector of doubles that either succeeds or triggers a IOHprofiler_error.
 */
double *IOHprofiler_allocate_vector(const size_t size);

/**
 * @brief Safe memory allocation for a vector of int that either succeeds or triggers a IOHprofiler_error.
 */
int *IOHprofiler_allocate_int_vector(const size_t size);

/**
 * @brief Frees the allocated memory.
 */
void IOHprofiler_free_memory(void *data);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler messages
 */
/**@{*/
/**
 * @brief Signals a fatal error.
 */
void IOHprofiler_error(const char *message, ...);

/**
 * @brief Warns about error conditions.
 */
void IOHprofiler_warning(const char *message, ...);

/**
 * @brief Outputs some information.
 */
void IOHprofiler_info(const char *message, ...);

/**
 * @brief Prints only the given message without any prefix and new line.
 *
 * A function similar to IOHprofiler_info but producing no additional text than
 * the given message.
 *
 * The output is only produced if IOHprofiler_log_level >= IOHprofiler_INFO.
 */
void IOHprofiler_info_partial(const char *message, ...);

/**
 * @brief Outputs detailed information usually used for debugging.
 */
void IOHprofiler_debug(const char *message, ...);

/**
 * @brief Sets the IOHprofiler log level to the given value and returns the previous value of the log level.
 */
const char *IOHprofiler_set_log_level(const char *level);
/**@}*/

/***********************************************************************************************************/

/**
 * @brief Constructs a IOHprofiler archive.
 */
IOHprofiler_archive_t *IOHprofiler_archive(const char *suite_name,
                                           const size_t function,
                                           const size_t dimension,
                                           const size_t instance);
/**
 * @brief Adds a solution with objectives (y1, y2) to the archive if none of the existing solutions in the
 * archive dominates it. In this case, returns 1, otherwise the archive is not updated and the method
 * returns 0.
 */

int IOHprofiler_archive_add_solution(IOHprofiler_archive_t *archive, const double y1, const double y2, const char *text);

/**
 * @brief Returns the number of (non-dominated) solutions in the archive (computed first, if needed).
 */
size_t IOHprofiler_archive_get_number_of_solutions(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the hypervolume of the archive (computed first, if needed).
 */
double IOHprofiler_archive_get_hypervolume(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the text of the next (non-dominated) solution in the archive and "" when there are no
 * solutions left. The first two solutions are always the extreme ones.
 */
const char *IOHprofiler_archive_get_next_solution_text(IOHprofiler_archive_t *archive);

/**
 * @brief Frees the archive.
 */
void IOHprofiler_archive_free(IOHprofiler_archive_t *archive);

/***********************************************************************************************************/

/**
 * @name Other useful methods
 */
/**@{*/
/**
 * @brief Removes the given directory and all its contents.
 */
int IOHprofiler_remove_directory(const char *path);

/**
 * @brief Formatted string duplication.
 */
char *IOHprofiler_strdupf(const char *str, ...);
/**@}*/

/***********************************************************************************************************/
typedef int (*int_to_int_func)(int);

struct WModel{
  size_t number_of_layers;
  int *layer1;
  int min1; int_to_int_func l_max1;
  int *layer2;
  int min2;int_to_int_func l_max2;
  int *layer3;
  int min3; int_to_int_func l_max3;
  int *layer4;
  int min4; int_to_int_func l_max4;
  int *counter;
};


#ifdef __cplusplus
}
#endif
#endif
#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_shift.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_problem.c"
/**
 * @file IOHprofiler_problem.c
 * @brief Definitions of functions regarding IOHprofiler problems.
 */
#ifndef IOH_PROFILER_PROBLEM
#define IOH_PROFILER_PROBLEM

#include <float.h>
#line 10 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_problem.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_internal.h"
/**
 * @file IOHprofiler_internal.h
 * @brief Definitions of internal IOHprofiler structures and typedefs.
 *
 * These are used throughout the IOHprofiler code base but should not be used by any external code.
 */

#ifndef __IOHprofiler_INTERNAL__
#define __IOHprofiler_INTERNAL__

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************************************/
/**
 * @brief The data free function type.
 *
 * This is a template for functions that free the contents of data (used to free the contents of data
 * fields in IOHprofiler_problem, IOHprofiler_suite and IOHprofiler_observer).
 */
typedef void (*IOHprofiler_data_free_function_t)(void *data);

/**
 * @brief The problem free function type.
 *
 * This is a template for functions that free the problem structure.
 */
typedef void (*IOHprofiler_problem_free_function_t)(IOHprofiler_problem_t *problem);

/**
 * @brief The initial solution function type.
 *
 * This is a template for functions that return an initial solution of the problem.
 */
typedef void (*IOHprofiler_initial_solution_function_t)(const IOHprofiler_problem_t *problem, int *x);

/**
 * @brief The evaluate function type.
 *
 * This is a template for functions that perform an evaluation of the problem (to evaluate the problem
 * function, the problems constraints etc.).
 */
typedef void (*IOHprofiler_evaluate_function_t)(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief The recommend solutions function type.
 *
 * This is a template for functions that log a recommended solution.
 */
typedef void (*IOHprofiler_recommend_function_t)(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief The allocate logger function type.
 *
 * This is a template for functions that allocate a logger (wrap a logger around the given problem and return
 * the wrapped problem).
 */
typedef IOHprofiler_problem_t *(*IOHprofiler_logger_allocate_function_t)(IOHprofiler_observer_t *observer,
                                                                         IOHprofiler_problem_t *problem);

/**
 * @brief The transformed IOHprofiler problem data type.
 *
 * This is a type of a generic structure for a transformed ("outer") IOHprofiler_problem. It makes possible the
 * wrapping of problems as layers of an onion. Initialized in the IOHprofiler_problem_transformed_allocate function,
 * it makes the current ("outer") transformed problem a "derived problem class", which inherits from the
 * "inner" problem, the "base class".
 *
 * From the perspective of the inner problem:
 * - data holds the meta-information to administer the inheritance
 * - data->data holds the additional fields of the derived class (the outer problem)
 * - data->inner_problem points to the inner problem (now we have a linked list)
 */
typedef struct {
    IOHprofiler_problem_t *inner_problem;                /**< @brief Pointer to the inner problem */
    void *data;                                          /**< @brief Pointer to data, which enables further
                                                  wrapping of the problem */
    IOHprofiler_data_free_function_t data_free_function; /**< @brief Function to free the contents of data */
} IOHprofiler_problem_transformed_data_t;

/**
 * @brief The free logger function type.
 *
 * This is a template for functions that free a logger.
 */
typedef void (*IOHprofiler_logger_free_function_t)(void *logger);

/**
 * @brief The stacked IOHprofiler problem data type.
 *
 * This is a type of a structure used when stacking two problems (especially useful for constructing
 * multi-objective problems).
 */
typedef struct {
    IOHprofiler_problem_t *problem1; /**< @brief Pointer to the first problem (objective) */
    IOHprofiler_problem_t *problem2; /**< @brief Pointer to the second problem (objective) */
} IOHprofiler_problem_stacked_data_t;

/**
 * @brief The option keys data type.
 *
 * This is a type of a structure used to contain a set of known option keys (used by suites and observers).
 */
typedef struct {
    size_t count; /**< @brief Number of option keys */
    char **keys;  /**< @brief Pointer to option keys */
} IOHprofiler_option_keys_t;

/***********************************************************************************************************/

/**
 * @brief The IOHprofiler problem structure.
 *
 * This is one of the main structures in IOHprofiler. It contains information about a problem to be optimized. The
 * problems can be wrapped around each other (similar to the onion layers) by means of the data field and
 * the IOHprofiler_problem_transformed_data_t structure creating some kind of "object inheritance". Even the logger
 * is considered as just another IOHprofiler_problem instance wrapped around the original problem.
 */
struct IOHprofiler_problem_s {
    IOHprofiler_initial_solution_function_t initial_solution;  /**< @brief  The function for creating an initial solution. */
    IOHprofiler_evaluate_function_t evaluate_function;         /**< @brief  The function for evaluating the problem. */
    IOHprofiler_recommend_function_t recommend_solution;       /**< @brief  The function for recommending a solution. */
    IOHprofiler_problem_free_function_t problem_free_function; /**< @brief  The function for freeing this problem. */

    size_t dimension; /**< @brief Number of variables expected before any transformation, used for logging files. */
    size_t number_of_variables;  /**< @brief Number of variables expected by the function, i.e.
                                       problem dimension */
    size_t number_of_objectives; /**< @brief Number of objectives. */
    size_t number_of_parameters; /**<  IOHprofiler @brief Number of parameters. */

    int *smallest_values_of_interest; /**< @brief The lower bounds of the ROI in the decision space. */
    int *largest_values_of_interest;  /**< @brief The upper bounds of the ROI in the decision space. */

    double *best_value;  /**< @brief Optimal (smallest) function value */
    double *nadir_value; /**< @brief The nadir point (defined when number_of_objectives > 1) */
    int *best_parameter; /**< @brief Optimal decision vector (defined only when unique) */
    double *parameters;  /** IOHprofiler @brief parameters setting */
    double *raw_fitness;

    char *problem_name; /**< @brief Problem name. */
    char *problem_id;   /**< @brief Problem ID (unique in the containing suite) */
    char *problem_type; /**< @brief Problem type */

    size_t evaluations; /**< @brief Number of evaluations performed on the problem. */

    /* Convenience fields for output generation */

    double final_target_delta[1];       /**< @brief Final target delta. */
    double best_observed_fvalue[1];     /**< @brief The best observed value so far. */
    size_t best_observed_evaluation[1]; /**< @brief The evaluation when the best value so far was achieved. */

    /* Fields depending on the containing benchmark suite */

    IOHprofiler_suite_t *suite; /**< @brief Pointer to the containing suite (NULL if not given) */
    size_t suite_dep_index;     /**< @brief Suite-depending problem index (starting from 0) */
    size_t suite_dep_function;  /**< @brief Suite-depending function */
    size_t suite_dep_instance;  /**< @brief Suite-depending instance */

    void *data; /**< @brief Pointer to a data instance @see IOHprofiler_problem_transformed_data_t */
};

/**
 * @brief The IOHprofiler observer structure.
 *
 * An observer observes the whole benchmark process. It is independent of suites and problems. Each time a
 * new problem of the suite is being observed, the observer initializes a new logger (wraps the observed
 * problem with the corresponding logger).
 */
struct IOHprofiler_observer_s {
    int is_active;         /**< @brief Whether the observer is active (the logger will log some output). */
    char *observer_name;   /**< @brief Name of the observer for identification purposes. */
    char *result_folder;   /**< @brief Name of the result folder. */
    char *algorithm_name;  /**< @brief Name of the algorithm to be used in logger output. */
    char *algorithm_info;  /**< @brief Additional information on the algorithm to be used in logger output. */
    char *parameters_name; /**< @brief Name of recorded parameters to be used in logger output. */
    size_t number_target_triggers;
    /**< @brief The number of targets between each 10**i and 10**(i+1). */
    double target_precision; /**< @brief The minimal precision used for targets. */
    size_t number_evaluation_triggers;
    /**< @brief The number of triggers between each 10**i and 10**(i+1) evaluation number. */
    char *base_evaluation_triggers;
    /**< @brief The "base evaluations" used to evaluations that trigger logging. */
    size_t number_interval_triggers;
    /**< @brief The size of interval between two triggers. */
    char *complete_triggers; /**< @brief The symbol for recording all evaluation. */

    int precision_x; /**< @brief Output precision for decision variables. */
    int precision_f; /**< @brief Output precision for function values. */
    void *data;      /**< @brief Void pointer that can be used to point to data specific to an observer. */

    IOHprofiler_data_free_function_t data_free_function;             /**< @brief  The function for freeing this observer. */
    IOHprofiler_logger_allocate_function_t logger_allocate_function; /**< @brief  The function for allocating the logger. */
    IOHprofiler_logger_free_function_t logger_free_function;         /**< @brief  The function for freeing the logger. */
};

/**
 * @brief The IOHprofiler suite structure.
 *
 * A suite is a collection of problems constructed by a Cartesian product of the suite's optimization
 * functions, dimensions and instances. The functions and dimensions are fixed for a suite with some name,
 * while the instances are defined dynamically. The suite can be filtered - only the chosen functions,
 * dimensions and instances will be taken into account when iterating through the suite.
 */
struct IOHprofiler_suite_s {
    char *suite_name; /**< @brief Name of the suite. */

    size_t number_of_dimensions; /**< @brief Number of dimensions contained in the suite. */
    size_t *dimensions;          /**< @brief The dimensions contained in the suite. */

    size_t number_of_functions; /**< @brief Number of functions contained in the suite. */
    size_t *functions;          /**< @brief The functions contained in the suite. */

    size_t number_of_instances; /**< @brief Number of instances contained in the suite. */
    char *default_instances;    /**< @brief The instances contained in the suite by default. */
    size_t *instances;          /**< @brief The instances contained in the suite. */

    IOHprofiler_problem_t *current_problem; /**< @brief Pointer to the currently tackled problem. */
    long current_dimension_idx;             /**< @brief The dimension index of the currently tackled problem. */
    long current_function_idx;              /**< @brief The function index of the currently tackled problem. */
    long current_instance_idx;              /**< @brief The instance index of the currently tackled problem. */

    void *data; /**< @brief Void pointer that can be used to point to data specific to a suite. */

    IOHprofiler_data_free_function_t data_free_function; /**< @brief The function for freeing this suite. */
};

#ifdef __cplusplus
}
#endif
#endif
#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_problem.c"

#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_utilities.c"
/**
 * @file IOHprofiler_utilities.c
 * @brief Definitions of miscellaneous functions used throughout the IOHprofiler framework.
 */
#ifndef IOH_PROFILER_UTILITIES
#define IOH_PROFILER_UTILITIES

#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_platform.h"
/**
 * @file IOHprofiler_platform.h
 * @brief Automatic platform-dependent configuration of the IOHprofiler framework.
 *
 * Some platforms and standard conforming compilers require extra defines or includes to provide some
 * functionality.
 *
 * Because most feature defines need to be set before the first system header is included and we do not
 * know when a system header is included for the first time in the amalgamation, all internal files
 * that need these definitions should include this file before any system headers.
 */

#ifndef __COCO_PLATFORM__
#define __COCO_PLATFORM__

#include <stddef.h>

/* Definitions of IOHprofiler_PATH_MAX, IOHprofiler_path_separator, HAVE_GFA and HAVE_STAT heavily used by functions in
 * IOHprofiler_utilities.c */
#if defined(_WIN32) || defined(_WIN64) || defined(__MINGW64__) || defined(__CYGWIN__)
#include <windows.h>
static const char *IOHprofiler_path_separator = "\\";
#define IOHprofiler_PATH_MAX MAX_PATH
#define HAVE_GFA 1
#elif defined(__gnu_linux__)
#include <linux/limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__APPLE__)
#include <sys/stat.h>
#include <sys/syslimits.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__FreeBSD__)
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif (defined(__sun) || defined(sun)) && (defined(__SVR4) || defined(__svr4__))
/* Solaris */
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#else
#error Unknown platform
#endif
#if !defined(IOHprofiler_PATH_MAX)
#error IOHprofiler_PATH_MAX undefined
#endif

/* Definitions needed for creating and removing directories */
/* Separately handle the special case of Microsoft Visual Studio 2008 with x86_64-w64-mingw32-gcc */
#if _MSC_VER
#include <direct.h>
#elif defined(__MINGW32__) || defined(__MINGW64__)
#include <dirent.h>
#else
#include <dirent.h>

#ifdef __cplusplus
extern "C" {
#endif

/* To silence the compiler (implicit-function-declaration warning). */
/** @cond */
int rmdir(const char *pathname);
int unlink(const char *file_name);
int mkdir(const char *pathname, mode_t mode);
/** @endcond */
#endif

/* Definition of the S_IRWXU constant needed to set file permissions */
#if defined(HAVE_GFA)
#define S_IRWXU 0700
#endif

/* To silence the Visual Studio compiler (C4996 warnings in the python build). */
#ifdef _MSC_VER
#pragma warning(disable : 4996)
#endif

#ifdef __cplusplus
}
#endif

#endif
#line 9 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_utilities.c"

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#line 18 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_utilities.c"
#line 19 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_utilities.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_string.c"
/**
 * @file IOHprofiler_string.c
 * @brief Definitions of functions that manipulate strings.
 */
#ifndef IOH_PROFILER_STRING
#define IOH_PROFILER_STRING

#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#line 13 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_string.c"

static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements);

/**
 * @brief Creates a duplicate copy of string and returns a pointer to it.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strdup(const char *string) {
    size_t len;
    char *duplicate;
    if (string == NULL)
        return NULL;
    len = strlen(string);
    duplicate = (char *)IOHprofiler_allocate_memory(len + 1);
    memcpy(duplicate, string, len + 1);
    return duplicate;
}

/**
 * @brief The length of the buffer used in the IOHprofiler_vstrdupf function.
 *
 * @note This should be handled differently!
 */
#define IOHprofiler_VSTRDUPF_BUFLEN 444

/**
 * @brief Formatted string duplication, with va_list arguments.
 */
static char *IOHprofiler_vstrdupf(const char *str, va_list args) {
    static char buf[IOHprofiler_VSTRDUPF_BUFLEN];
    long written;
    /* apparently args can only be used once, therefore
   * len = vsnprintf(NULL, 0, str, args) to find out the
   * length does not work. Therefore we use a buffer
   * which limits the max length. Longer strings should
   * never appear anyway, so this is rather a non-issue. */

#if 0
  written = vsnprintf(buf, IOHprofiler_VSTRDUPF_BUFLEN - 2, str, args);
  if (written < 0)
  IOHprofiler_error("IOHprofiler_vstrdupf(): vsnprintf failed on '%s'", str);
#else /* less safe alternative, if vsnprintf is not available */
    assert(strlen(str) < IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2);
    if (strlen(str) >= IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2)
        IOHprofiler_error("IOHprofiler_vstrdupf(): string is too long");
    written = vsprintf(buf, str, args);
    if (written < 0)
        IOHprofiler_error("IOHprofiler_vstrdupf(): vsprintf failed on '%s'", str);
#endif
    if (written > IOHprofiler_VSTRDUPF_BUFLEN - 3)
        IOHprofiler_error("IOHprofiler_vstrdupf(): A suspiciously long string is tried to being duplicated '%s'", buf);
    return IOHprofiler_strdup(buf);
}

#undef IOHprofiler_VSTRDUPF_BUFLEN

/**
 * Optional arguments are used like in sprintf.
 */
char *IOHprofiler_strdupf(const char *str, ...) {
    va_list args;
    char *s;

    va_start(args, str);
    s = IOHprofiler_vstrdupf(str, args);
    va_end(args);
    return s;
}

/**
 * @brief Returns a concatenate copy of string1 + string2.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strconcat(const char *s1, const char *s2) {
    size_t len1 = strlen(s1);
    size_t len2 = strlen(s2);
    char *s = (char *)IOHprofiler_allocate_memory(len1 + len2 + 1);

    memcpy(s, s1, len1);
    memcpy(&s[len1], s2, len2 + 1);
    return s;
}

/**
 * @brief Returns the first index where seq occurs in base and -1 if it doesn't.
 *
 * @note If there is an equivalent standard C function, this can/should be removed.
 */
static long IOHprofiler_strfind(const char *base, const char *seq) {
    const size_t strlen_seq = strlen(seq);
    const size_t last_first_idx = strlen(base) - strlen(seq);
    size_t i, j;

    if (strlen(base) < strlen(seq))
        return -1;

    for (i = 0; i <= last_first_idx; ++i) {
        if (base[i] == seq[0]) {
            for (j = 0; j < strlen_seq; ++j) {
                if (base[i + j] != seq[j])
                    break;
            }
            if (j == strlen_seq) {
                if (i > 1e9)
                    IOHprofiler_error("IOHprofiler_strfind(): strange values observed i=%lu, j=%lu, strlen(base)=%lu",
                                      (unsigned long)i, (unsigned long)j, (unsigned long)strlen(base));
                return (long)i;
            }
        }
    }
    return -1;
}

/**
 * @brief Splits a string based on the given delimiter.
 *
 * Returns a pointer to the resulting substrings with NULL as the last one.
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char **IOHprofiler_string_split(const char *string, const char delimiter) {
    char **result;
    char *str_copy, *ptr, *token;
    char str_delimiter[2];
    size_t i;
    size_t count = 1;

    str_copy = IOHprofiler_strdup(string);

    /* Counts the parts between delimiters */
    ptr = str_copy;
    while (*ptr != '\0') {
        if (*ptr == delimiter) {
            count++;
        }
        ptr++;
    }
    /* Makes room for an empty string that will be appended at the end */
    count++;

    result = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));

    /* Iterates through tokens
   * NOTE: strtok() ignores multiple delimiters, therefore the final number of detected substrings might be
   * lower than the count. This is OK. */
    i = 0;
    /* A char* delimiter needs to be used, otherwise strtok() can surprise */
    str_delimiter[0] = delimiter;
    str_delimiter[1] = '\0';
    token = strtok(str_copy, str_delimiter);
    while (token) {
        assert(i < count);
        *(result + i++) = IOHprofiler_strdup(token);
        token = strtok(NULL, str_delimiter);
    }
    *(result + i) = NULL;

    IOHprofiler_free_memory(str_copy);

    return result;
}

/**
 * @brief Creates and returns a string with removed characters between from and to.
 *
 * If you wish to remove characters from the beginning of the string, set from to "".
 * If you wish to remove characters until the end of the string, set to to "".
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_remove_from_string(const char *string, const char *from, const char *to) {
    char *result, *start, *stop;

    result = IOHprofiler_strdup(string);

    if (strcmp(from, "") == 0) {
        /* Remove from the start */
        start = result;
    } else
        start = strstr(result, from);

    if (strcmp(to, "") == 0) {
        /* Remove until the end */
        stop = result + strlen(result);
    } else
        stop = strstr(result, to);

    if ((start == NULL) || (stop == NULL) || (stop < start)) {
        IOHprofiler_error("IOHprofiler_remove_from_string(): failed to remove characters between %s and %s from string %s",
                          from, to, string);
        return NULL; /* Never reached */
    }

    memmove(start, stop, strlen(stop) + 1);

    return result;
}

/**
 * @brief Returns the numbers defined by the ranges.
 *
 * Reads ranges from a string of positive ranges separated by commas. For example: "-3,5-6,8-". Returns the
 * numbers that are defined by the ranges if min and max are used as their extremes. If the ranges with open
 * beginning/end are not allowed, use 0 as min/max. The returned string has an appended 0 to mark its end.
 * A maximum of max_count values is returned. If there is a problem with one of the ranges, the parsing stops
 * and the current result is returned. The memory of the returned object needs to be freed by the caller.
 */
static size_t *IOHprofiler_string_parse_ranges(const char *string,
                                               const size_t min,
                                               const size_t max,
                                               const char *name,
                                               const size_t max_count) {
    char *ptr, *dash = NULL;
    char **ranges, **numbers;
    size_t i, j, count;
    size_t num[2];

    size_t *result;
    size_t i_result = 0;

    char *str = IOHprofiler_strdup(string);

    /* Check for empty string */
    if ((str == NULL) || (strlen(str) == 0)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): cannot parse empty ranges");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    ptr = str;
    /* Check for disallowed characters */
    while (*ptr != '\0') {
        if ((*ptr != '-') && (*ptr != ',') && !isdigit((unsigned char)*ptr)) {
            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - cannot parse ranges with '%c'", str,
                                *ptr);
            IOHprofiler_free_memory(str);
            return NULL;
        } else
            ptr++;
    }
    /* Check for incorrect boundaries */
    if ((max > 0) && (min > max)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): incorrect boundaries");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    result = IOHprofiler_allocate_vector_size_t(max_count + 1);

    /* Split string to ranges w.r.t commas */
    ranges = IOHprofiler_string_split(str, ',');
    IOHprofiler_free_memory(str);
    if (ranges) {
        /* Go over the current range */
        for (i = 0; *(ranges + i); i++) {
            ptr = *(ranges + i);
            /* Count the number of '-' */
            count = 0;
            while (*ptr != '\0') {
                if (*ptr == '-') {
                    if (count == 0)
                        /* Remember the position of the first '-' */
                        dash = ptr;
                    count++;
                }
                ptr++;
            }
            /* Point again to the start of the range */
            ptr = *(ranges + i);

            /* Check for incorrect number of '-' */
            if (count > 1) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - too many '-'s", string);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            } else if (count == 0) {
                /* Range is in the format: n (no range) */
                num[0] = (size_t)strtol(ptr, NULL, 10);
                num[1] = num[0];
            } else {
                /* Range is in one of the following formats: n-m / -n / n- / - */

                /* Split current range to numbers w.r.t '-' */
                numbers = IOHprofiler_string_split(ptr, '-');
                j = 0;
                if (numbers) {
                    /* Read the numbers */
                    for (j = 0; *(numbers + j); j++) {
                        assert(j < 2);
                        num[j] = (size_t)strtol(*(numbers + j), NULL, 10);
                        IOHprofiler_free_memory(*(numbers + j));
                    }
                }
                IOHprofiler_free_memory(numbers);

                if (j == 0) {
                    /* Range is in the format - (open ends) */
                    if ((min == 0) || (max == 0)) {
                        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open ends; some ranges ignored", name);
                        /* Cleanup */
                        for (j = i; *(ranges + j); j++)
                            IOHprofiler_free_memory(*(ranges + j));
                        IOHprofiler_free_memory(ranges);
                        if (i_result == 0) {
                            IOHprofiler_free_memory(result);
                            return NULL;
                        }
                        result[i_result] = 0;
                        return result;
                    }
                    num[0] = min;
                    num[1] = max;
                } else if (j == 1) {
                    if (dash - *(ranges + i) == 0) {
                        /* Range is in the format -n */
                        if (min == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open beginning; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = num[0];
                        num[0] = min;
                    } else {
                        /* Range is in the format n- */
                        if (max == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open end; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = max;
                    }
                }
                /* if (j == 2), range is in the format n-m and there is nothing to do */
            }

            /* Make sure the boundaries are taken into account */
            if ((min > 0) && (num[0] < min)) {
                num[0] = min;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be >= %lu", name,
                                    (unsigned long)min);
              }
            if ((max > 0) && (num[1] > max)) {
                num[1] = max;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be <= %lu", name, (unsigned long) max);
            }
            if (num[0] > num[1]) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges not within boundaries; some ranges ignored", name);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            }

            /* Write in result */
            for (j = num[0]; j <= num[1]; j++) {
                if (i_result > max_count - 1)
                    break;
                result[i_result++] = j;
            }

            IOHprofiler_free_memory(*(ranges + i));
            *(ranges + i) = NULL;
        }
    }

    IOHprofiler_free_memory(ranges);

    if (i_result == 0) {
        IOHprofiler_free_memory(result);
        return NULL;
    }

    result[i_result] = 0;
    return result;
}

/**
 * @brief Trims the given string (removes any leading and trailing spaces).
 *
 * If the string contains any leading spaces, the contents are shifted so that if it was dynamically
 * allocated, it can be still freed on the returned pointer.
 */
static char *IOHprofiler_string_trim(char *string) {
    size_t len = 0;
    char *frontp = string;
    char *endp = NULL;

    if (string == NULL) {
        return NULL;
    }
    if (string[0] == '\0') {
        return string;
    }

    len = strlen(string);
    endp = string + len;

    /* Move the front and back pointers to address the first non-whitespace characters from each end. */
    while (isspace((unsigned char)*frontp)) {
        ++frontp;
    }
    if (endp != frontp) {
        while (isspace((unsigned char)*(--endp)) && endp != frontp) {
        }
    }

    if (string + len - 1 != endp)
        *(endp + 1) = '\0';
    else if (frontp != string && endp == frontp)
        *string = '\0';

    /* Shift the string. Note the reuse of endp to mean the front of the string buffer now. */
    endp = string;
    if (frontp != string) {
        while (*frontp) {
            *endp++ = *frontp++;
        }
        *endp = '\0';
    }

    return string;
}
#endif
#line 20 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_utilities.c"

/***********************************************************************************************************/

/**
 * @brief Initializes the logging level to IOHprofiler_INFO.
 */
static IOHprofiler_log_level_type_e IOHprofiler_log_level = IOHprofiler_INFO;

/**
 * @param log_level Denotes the level of information given to the user through the standard output and
 * error streams. Can take on the values:
 * - "error" (only error messages are output),
 * - "warning" (only error and warning messages are output),
 * - "info" (only error, warning and info messages are output) and
 * - "debug" (all messages are output).
 * - "" does not set a new value
 * The default value is info.
 *
 * @return The previous IOHprofiler_log_level value as an immutable string.
 */
const char *IOHprofiler_set_log_level(const char *log_level) {
    IOHprofiler_log_level_type_e previous_log_level = IOHprofiler_log_level;

    if (strcmp(log_level, "error") == 0)
        IOHprofiler_log_level = IOHprofiler_ERROR;
    else if (strcmp(log_level, "warning") == 0)
        IOHprofiler_log_level = IOHprofiler_WARNING;
    else if (strcmp(log_level, "info") == 0)
        IOHprofiler_log_level = IOHprofiler_INFO;
    else if (strcmp(log_level, "debug") == 0)
        IOHprofiler_log_level = IOHprofiler_DEBUG;
    else if (strcmp(log_level, "") == 0) {
        /* Do nothing */
    } else {
        IOHprofiler_warning("IOHprofiler_set_log_level(): unknown level %s", log_level);
    }

    if (previous_log_level == IOHprofiler_ERROR)
        return "error";
    else if (previous_log_level == IOHprofiler_WARNING)
        return "warning";
    else if (previous_log_level == IOHprofiler_INFO)
        return "info";
    else if (previous_log_level == IOHprofiler_DEBUG)
        return "debug";
    else {
        IOHprofiler_error("IOHprofiler_set_log_level(): unknown previous log level");
        return "";
    }
}

/***********************************************************************************************************/

/**
 * @name Methods regarding file, directory and path manipulations
 */
/**@{*/
/**
 * @brief Creates a platform-dependent path from the given strings.
 *
 * @note The last argument must be NULL.
 * @note The first parameter must be able to accommodate path_max_length characters and the length
 * of the joined path must not exceed path_max_length characters.
 * @note Should work cross-platform.
 *
 * Usage examples:
 * - IOHprofiler_join_path(base_path, 100, folder1, folder2, folder3, NULL) creates base_path/folder1/folder2/folder3
 * - IOHprofiler_join_path(base_path, 100, folder1, file_name, NULL) creates base_path/folder1/file_name
 * @param path The base path; it's also where the joined path is stored to.
 * @param path_max_length The maximum length of the path.
 * @param ... Additional strings, must end with NULL
 */
static void IOHprofiler_join_path(char *path, const size_t path_max_length, ...) {
    const size_t path_separator_length = strlen(IOHprofiler_path_separator);
    va_list args;
    char *path_component;
    size_t path_length = strlen(path);

    va_start(args, path_max_length);
    while (NULL != (path_component = va_arg(args, char *))) {
        size_t component_length = strlen(path_component);
        if (path_length + path_separator_length + component_length >= path_max_length) {
            IOHprofiler_error("IOHprofiler_join_path() failed because the ${path} is too short.");
            return; /* never reached */
        }
        /* Both should be safe because of the above check. */
        if (strlen(path) > 0)
            strncat(path, IOHprofiler_path_separator, path_max_length - strlen(path) - 1);
        strncat(path, path_component, path_max_length - strlen(path) - 1);
    }
    va_end(args);
}

/**
 * @brief Checks if the given directory exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a directory and 0 otherwise.
 */
static int IOHprofiler_directory_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Checks if the given file exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a file and 0 otherwise.
 */
static int IOHprofiler_file_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES) && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && !S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Calls the right mkdir() method (depending on the platform).
 *
 * @param path The directory path.
 *
 * @return 0 on successful completion, and -1 on error.
 */
static int IOHprofiler_mkdir(const char *path) {
#if _MSC_VER
    return _mkdir(path);
#elif defined(__MINGW32__) || defined(__MINGW64__)
    return mkdir(path);
#else
    return mkdir(path, S_IRWXU);
#endif
}

/**
 * @brief Creates a directory with full privileges for the user.
 *
 * @note Should work cross-platform.
 *
 * @param path The directory path.
 */
static void IOHprofiler_create_directory(const char *path) {
    char *tmp = NULL;
    char *p;
    size_t len = strlen(path);
    char path_sep = IOHprofiler_path_separator[0];

    /* Nothing to do if the path exists. */
    if (IOHprofiler_directory_exists(path))
        return;

    tmp = IOHprofiler_strdup(path);
    /* Remove possible trailing slash */
    if (tmp[len - 1] == path_sep)
        tmp[len - 1] = 0;
    for (p = tmp + 1; *p; p++) {
        if (*p == path_sep) {
            *p = 0;
            if (!IOHprofiler_directory_exists(tmp)) {
                if (0 != IOHprofiler_mkdir(tmp))
                    IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
            }
            *p = path_sep;
        }
    }
    if (0 != IOHprofiler_mkdir(tmp))
        IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
    IOHprofiler_free_memory(tmp);
    return;
}

/* Commented to silence the compiler (unused function warning) */
#if 0

#endif

/**
 * @brief Creates a unique directory from the given path.
 *
 * If the given path does not yet exit, it is left as is, otherwise it is changed(!) by appending a number
 * to it. If path already exists, path-01 will be tried. If this one exists as well, path-02 will be tried,
 * and so on. If path-99 exists as well, the function throws an error.
 */
static void IOHprofiler_create_unique_directory(char **path) {
    int counter = 1;
    char *new_path;

    /* Create the path if it does not yet exist */
    if (!IOHprofiler_directory_exists(*path)) {
        IOHprofiler_create_directory(*path);
        return;
    }

    while (counter < 999) {
        new_path = IOHprofiler_strdupf("%s-%03d", *path, counter);

        if (!IOHprofiler_directory_exists(new_path)) {
            IOHprofiler_free_memory(*path);
            *path = new_path;
            IOHprofiler_create_directory(*path);
            return;
        } else {
            counter++;
            IOHprofiler_free_memory(new_path);
        }
    }

    IOHprofiler_error("IOHprofiler_create_unique_path(): could not create a unique path with name %s", *path);
    return; /* Never reached */
}

/**
 * The method should work across different platforms/compilers.
 *
 * @path The path to the directory
 *
 * @return 0 on successful completion, and -1 on error.
 */
int IOHprofiler_remove_directory(const char *path) {
#if _MSC_VER
    WIN32_FIND_DATA find_data_file;
    HANDLE find_handle = NULL;
    char *buf;
    int r = -1;
    int r2 = -1;

    buf = IOHprofiler_strdupf("%s\\*.*", path);
    /* Nothing to do if the folder does not exist */
    if ((find_handle = FindFirstFile(buf, &find_data_file)) == INVALID_HANDLE_VALUE) {
        IOHprofiler_free_memory(buf);
        return 0;
    }
    IOHprofiler_free_memory(buf);

    do {
        r = 0;

        /* Skip the names "." and ".." as we don't want to recurse on them */
        if (strcmp(find_data_file.cFileName, ".") != 0 && strcmp(find_data_file.cFileName, "..") != 0) {
            /* Build the new path using the argument path the file/folder name we just found */
            buf = IOHprofiler_strdupf("%s\\%s", path, find_data_file.cFileName);

            if (find_data_file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                /* Buf is a directory, recurse on it */
                r2 = IOHprofiler_remove_directory(buf);
            } else {
                /* Buf is a file, delete it */
                /* Careful, DeleteFile returns 0 if it fails and nonzero otherwise! */
                r2 = -(DeleteFile(buf) == 0);
            }

            IOHprofiler_free_memory(buf);
        }

        r = r2;

    } while (FindNextFile(find_handle, &find_data_file)); /* Find the next file */

    FindClose(find_handle);

    if (!r) {
        /* Path is an empty directory, delete it */
        /* Careful, RemoveDirectory returns 0 if it fails and nonzero otherwise! */
        r = -(RemoveDirectory(path) == 0);
    }

    return r;
#else
    DIR *d = opendir(path);
    int r = -1;
    int r2 = -1;
    char *buf;

    /* Nothing to do if the folder does not exist */
    if (!IOHprofiler_directory_exists(path))
        return 0;

    if (d) {
        struct dirent *p;

        r = 0;

        while (!r && (p = readdir(d))) {
            /* Skip the names "." and ".." as we don't want to recurse on them */
            if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, "..")) {
                continue;
            }

            buf = IOHprofiler_strdupf("%s/%s", path, p->d_name);
            if (buf) {
                if (IOHprofiler_directory_exists(buf)) {
                    /* Buf is a directory, recurse on it */
                    r2 = IOHprofiler_remove_directory(buf);
                } else {
                    /* Buf is a file, delete it */
                    r2 = unlink(buf);
                }
            }
            IOHprofiler_free_memory(buf);

            r = r2;
        }

        closedir(d);
    }

    if (!r) {
        /* Path is an empty directory, delete it */
        r = rmdir(path);
    }

    return r;
#endif
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding memory allocations
 */
/**@{*/
double *IOHprofiler_allocate_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(double);
    return (double *)IOHprofiler_allocate_memory(block_size);
}

int *IOHprofiler_allocate_int_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(int);
    return (int *)IOHprofiler_allocate_memory(block_size);
}
/**
 * @brief Allocates memory for a vector and sets all its elements to value.
 */
static double *IOHprofiler_allocate_vector_with_value(const size_t number_of_elements, double value) {
    const size_t block_size = number_of_elements * sizeof(double);
    double *vector = (double *)IOHprofiler_allocate_memory(block_size);
    size_t i;

    for (i = 0; i < number_of_elements; i++)
        vector[i] = value;

    return vector;
}

/**
 * @brief Safe memory allocation for a vector with size_t elements that either succeeds or triggers a
 * IOHprofiler_error.
 */
static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(size_t);
    return (size_t *)IOHprofiler_allocate_memory(block_size);
}

static char *IOHprofiler_allocate_string(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(char);
    return (char *)IOHprofiler_allocate_memory(block_size);
}

static double *IOHprofiler_duplicate_vector(const double *src, const size_t number_of_elements) {
    size_t i;
    double *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}

static int *IOHprofiler_duplicate_int_vector(const int *src, const size_t number_of_elements) {
    size_t i;
    int *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_int_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding string options
 */
/**@{*/

/**
 * @brief Allocates an option keys structure holding the given number of option keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_allocate(const size_t count, const char **keys) {
    size_t i;
    IOHprofiler_option_keys_t *option_keys;

    if ((count == 0) || (keys == NULL))
        return NULL;

    option_keys = (IOHprofiler_option_keys_t *)IOHprofiler_allocate_memory(sizeof(*option_keys));

    option_keys->keys = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));
    for (i = 0; i < count; i++) {
        assert(keys[i]);
        option_keys->keys[i] = IOHprofiler_strdup(keys[i]);
    }
    option_keys->count = count;

    return option_keys;
}

/**
 * @brief Frees the given option keys structure.
 */
static void IOHprofiler_option_keys_free(IOHprofiler_option_keys_t *option_keys) {
    size_t i;

    if (option_keys) {
        for (i = 0; i < option_keys->count; i++) {
            IOHprofiler_free_memory(option_keys->keys[i]);
        }
        IOHprofiler_free_memory(option_keys->keys);
        IOHprofiler_free_memory(option_keys);
    }
}

/**
 * @brief Returns redundant option keys (the ones present in given_option_keys but not in known_option_keys).
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_get_redundant(const IOHprofiler_option_keys_t *known_option_keys,
                                                                        const IOHprofiler_option_keys_t *given_option_keys) {
    size_t i, j, count = 0;
    int found;
    char **redundant_keys;
    IOHprofiler_option_keys_t *redundant_option_keys;

    assert(known_option_keys != NULL);
    assert(given_option_keys != NULL);

    /* Find the redundant keys */
    redundant_keys = (char **)IOHprofiler_allocate_memory(given_option_keys->count * sizeof(char *));
    for (i = 0; i < given_option_keys->count; i++) {
        found = 0;
        for (j = 0; j < known_option_keys->count; j++) {
            if (strcmp(given_option_keys->keys[i], known_option_keys->keys[j]) == 0) {
                found = 1;
                break;
            }
        }
        if (!found) {
            redundant_keys[count++] = IOHprofiler_strdup(given_option_keys->keys[i]);
        }
    }
    redundant_option_keys = IOHprofiler_option_keys_allocate(count, (const char **)redundant_keys);

    /* Free memory */
    for (i = 0; i < count; i++) {
        IOHprofiler_free_memory(redundant_keys[i]);
    }
    IOHprofiler_free_memory(redundant_keys);

    return redundant_option_keys;
}

/**
 * @brief Adds additional option keys to the given basic option keys (changes the basic keys).
 */
static void IOHprofiler_option_keys_add(IOHprofiler_option_keys_t **basic_option_keys,
                                        const IOHprofiler_option_keys_t *additional_option_keys) {
    size_t i, j;
    size_t new_count;
    char **new_keys;
    IOHprofiler_option_keys_t *new_option_keys;

    assert(*basic_option_keys != NULL);
    if (additional_option_keys == NULL)
        return;

    /* Construct the union of both keys */
    new_count = (*basic_option_keys)->count + additional_option_keys->count;
    new_keys = (char **)IOHprofiler_allocate_memory(new_count * sizeof(char *));
    for (i = 0; i < (*basic_option_keys)->count; i++) {
        new_keys[i] = IOHprofiler_strdup((*basic_option_keys)->keys[i]);
    }
    for (j = 0; j < additional_option_keys->count; j++) {
        new_keys[(*basic_option_keys)->count + j] = IOHprofiler_strdup(additional_option_keys->keys[j]);
    }
    new_option_keys = IOHprofiler_option_keys_allocate(new_count, (const char **)new_keys);

    /* Free the old basic keys */
    IOHprofiler_option_keys_free(*basic_option_keys);
    *basic_option_keys = new_option_keys;
    for (i = 0; i < new_count; i++) {
        IOHprofiler_free_memory(new_keys[i]);
    }
    IOHprofiler_free_memory(new_keys);
}

/**
 * @brief Creates an instance of option keys from the given string of options containing keys and values
 * separated by colons.
 *
 * @note Relies heavily on the "key: value" format and might fail if the number of colons doesn't match the
 * number of keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys(const char *option_string) {
    size_t i;
    char **keys;
    IOHprofiler_option_keys_t *option_keys = NULL;
    char *string_to_parse, *key;

    /* Check for empty string */
    if ((option_string == NULL) || (strlen(option_string) == 0)) {
        return NULL;
    }

    /* Split the options w.r.t ':' */
    keys = IOHprofiler_string_split(option_string, ':');

    if (keys) {
        /* Keys now contain something like this: "values_of_previous_key this_key" except for the first, which
     * contains only the key and the last, which contains only the previous values */
        for (i = 0; *(keys + i); i++) {
            string_to_parse = IOHprofiler_strdup(*(keys + i));

            /* Remove any leading and trailing spaces */
            string_to_parse = IOHprofiler_string_trim(string_to_parse);

            /* Stop if this is the last substring (contains a value and no key) */
            if ((i > 0) && (*(keys + i + 1) == NULL)) {
                IOHprofiler_free_memory(string_to_parse);
                break;
            }

            /* Disregard everything before the last space */
            key = strrchr(string_to_parse, ' ');
            if ((key == NULL) || (i == 0)) {
                /* No spaces left (or this is the first key), everything is the key */
                key = string_to_parse;
            } else {
                /* Move to the start of the key (one char after the space) */
                key++;
            }

            /* Put the key in keys */
            IOHprofiler_free_memory(*(keys + i));
            *(keys + i) = IOHprofiler_strdup(key);
            IOHprofiler_free_memory(string_to_parse);
        }

        option_keys = IOHprofiler_option_keys_allocate(i, (const char **)keys);

        /* Free the keys */
        for (i = 0; *(keys + i); i++) {
            IOHprofiler_free_memory(*(keys + i));
        }
        IOHprofiler_free_memory(keys);
    }

    return option_keys;
}

/**
 * @brief Creates and returns a string containing the info_string and all keys from option_keys.
 *
 * Can be used to output information about the given option_keys.
 */
static char *IOHprofiler_option_keys_get_output_string(const IOHprofiler_option_keys_t *option_keys,
                                                       const char *info_string) {
    size_t i;
    char *string = NULL, *new_string;

    if ((option_keys != NULL) && (option_keys->count > 0)) {
        string = IOHprofiler_strdup(info_string);
        for (i = 0; i < option_keys->count; i++) {
            new_string = IOHprofiler_strdupf("%s %s\n", string, option_keys->keys[i]);
            IOHprofiler_free_memory(string);
            string = new_string;
        }
    }

    return string;
}

/**
 * @brief Parses options in the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - value needs to be a single string (no spaces allowed)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read(const char *options, const char *name, const char *format, void *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing whitespaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    return sscanf(&options[i2], format, pointer);
}

/**
 * @brief Reads an integer from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be an integer
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_int(const char *options, const char *name, int *pointer) {
    return IOHprofiler_options_read(options, name, " %i", pointer);
}

/**
 * @brief Reads a size_t from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a size_t
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_size_t(const char *options, const char *name, size_t *pointer) {
    return IOHprofiler_options_read(options, name, "%lu", pointer);
}

/**
 * @brief Reads a double value from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a double
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_double(const char *options, const char *name, double *pointer) {
    return IOHprofiler_options_read(options, name, "%lf", pointer);
}

/**
 * @brief Reads a string from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a string - either a single word or multiple words
 * in double quotes
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_string(const char *options, const char *name, char *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    if (options[i2] == '\"') {
        /* The value starts with a quote: read everything between two quotes into a string */
        return sscanf(&options[i2], "\"%[^\"]\"", pointer);
    } else
        return sscanf(&options[i2], "%s", pointer);
}

/**
 * @brief Reads (possibly delimited) values from options using the form "name1: value1,value2,value3 name2: value4",
 * i.e. reads all characters from the corresponding name up to the next whitespace or end of string.
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_values(const char *options, const char *name, char *pointer) {
    long i1, i2;
    int i;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    i = 0;
    while (!isspace((unsigned char)options[i2 + i]) && (options[i2 + i] != '\0')) {
        pointer[i] = options[i2 + i];
        i++;
    }
    pointer[i] = '\0';
    return i;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods implementing functions on double values not contained in C89 standard
 */
/**@{*/

/**
 * @brief Rounds the given double to the nearest integer.
 */
static double IOHprofiler_double_round(const double number) {
    return floor(number + 0.5);
}

/**
 * @brief Returns the maximum of a and b.
 */
static double IOHprofiler_double_max(const double a, const double b) {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Returns the minimum of a and b.
 */
static double IOHprofiler_double_min(const double a, const double b) {
    if (a <= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Performs a "safer" double to size_t conversion.
 */
static size_t IOHprofiler_double_to_size_t(const double number) {
    return (size_t)IOHprofiler_double_round(number);
}

/**
 * @brief  Returns 1 if |a - b| < precision and 0 otherwise.
 */
static int IOHprofiler_double_almost_equal(const double a, const double b, const double precision) {
    return (fabs(a - b) < precision);
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods handling NAN and INFINITY
 */
/**@{*/

/**
 * @brief Returns 1 if x is NAN and 0 otherwise.
 */
static int IOHprofiler_is_nan(const int x) {
    /*return (isnan(x) || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
*/
    return (0 || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
}

/**
 * @brief Returns 1 if the input vector of dimension dim contains any NAN values and 0 otherwise.
 */
static int IOHprofiler_vector_contains_nan(const int *x, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        if (IOHprofiler_is_nan(x[i]))
            return 1;
    }
    return 0;
}

/**
 * @brief Sets all dim values of y to NAN.
 */
static void IOHprofiler_vector_set_to_nan(double *y, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        y[i] = NAN;
    }
}

/**
 * @brief Returns 1 if x is INFINITY and 0 otherwise.
 */
static int IOHprofiler_is_inf(const int x) {
    if (IOHprofiler_is_nan(x))
        return 0;
    /*return (isinf(x) || (x <= -INFINITY) || (x >= INFINITY));*/
    return (0 || (x <= -INFINITY) || (x >= INFINITY));
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Miscellaneous methods
 */
/**@{*/

/**
 * @brief Returns the current time as a string.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_current_time_get_string(void) {
    time_t timer;
    char *time_string = IOHprofiler_allocate_string(30);
    struct tm *tm_info;
    time(&timer);
    tm_info = localtime(&timer);
    assert(tm_info != NULL);
    strftime(time_string, 30, "%d.%m.%y %H:%M:%S", tm_info);
    return time_string;
}

/**
 * @brief Returns the number of positive numbers pointed to by numbers (the count stops when the first
 * 0 is encountered of max_count numbers have been read).
 *
 * If there are more than max_count numbers, a IOHprofiler_error is raised. The name argument is used
 * only to provide more informative output in case of any problems.
 */
static size_t IOHprofiler_count_numbers(const size_t *numbers, const size_t max_count, const char *name) {
    size_t count = 0;
    while ((count < max_count) && (numbers[count] != 0)) {
        count++;
    }
    if (count == max_count) {
        IOHprofiler_error("IOHprofiler_count_numbers(): over %lu numbers in %s", (unsigned long)max_count, name);
        return 0; /* Never reached*/
    }

    return count;
}

/**@}*/

/***********************************************************************************************************/
#endif
#line 13 "code-experiments/src/profiler/../suite/PBO/../../transform/../profiler/IOHprofiler_problem.c"

/**
 * Evaluates the problem function, increases the number of evaluations and updates the best observed value
 * and the best observed evaluation number.
 *
 * @note Both x and y must point to correctly sized allocated memory regions.
 *
 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 * @param y The objective vector that is the result of the evaluation (in single-objective problems only the
 * first vector item is being set). Currently multi-objective is not supported.
 * @param number_of_parameters The number of parameters need to be logged. Set as zero by default.
 * @param parameters The list of parameters. Set as NULL by default.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {

    assert(problem != NULL);
    assert(problem->evaluate_function != NULL);
    problem->evaluate_function(problem, x, y);
    problem->evaluations++; /* each derived class has its own counter, only the most outer will be visible */

    /* A little bit of bookkeeping */
    if (y[0] > problem->best_observed_fvalue[0]) {
        problem->best_observed_fvalue[0] = y[0];
        problem->best_observed_evaluation[0] = problem->evaluations;
    }
}

/**
 * Evaluates and logs the given solution (as the IOHprofiler_evaluate_function), but does not return the evaluated
 * value.
 *
 * @note None of the observers implements this function yet!
 * @note x must point to a correctly sized allocated memory region.

 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    assert(problem != NULL);
    if (problem->recommend_solution == NULL) {
        IOHprofiler_error("IOHprofiler_recommend_solutions(): No recommend solution function implemented for problem %s",
                          problem->problem_id);
    }
    problem->recommend_solution(problem, x);
}

/**
 * @brief Allocates a new IOHprofiler_problem_t for the given number of variables and number of objectives.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate(const size_t number_of_variables,
                                                           const size_t number_of_objectives) {
    IOHprofiler_problem_t *problem;
    problem = (IOHprofiler_problem_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    /* Initialize fields to sane/safe defaults */
    problem->initial_solution = NULL;
    problem->evaluate_function = NULL;
    problem->recommend_solution = NULL;
    problem->problem_free_function = NULL;
    problem->dimension = number_of_variables;
    problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = number_of_objectives;
    problem->number_of_parameters = 0;
    problem->parameters = NULL;
    problem->smallest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->largest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_parameter = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_value = IOHprofiler_allocate_vector(number_of_objectives);
    problem->raw_fitness = IOHprofiler_allocate_vector(number_of_objectives);
    if (number_of_objectives > 1)
        problem->nadir_value = IOHprofiler_allocate_vector(number_of_objectives);
    else
        problem->nadir_value = NULL;
    problem->problem_name = NULL;
    problem->problem_id = NULL;
    problem->problem_type = NULL;
    problem->evaluations = 0;
    problem->final_target_delta[0] = 1e-8; /* in case to be modified by the benchmark */
    problem->best_observed_fvalue[0] = DBL_MIN_EXP;
    problem->best_observed_evaluation[0] = 0;
    problem->suite = NULL; /* To be initialized in the IOHprofiler_suite_get_problem_from_indices() function */
    problem->suite_dep_index = 0;
    problem->suite_dep_function = 0;
    problem->suite_dep_instance = 0;
    problem->data = NULL;
    return problem;
}

/**
 * @brief Creates a duplicate of the 'other' problem for all fields except for data, which points to NULL.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_duplicate(const IOHprofiler_problem_t *other) {
    size_t i;
    IOHprofiler_problem_t *problem;
    problem = IOHprofiler_problem_allocate(other->number_of_variables, other->number_of_objectives);

    problem->dimension = other->dimension;
    problem->initial_solution = other->initial_solution;
    problem->evaluate_function = other->evaluate_function;
    problem->recommend_solution = other->recommend_solution;
    problem->problem_free_function = other->problem_free_function;

    for (i = 0; i < problem->number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = other->smallest_values_of_interest[i];
        problem->largest_values_of_interest[i] = other->largest_values_of_interest[i];
        if (other->best_parameter)
            problem->best_parameter[i] = other->best_parameter[i];
    }

    if (other->best_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->best_value[i] = other->best_value[i];
        }

    if (other->nadir_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->nadir_value[i] = other->nadir_value[i];
        }

    if (other->raw_fitness)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->raw_fitness[i] = other->raw_fitness[i];
        }

    problem->number_of_parameters = other->number_of_parameters;
    for (i = 0; i < problem->number_of_parameters; ++i) {
        problem->parameters[i] = other->parameters[i];
    }

    problem->problem_name = IOHprofiler_strdup(other->problem_name);
    problem->problem_id = IOHprofiler_strdup(other->problem_id);
    problem->problem_type = IOHprofiler_strdup(other->problem_type);

    problem->evaluations = other->evaluations;
    problem->final_target_delta[0] = other->final_target_delta[0];
    problem->best_observed_fvalue[0] = other->best_observed_fvalue[0];
    problem->best_observed_evaluation[0] = other->best_observed_evaluation[0];

    problem->suite = other->suite;
    problem->suite_dep_index = other->suite_dep_index;
    problem->suite_dep_function = other->suite_dep_function;
    problem->suite_dep_instance = other->suite_dep_instance;

    problem->data = NULL;

    return problem;
}

/**
 * @brief Allocates a problem using scalar values for smallest_value_of_interest, largest_value_of_interest
 * and best_parameter.
 * Note that the number of objectives is set as 1 by default.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate_from_scalars(const char *problem_name,
                                                                        IOHprofiler_evaluate_function_t evaluate_function,
                                                                        IOHprofiler_problem_free_function_t problem_free_function,
                                                                        const size_t number_of_variables,
                                                                        const int smallest_value_of_interest,
                                                                        const int largest_value_of_interest,
                                                                        const int best_parameter) {
    size_t i;

    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate(number_of_variables, 1);

    problem->problem_name = IOHprofiler_strdup(problem_name);
    /*problem->dimension = number_of_variables;
    */problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = 1;
    problem->evaluate_function = evaluate_function;
    problem->problem_free_function = problem_free_function;

    for (i = 0; i < number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = smallest_value_of_interest;
        problem->largest_values_of_interest[i] = largest_value_of_interest;
        problem->best_parameter[i] = best_parameter;
    }
    return problem;
}

void IOHprofiler_problem_free(IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (problem->problem_free_function != NULL) {
        problem->problem_free_function(problem);
    } else {
        /* Best guess at freeing all relevant structures */
        if (problem->smallest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->smallest_values_of_interest);
        if (problem->largest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->largest_values_of_interest);
        if (problem->best_parameter != NULL)
            IOHprofiler_free_memory(problem->best_parameter);
        if (problem->best_value != NULL)
            IOHprofiler_free_memory(problem->best_value);
        if (problem->raw_fitness != NULL)
            IOHprofiler_free_memory(problem->raw_fitness);
        if (problem->nadir_value != NULL)
            IOHprofiler_free_memory(problem->nadir_value);
        if (problem->problem_name != NULL)
            IOHprofiler_free_memory(problem->problem_name);
        if (problem->problem_id != NULL)
            IOHprofiler_free_memory(problem->problem_id);
        if (problem->problem_type != NULL)
            IOHprofiler_free_memory(problem->problem_type);
        if (problem->data != NULL)
            IOHprofiler_free_memory(problem->data);
        if (problem->parameters != NULL)
            IOHprofiler_free_memory(problem->parameters);
        problem->smallest_values_of_interest = NULL;
        problem->largest_values_of_interest = NULL;
        problem->best_parameter = NULL;
        problem->best_value = NULL;
        problem->raw_fitness = NULL;
        problem->nadir_value = NULL;
        problem->suite = NULL;
        problem->data = NULL;
        problem->parameters = NULL;
        IOHprofiler_free_memory(problem);
    }
}

/**
 * @brief Checks whether the given string is in the right format to be a problem_id.
 *
 * No non-alphanumeric characters besides '-', '_' and '.' are allowed.
 */
static int IOHprofiler_problem_id_is_fine(const char *id, ...) {
    va_list args;
    const int reject = 0;
    const int accept = 1;
    const char *cp;
    char *s;
    int result = accept;

    va_start(args, id);
    s = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    for (cp = s; *cp != '\0'; ++cp) {
        if (('A' <= *cp) && (*cp <= 'Z'))
            continue;
        if (('a' <= *cp) && (*cp <= 'z'))
            continue;
        if ((*cp == '_') || (*cp == '-'))
            continue;
        if (('0' <= *cp) && (*cp <= '9'))
            continue;
        result = reject;
    }
    IOHprofiler_free_memory(s);
    return result;
}

/**
 * @brief Sets the problem_parameters.
 *
 */
void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters) {
    size_t i;
    if (number_of_parameters != 0) {
        problem->number_of_parameters = number_of_parameters;
        if (problem->parameters != NULL) {
            IOHprofiler_free_memory(problem->parameters);
        }
        problem->parameters = IOHprofiler_allocate_vector(number_of_parameters);
        for (i = 0; i < problem->number_of_parameters; ++i) {
            problem->parameters[i] = parameters[i];
        }
    }
}

/**
 * @brief Sets the problem_id using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation and verifies that the problem_id is in the correct format.
 */
static void IOHprofiler_problem_set_id(IOHprofiler_problem_t *problem, const char *id, ...) {
    va_list args;

    va_start(args, id);
    if (problem->problem_id != NULL)
        IOHprofiler_free_memory(problem->problem_id);
    problem->problem_id = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    if (!IOHprofiler_problem_id_is_fine(problem->problem_id)) {
        IOHprofiler_error("Problem id should only contain standard chars, not like '%s'", problem->problem_id);
    }
}

/**
 * @brief Sets the problem_name using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_name(IOHprofiler_problem_t *problem, const char *name, ...) {
    va_list args;

    va_start(args, name);
    if (problem->problem_name != NULL)
        IOHprofiler_free_memory(problem->problem_name);
    problem->problem_name = IOHprofiler_vstrdupf(name, args);
    va_end(args);
}

/**
 * @brief Sets the problem_type using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_type(IOHprofiler_problem_t *problem, const char *type, ...) {
    va_list args;

    va_start(args, type);
    if (problem->problem_type != NULL)
        IOHprofiler_free_memory(problem->problem_type);
    problem->problem_type = IOHprofiler_vstrdupf(type, args);
    va_end(args);
}

size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->evaluations;
}

/**
 * @brief Returns 1 if the best parameter is not (close to) zero and 0 otherwise.
 */
static int IOHprofiler_problem_best_parameter_not_zero(const IOHprofiler_problem_t *problem) {
    size_t i = 0;
    int best_is_zero = 1;

    if (IOHprofiler_vector_contains_nan(problem->best_parameter, problem->number_of_variables))
        return 1;

    while (i < problem->number_of_variables && best_is_zero) {
        best_is_zero = IOHprofiler_double_almost_equal(problem->best_parameter[i], 0, 1e-9);
        i++;
    }

    return !best_is_zero;
}

/**
 * @note Can be used to prevent unnecessary burning of CPU time.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (IOHprofiler_problem_get_number_of_objectives(problem) != 1 ||
        IOHprofiler_problem_get_evaluations(problem) < 1)
        return 0;
    if (problem->best_value == NULL)
        return 0;
    return problem->best_observed_fvalue[0] >= problem->best_value[0] - problem->final_target_delta[0] ? 1 : 0;
}

/**
 * @note Tentative...
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->best_observed_fvalue[0];
}

/**
 * @note This function breaks the black-box property: the returned  value is not
 * meant to be used by the optimization algorithm.
 */
double IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->best_value != NULL);
    assert(problem->final_target_delta != NULL);
    return problem->best_value[0] + problem->final_target_delta[0];
}

/**
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_name != NULL);
    return problem->problem_name;
}

/**
 * The ID is guaranteed to contain only characters in the set [a-z0-9_-]. It should therefore be safe to use
 * it to construct filenames or other identifiers.
 *
 * Each problem ID should be unique within each benchmark suite.
 *
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_id != NULL);
    return problem->problem_id;
}

const char *IOHprofiler_problem_get_type(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_type != NULL);
    return problem->problem_type;
}

size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->dimension > 0);
    return problem->dimension;
}

size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->number_of_objectives > 0);
    return problem->number_of_objectives;
}
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->smallest_values_of_interest != NULL);
    return problem->smallest_values_of_interest;
}

const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->largest_values_of_interest != NULL);
    return problem->largest_values_of_interest;
}

/**
 * If a special method for setting an initial solution to the problem does not exist, the center of the
 * problem's region of interest is the initial solution.
 * @param problem The given IOHprofiler problem.
 * @param initial_solution The pointer to the initial solution being set by this method.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution) {
    assert(problem != NULL);
    if (problem->initial_solution != NULL) {
        problem->initial_solution(problem, initial_solution);
    } else {
        size_t i;
        assert(problem->smallest_values_of_interest != NULL);
        assert(problem->largest_values_of_interest != NULL);
        for (i = 0; i < problem->number_of_variables; ++i)
            initial_solution[i] = (int)(problem->smallest_values_of_interest[i] + 0.5 * (problem->largest_values_of_interest[i] - problem->smallest_values_of_interest[i]));
    }
}

static IOHprofiler_suite_t *IOHprofiler_problem_get_suite(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite;
}

static void IOHprofiler_problem_set_suite(IOHprofiler_problem_t *problem, IOHprofiler_suite_t *suite) {
    assert(problem != NULL);
    problem->suite = suite;
}

size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite_dep_index;
}

static size_t IOHprofiler_problem_get_suite_dep_function(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_function > 0);
    return problem->suite_dep_function;
}

static size_t IOHprofiler_problem_get_suite_dep_instance(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_instance > 0);
    return problem->suite_dep_instance;
}

/**
 * @brief Returns the data of the transformed problem.
 */
static void *IOHprofiler_problem_transformed_get_data(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->data != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->data;
}

/**
 * @brief Returns the inner problem of the transformed problem.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_get_inner_problem(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the inner problem.
 */
static void IOHprofiler_problem_transformed_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_evaluate_function(data->inner_problem, x, y);
}

/**
 * @brief Calls the IOHprofiler_recommend_solution function on the inner problem.
 */
static void IOHprofiler_problem_transformed_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_recommend_solution(data->inner_problem, x);
}

/**
 * @brief Frees only the data of the transformed problem leaving the inner problem intact.
 *
 * @note If there is no other pointer to the inner problem, access to it will be lost.
 */
static void IOHprofiler_problem_transformed_free_data(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;

    if (data->data != NULL) {
        if (data->data_free_function != NULL) {
            data->data_free_function(data->data);
            data->data_free_function = NULL;
        }
        IOHprofiler_free_memory(data->data);
        data->data = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}

/**
 * @brief Frees the transformed problem.
 */
static void IOHprofiler_problem_transformed_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);
    if (data->inner_problem != NULL) {
        IOHprofiler_problem_free(data->inner_problem);
        data->inner_problem = NULL;
    }
    IOHprofiler_problem_transformed_free_data(problem);
}

/**
 * @brief Allocates a transformed problem that wraps the inner_problem.
 *
 * By default all methods will dispatch to the inner_problem. A prefix is prepended to the problem name
 * in order to reflect the transformation somewhere.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_allocate(IOHprofiler_problem_t *inner_problem,
                                                                       void *user_data,
                                                                       IOHprofiler_data_free_function_t data_free_function,
                                                                       const char *name_prefix) {
    IOHprofiler_problem_transformed_data_t *problem;
    IOHprofiler_problem_t *inner_copy;
    char *old_name = IOHprofiler_strdup(inner_problem->problem_name);

    problem = (IOHprofiler_problem_transformed_data_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    problem->inner_problem = inner_problem;
    problem->data = user_data;
    problem->data_free_function = data_free_function;

    inner_copy = IOHprofiler_problem_duplicate(inner_problem);
    inner_copy->evaluate_function = IOHprofiler_problem_transformed_evaluate_function;
    inner_copy->recommend_solution = IOHprofiler_problem_transformed_recommend_solution;
    inner_copy->problem_free_function = IOHprofiler_problem_transformed_free;
    inner_copy->data = problem;

    IOHprofiler_problem_set_name(inner_copy, "%s(%s)", name_prefix, old_name);
    IOHprofiler_free_memory(old_name);

    return inner_copy;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the underlying problems.
 */
static void IOHprofiler_problem_stacked_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_stacked_data_t *data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    assert(
        IOHprofiler_problem_get_number_of_objectives(problem) == IOHprofiler_problem_get_number_of_objectives(data->problem1) + IOHprofiler_problem_get_number_of_objectives(data->problem2));

    IOHprofiler_evaluate_function(data->problem1, x, &y[0]);
    IOHprofiler_evaluate_function(data->problem2, x, &y[IOHprofiler_problem_get_number_of_objectives(data->problem1)]);
}

/**
 * @brief Frees the stacked problem.
 */
static void IOHprofiler_problem_stacked_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_stacked_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    if (data->problem1 != NULL) {
        IOHprofiler_problem_free(data->problem1);
        data->problem1 = NULL;
    }
    if (data->problem2 != NULL) {
        IOHprofiler_problem_free(data->problem2);
        data->problem2 = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}
#endif
#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_shift.c"

/**
 * @brief Data type for transform_obj_shift.
 */
typedef struct {
  double offset;
} transform_obj_shift_data_t;

/**
 * @brief Evaluates the transformation.
 */
static void transform_obj_shift_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  transform_obj_shift_data_t *data;
  size_t i;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }

  data = (transform_obj_shift_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  IOHprofiler_evaluate_function(IOHprofiler_problem_transformed_get_inner_problem(problem), x, y);
  
  for (i = 0; i < problem->number_of_objectives; i++) {
      y[i] += data->offset;
      problem->raw_fitness[i] = IOHprofiler_problem_transformed_get_inner_problem(problem)->raw_fitness[i];
  }

  assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_obj_shift(IOHprofiler_problem_t *inner_problem, const double offset) {
  IOHprofiler_problem_t *problem;
  transform_obj_shift_data_t *data;
  size_t i;
  data = (transform_obj_shift_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = offset;

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, NULL, "transform_obj_shift");
  problem->evaluate_function = transform_obj_shift_evaluate;
  for (i = 0; i < problem->number_of_objectives; i++) {
      problem->best_value[0] += offset;
  }
  return problem;
}
#endif
#line 26 "code-experiments/src/profiler/../suite/PBO/f_binary.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_xor.c"
/**
 * @file transform_vars_xor.c
 * @brief Implementation of xor all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_XOR
#define TRANSFORM_VARS_XOR

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_xor.c"
#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_xor.c"

/**
 * @brief Data type for transform_vars_xor.
 */
typedef struct {
  int *offset;
  int *xor_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_xor_data_t;

/**
 * @brief Evaluates the transformation.
 */
static int xor_compute(const int x1, const int x2){
    return (int) x1 != x2;
}

static void transform_vars_xor_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_xor_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }

  data = (transform_vars_xor_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->xor_x[i] = xor_compute(x[i],data->offset[i]);
  }
  inner_problem->number_of_variables = problem->number_of_variables;
  IOHprofiler_evaluate_function(inner_problem, data->xor_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_xor_free(void *thing) {
  transform_vars_xor_data_t *data = (transform_vars_xor_data_t *) thing;
  IOHprofiler_free_memory(data->xor_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_xor(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int xor_bounds) {
    
  transform_vars_xor_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  if (xor_bounds)
    IOHprofiler_error("xor_bounds not implemented.");

  data = (transform_vars_xor_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, inner_problem->number_of_variables);
  data->xor_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_xor_free, "transform_vars_xor");
  problem->evaluate_function = transform_vars_xor_evaluate;
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = xor_compute(problem->best_parameter[i],data->offset[i]);
  }
  return problem;
}
#endif
#line 27 "code-experiments/src/profiler/../suite/PBO/f_binary.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_sigma.c"
/**
 * @file transform_vars_sigma.c
 * @brief Implementation of sigmad all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_SIGMA
#define TRANSFORM_VARS_SIGMA

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_sigma.c"
#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_sigma.c"

/**
 * @brief Data type for transform_vars_sigma.
 */
typedef struct {
  int *offset;
  int *sigma_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_sigma_data_t;

/**
 * @brief Evaluates the transformation.
 */
static int sigma_compute(const int *x, const int pos){
  return x[pos];
}

static void transform_vars_sigma_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_sigma_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }
  data = (transform_vars_sigma_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->sigma_x[i] = sigma_compute(x,data->offset[i]);
  }

  IOHprofiler_evaluate_function(inner_problem, data->sigma_x, y);
  problem->raw_fitness[0] = y[0];
  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_sigma_free(void *thing) {
  transform_vars_sigma_data_t *data = (transform_vars_sigma_data_t *) thing;
  IOHprofiler_free_memory(data->sigma_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_sigma(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int sigma_bounds) {
    
  transform_vars_sigma_data_t *data;
  IOHprofiler_problem_t *problem;
  int * temp_best;
  size_t i;
  if (sigma_bounds)
    IOHprofiler_error("sigma_bounds not implemented.");

  data = (transform_vars_sigma_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, inner_problem->number_of_variables);
  data->sigma_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);
  temp_best = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_sigma_free, "transform_vars_sigma");
  problem->evaluate_function = transform_vars_sigma_evaluate;
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      temp_best[i] = sigma_compute(problem->best_parameter,data->offset[i]);
  }
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = temp_best[i];
  }
  IOHprofiler_free_memory(temp_best);
  return problem;
}
#endif
#line 28 "code-experiments/src/profiler/../suite/PBO/f_binary.c"


/**
 * @brief Implements the binary function without connections to any IOHprofiler structures.
 */
static double f_binary_raw(const int *x, const size_t number_of_variables) {
    int i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;

    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        result += (double)(pow(2, i) * x[i]);
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_binary_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_binary_raw(x, problem->number_of_variables);
    problem->raw_fitness[0] = y[0];
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic binary problem.
 */
static IOHprofiler_problem_t *f_binary_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("binary function",
                                                                               f_binary_evaluate, NULL, number_of_variables, 0, 1, 1);
    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "binary", number_of_variables);

    /* Compute best solution */
    f_binary_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler binary problem.
 */
static IOHprofiler_problem_t *f_binary_IOHprofiler_problem_allocate(const size_t function,
                                                                    const size_t dimension,
                                                                    const size_t instance,
                                                                    const long rseed,
                                                                    const char *problem_id_template,
                                                                    const char *problem_name_template) {
    IOHprofiler_problem_t *problem = NULL;

    assert(dimension < 200);
    problem = f_binary_allocate(dimension);

    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    return problem;
}
#line 13 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_jump.c"
/**
 * @Jump function
 */

/**
 * @file f_jump.c
 * @brief Implementation of the jump function and problem.
 * this is for jump function
 */

#include <assert.h>
#include <math.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 18 "code-experiments/src/profiler/../suite/PBO/f_jump.c"
#endif

#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 23 "code-experiments/src/profiler/../suite/PBO/f_jump.c"
#endif
#line 25 "code-experiments/src/profiler/../suite/PBO/f_jump.c"
#line 26 "code-experiments/src/profiler/../suite/PBO/f_jump.c"
#line 27 "code-experiments/src/profiler/../suite/PBO/f_jump.c"
#line 28 "code-experiments/src/profiler/../suite/PBO/f_jump.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_scale.c"
/**
 * @file transform_obj_scale.c
 * @brief Implementation of scaleing the objective value by the given offset.
 */
#ifndef TRANSFORM_OBJ_SCALE
#define TRANSFORM_OBJ_SCALE

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_scale.c"
#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_scale.c"

/**
 * @brief Data type for transform_obj_scale.
 */
typedef struct {
  double offset;
} transform_obj_scale_data_t;

/**
 * @brief Evaluates the transformation.
 */
static void transform_obj_scale_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  transform_obj_scale_data_t *data;
  size_t i;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }
  data = (transform_obj_scale_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  IOHprofiler_evaluate_function(IOHprofiler_problem_transformed_get_inner_problem(problem), x, y);
  
  for (i = 0; i < problem->number_of_objectives; i++) {
      y[i] = y[i] * data->offset;
      problem->raw_fitness[i] = IOHprofiler_problem_transformed_get_inner_problem(problem)->raw_fitness[i];
  }
  assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_obj_scale(IOHprofiler_problem_t *inner_problem, const double offset) {
  IOHprofiler_problem_t *problem;
  transform_obj_scale_data_t *data;
  size_t i;
  data = (transform_obj_scale_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = offset;

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, NULL, "transform_obj_scale");
  problem->evaluate_function = transform_obj_scale_evaluate;
  for (i = 0; i < problem->number_of_objectives; i++) {
      problem->best_value[0] = problem->best_value[0] * offset;
  }
  return problem;
}
#endif
#line 29 "code-experiments/src/profiler/../suite/PBO/f_jump.c"

/**
 * @brief Implements the linear slope function without connections to any IOHprofiler structures.
 */
static double f_jump_raw(const int *x, const size_t number_of_variables) {
    static const size_t l = 1;
    size_t i;
    double result = 0.0;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;

    for (i = 0; i < number_of_variables; ++i) {
        result += (double)x[i];
    }

    if ((result >= number_of_variables - l || result <= l) && result != number_of_variables) {
        result = 0.0;
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_jump_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_jump_raw(x, problem->number_of_variables);
    problem->raw_fitness[0] = y[0];
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic jump problem.
 */
static IOHprofiler_problem_t *f_jump_allocate(const size_t number_of_variables) {
    /* best_parameter will be overwritten below */
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("jump function",
                                                                               f_jump_evaluate, NULL, number_of_variables, 0, 1, 1);
    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "jump", number_of_variables);

    /* Compute best solution */
    f_jump_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler jump problem.
 */
static IOHprofiler_problem_t *f_jump_IOHprofiler_problem_allocate(const size_t function,
                                                                  const size_t dimension,
                                                                  const size_t instance,
                                                                  const long rseed,
                                                                  const char *problem_id_template,
                                                                  const char *problem_name_template) {
  
  int *z, *sigma;
  int temp,t;
  size_t i;
  double a;
  double b;
  double *xins;
  IOHprofiler_problem_t *problem;
  z = IOHprofiler_allocate_int_vector(dimension);
  sigma = IOHprofiler_allocate_int_vector(dimension);
  xins = IOHprofiler_allocate_vector(dimension);
  problem = f_jump_allocate(dimension);

  if(instance == 1){
    for(i = 0; i < dimension; i++)
      z[i] = 0;
    a = 0.0;
    problem = transform_vars_xor(problem,z,0);
    problem = transform_obj_shift(problem,a);
  }
  else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
 
  IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
  IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
  IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

  IOHprofiler_free_memory(z);
  IOHprofiler_free_memory(sigma);
  IOHprofiler_free_memory(xins);
  return problem;
}
#line 14 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_leading_ones.c"
/**
 * @Leading Ones
 */

/**
 * @file f_leading_ones.c
 * @brief Implementation of the leading ones function and problem.
 */

#include <assert.h>
#include <math.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_leading_ones.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_leading_ones.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_leading_ones.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_leading_ones.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_leading_ones.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_leading_ones.c"
#line 26 "code-experiments/src/profiler/../suite/PBO/f_leading_ones.c"


/**
 * @brief Implements the leading ones function without connections to any IOHprofiler structures.
 */
static double f_leading_ones_raw(const int *x, const size_t number_of_variables) {
    size_t i;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;

    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        if (x[i] == 1.0) {
            result = (double)(i + 1);
        } else {
            break;
        }
    }
    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_leading_ones_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_leading_ones_raw(x, problem->number_of_variables);
    problem->raw_fitness[0] = y[0];
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic leading ones problem.
 */
static IOHprofiler_problem_t *f_leading_ones_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("Leading Ones function",
                                                                               f_leading_ones_evaluate, NULL, number_of_variables, 0, 1, 1);
    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "leading_ones", number_of_variables);

    /* Compute best solution */
    f_leading_ones_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler leading ones problem.
 */
static IOHprofiler_problem_t *f_leading_ones_IOHprofiler_problem_allocate(const size_t function,
                                                                          const size_t dimension,
                                                                          const size_t instance,
                                                                          const long rseed,
                                                                          const char *problem_id_template,
                                                                          const char *problem_name_template) {
  int *z, *sigma;
  int temp,t;
  size_t i;
  double a;
  double b;
  double *xins;
  IOHprofiler_problem_t *problem;
  z = IOHprofiler_allocate_int_vector(dimension);
  sigma = IOHprofiler_allocate_int_vector(dimension);
  xins = IOHprofiler_allocate_vector(dimension);
  problem = f_leading_ones_allocate(dimension);
  
  if(instance == 1){
    for(i = 0; i < dimension; i++)
        z[i] = 0;
    a = 0.0;
    problem = transform_vars_xor(problem,z,0);
    problem = transform_obj_shift(problem,a);
  }
  else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
  
  IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
  IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
  IOHprofiler_problem_set_type(problem, "pseudo-Boolean");
  
  IOHprofiler_free_memory(z);
  IOHprofiler_free_memory(sigma);
  IOHprofiler_free_memory(xins);
  return problem;
}
#line 15 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_linear.c"
/**
 * @Linear functions
 */

/**
 * @file f_liner.c
 * @brief Implementation of the linear function and problem.
 */

#include <assert.h>
#include <math.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 17 "code-experiments/src/profiler/../suite/PBO/f_linear.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 21 "code-experiments/src/profiler/../suite/PBO/f_linear.c"
#endif

#line 24 "code-experiments/src/profiler/../suite/PBO/f_linear.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_linear.c"
#line 26 "code-experiments/src/profiler/../suite/PBO/f_linear.c"
#line 27 "code-experiments/src/profiler/../suite/PBO/f_linear.c"
#line 28 "code-experiments/src/profiler/../suite/PBO/f_linear.c"

/**
 * @brief Implements the linear function without connections to any IOHprofiler structures.
 */

long f_linear_ins;

static double f_linear_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;
    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;

    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        result += (double)x[i] * (double)(i+1);
    }
    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_linear_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_linear_raw(x, problem->number_of_variables);
    problem->raw_fitness[0] = y[0];
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic Linear problem.
 */
static IOHprofiler_problem_t *f_linear_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("Linear function",
                                                                               f_linear_evaluate, NULL, number_of_variables, 0, 1, 1);
    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "linear", number_of_variables);

    /* Compute best solution */
    f_linear_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler linearproblem.
 */
static IOHprofiler_problem_t *f_linear_IOHprofiler_problem_allocate(const size_t function,
                                                                    const size_t dimension,
                                                                    const size_t instance,
                                                                    const long rseed,
                                                                    const char *problem_id_template,
                                                                    const char *problem_name_template) {

  int *z, *sigma;
  int temp,t;
  size_t i;
  double a;
  double b;
  double *xins;
  IOHprofiler_problem_t *problem;
  z = IOHprofiler_allocate_int_vector(dimension);
  sigma = IOHprofiler_allocate_int_vector(dimension);
  xins = IOHprofiler_allocate_vector(dimension);
  problem =  f_linear_allocate(dimension);
  f_linear_ins = 1;

  if(instance == 1){
    for(i = 0; i < dimension; i++)
      z[i] = 0;
    a = 0.0;
    problem = transform_vars_xor(problem,z,0);
    problem = transform_obj_shift(problem,a);
  }
  else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }


  IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
  IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
  IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

  IOHprofiler_free_memory(z);
  IOHprofiler_free_memory(sigma);
  IOHprofiler_free_memory(xins);
  return problem;
}
#line 16 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_one_max.c"
/**
 * @Onemax function
 */

/**
 * @file f_one_max.c
 * @brief Implementation of the one_max function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_one_max.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_one_max.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_one_max.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_one_max.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_one_max.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_one_max.c"
#line 26 "code-experiments/src/profiler/../suite/PBO/f_one_max.c"
/**
 * @brief Implements the one_max function without connections to any IOHprofiler structures.
 */
static double f_one_max_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        result += (double)x[i];
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_one_max_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_one_max_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic one_max problem.
 */
static IOHprofiler_problem_t *f_one_max_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("one_max function",
                                                                               f_one_max_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "one_max", number_of_variables);

    /* Compute best solution */
    f_one_max_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler one_max problem.
 */
static IOHprofiler_problem_t *f_one_max_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);
    problem = f_one_max_allocate(dimension);

    if(instance == 1){
        for(i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem,z,0);
        problem = transform_obj_shift(problem,a);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 17 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_labs.c"
/**
 * @Onemax function
 */

/**
 * @file f_labs.c
 * @brief Implementation of the labs function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_labs.c"
#endif

#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 21 "code-experiments/src/profiler/../suite/PBO/f_labs.c"
#endif

#line 24 "code-experiments/src/profiler/../suite/PBO/f_labs.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_labs.c"
#line 26 "code-experiments/src/profiler/../suite/PBO/f_labs.c"
#line 27 "code-experiments/src/profiler/../suite/PBO/f_labs.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_shift.c"
/**
 * @file transform_vars_shift.c
 * @brief Implementation of shifting all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_SHIFT
#define TRANSFORM_VARS_SHIFT

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_shift.c"
#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_shift.c"

/**
 * @brief Data type for transform_vars_shift.
 */
typedef struct {
  int *offset;
  int *shifted_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_shift_data_t;

/**
 * @brief Evaluates the transformation.
 */
static void transform_vars_shift_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_shift_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }

  data = (transform_vars_shift_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  

  for (i = 0; i < problem->number_of_variables; ++i) {
    data->shifted_x[i] = x[i] + data->offset[i];
  }
  inner_problem->number_of_variables = problem->number_of_variables;
  IOHprofiler_evaluate_function(inner_problem, data->shifted_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_shift_free(void *thing) {
  transform_vars_shift_data_t *data = (transform_vars_shift_data_t *) thing;
  IOHprofiler_free_memory(data->shifted_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_shift(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int shift_bounds) {
  transform_vars_shift_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  if (shift_bounds)
    IOHprofiler_error("shift_bounds not implemented.");


  data = (transform_vars_shift_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, inner_problem->number_of_variables);
  data->shifted_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);


  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_shift_free, "transform_vars_shift");
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  problem->evaluate_function = transform_vars_shift_evaluate;
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] += data->offset[i];
  }
  return problem;
}
#endif
#line 28 "code-experiments/src/profiler/../suite/PBO/f_labs.c"
#line 29 "code-experiments/src/profiler/../suite/PBO/f_labs.c"

/**
 * @brief Implements the labs function without connections to any IOHprofiler structures.
 */
static double correlation(const int * x, const size_t number_of_variables, size_t k)
{
    size_t i;
    int x1,x2;
    double result;
    result = 0.0;
    for(i = 0 ; i < number_of_variables - k; ++i){
        if(x[i] == 0){
            x1 = -1;
        }
        else{
            x1 = 1;
        }
        if(x[i + k] == 0){
            x2 = -1;
        }
        else{
            x2 = 1;
        }
        result += x1 * x2;
    }
    return result;
}

static double f_labs_raw(const int *x, const size_t number_of_variables) {
    size_t k = 0;
    double result,cor;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;

    result = 0.0;
    for (k = 1; k < number_of_variables; ++k){
        cor = correlation(x,number_of_variables,k);
        result += cor * cor;
    }

    result = (double)(number_of_variables * number_of_variables) / 2.0 / result;
    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_labs_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_labs_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic labs problem.
 */
static IOHprofiler_problem_t *f_labs_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("labs function",
                                                                               f_labs_evaluate, NULL, number_of_variables, -1, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "labs", number_of_variables);

    /* Compute best solution */
    problem->best_value[0] = DBL_MAX;
    return problem;
}

/**
 * @brief Creates the IOHprofiler labs problem.
 */
static IOHprofiler_problem_t *f_labs_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {

  
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);
    problem = f_labs_allocate(dimension);
    if(instance == 1){
        for(i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem,z,0);
        problem = transform_obj_shift(problem,a);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");
    
    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 18 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy1.c"
/**
 * @Onemax function
 */

/**
 * @file f_one_max_dummy1.c
 * @brief Implementation of the one_max_dummy1 function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy1.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy1.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy1.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy1.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy1.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy1.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_dummy.c"
/**
 * @file transform_vars_dummy.c
 * @brief Implementation of dummyd all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_DUMMY1
#define TRANSFORM_VARS_DUMMY1

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_dummy.c"
#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_dummy.c"

/**
 * @brief Data type for transform_vars_dummy.
 */
typedef struct {
  int *offset;
  int *reduncted_x;
  int *postion_match;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_dummy_data_t;

static void compute_dummy_match(int * postion_match, const int old_dimension, const int new_dimension){
  size_t i,j;
  int temp;
  double *randN = IOHprofiler_allocate_vector(1);
  int flag;
  int dummyins = 10000;
  for(i = 0; i < new_dimension;){
    IOHprofiler_unif(randN, 1, dummyins++);
    temp = (int)(randN[0] * old_dimension);
    flag = 1;
    for(j = 0; j < i; ++j){
      if(postion_match[j] == temp){
        flag = 0;
        break;
      }
    }
    if(flag == 1){
      postion_match[i] = temp;
      ++i;
    }
    else{
      continue;
    }
  }
  IOHprofiler_free_memory(randN);
}

static void transform_vars_dummy_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_dummy_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (transform_vars_dummy_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->reduncted_x[i] = x[data->postion_match[i]];
  }
  IOHprofiler_evaluate_function(inner_problem, data->reduncted_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_dummy_free(void *thing) {
  transform_vars_dummy_data_t *data = (transform_vars_dummy_data_t *) thing;
  IOHprofiler_free_memory(data->reduncted_x);
  IOHprofiler_free_memory(data->postion_match);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_dummy(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int dummy_bounds) {
  if(*offset==0){return inner_problem;}
  transform_vars_dummy_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  size_t new_dimension;
  if (dummy_bounds)
    IOHprofiler_error("dummy_bounds not implemented.");
 
  
  new_dimension = offset[0];
  data = (transform_vars_dummy_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, 1);
  data->reduncted_x = IOHprofiler_allocate_int_vector(new_dimension);
  data->postion_match = IOHprofiler_allocate_int_vector(new_dimension);
  compute_dummy_match(data->postion_match,inner_problem->number_of_variables,new_dimension);

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_dummy_free, "transform_vars_dummy");
  problem->number_of_variables = new_dimension;
  inner_problem->number_of_variables = problem->number_of_variables;

  while(inner_problem->data != NULL){
    inner_problem = IOHprofiler_problem_transformed_get_inner_problem(inner_problem);
    inner_problem->number_of_variables = problem->number_of_variables;
  }

  problem->evaluate_function = transform_vars_dummy_evaluate;
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = problem->best_parameter[data->postion_match[i]];
  }
  IOHprofiler_evaluate_function(inner_problem, problem->best_parameter, problem->best_value);
  return problem;
}
#endif
#line 26 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy1.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_dummy_sigma.c"
/**
 * @file transform_vars_dummy.c
 * @brief Implementation of dummyd all decision values by an offset.
 */

#ifndef TRANSFORM_VARS_DUMMY_SIGMA
#define TRANSFORM_VARS_DUMMY_SIGMA

#include <assert.h>

#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_dummy_sigma.c"
#line 13 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_dummy_sigma.c"

/**
 * @brief Data type for transform_vars_dummy.
 */
typedef struct {
  int *offset;
  int *reduncted_x;
  int *postion_match;
  int *sigma_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_dummy_sigma_data_t;

static void compute_dummy_sigma_match(int * postion_match, const int old_dimension, const int new_dimension){
  size_t i,j;
  int temp;
  double *randN = IOHprofiler_allocate_vector(1);
  int flag;
  int dummyins = 10000;
  for(i = 0; i < new_dimension;){
    IOHprofiler_unif(randN, 1, dummyins++);
    temp = (int)(randN[0] * old_dimension);
    flag = 1;
    for(j = 0; j < i; ++j){
      if(postion_match[j] == temp){
        flag = 0;
        break;
      }
    }
    if(flag == 1){
      postion_match[i] = temp;
      ++i;
    }
    else{
      continue;
    }
  }
  IOHprofiler_free_memory(randN);
}

static int dummy_sigma_compute(const int *x, const int pos){
  return x[pos];
}


static void transform_vars_dummy_sigma_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_dummy_sigma_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (transform_vars_dummy_sigma_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->reduncted_x[i] = x[data->postion_match[i]];
  }
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->sigma_x[i] = dummy_sigma_compute(data->reduncted_x,data->offset[i]);
  }
  IOHprofiler_evaluate_function(inner_problem, data->sigma_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_dummy_sigma_free(void *thing) {
  transform_vars_dummy_sigma_data_t *data = (transform_vars_dummy_sigma_data_t *) thing;
  IOHprofiler_free_memory(data->reduncted_x);
  IOHprofiler_free_memory(data->postion_match);
  IOHprofiler_free_memory(data->sigma_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_dummy_sigma(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int *offset1,
                                            const int dummy_bounds) {
    
  transform_vars_dummy_sigma_data_t *data;
  IOHprofiler_problem_t *problem;
  int * temp_best;
  size_t i;
  size_t new_dimension;
  if (dummy_bounds)
    IOHprofiler_error("dummy_bounds not implemented.");

  new_dimension = offset[0];
  temp_best = IOHprofiler_allocate_int_vector(new_dimension);
  data = (transform_vars_dummy_sigma_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset1, new_dimension);
  data->reduncted_x = IOHprofiler_allocate_int_vector(new_dimension);
  data->postion_match = IOHprofiler_allocate_int_vector(new_dimension);
  data->sigma_x = IOHprofiler_allocate_int_vector(new_dimension);
  compute_dummy_sigma_match(data->postion_match,inner_problem->number_of_variables,new_dimension);
  
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_dummy_sigma_free, "transform_vars_dummy_sigma");
  problem->number_of_variables = new_dimension;
  inner_problem->number_of_variables = problem->number_of_variables;
  
  while(inner_problem->data != NULL){
    inner_problem = IOHprofiler_problem_transformed_get_inner_problem(inner_problem);
    inner_problem->number_of_variables = problem->number_of_variables;
  }

  problem->evaluate_function = transform_vars_dummy_sigma_evaluate;
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      temp_best[i] = problem->best_parameter[data->postion_match[i]];
  }
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = temp_best[i];
  }
  for (i = 0; i < problem->number_of_variables; i++) {
      temp_best[i] = dummy_sigma_compute(problem->best_parameter,data->offset[i]);
  }
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = temp_best[i];
  }
  problem->evaluate_function(problem, problem->best_parameter, problem->best_value);
  IOHprofiler_free_memory(temp_best);
  return problem;
}
#endif
#line 27 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy1.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_dummy_xor.c"
/**
 * @file transform_vars_dummy.c
 * @brief Implementation of dummyd all decision values by an offset.
 */

#ifndef TRANSFORM_VARS_DUMMY_XOR
#define TRANSFORM_VARS_DUMMY_XOR

#include <assert.h>

#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_dummy_xor.c"
#line 13 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_dummy_xor.c"

/**
 * @brief Data type for transform_vars_dummy.
 */
typedef struct {
  int *offset;
  int *reduncted_x;
  int *postion_match;
  int *xor_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_dummy_xor_data_t;

static void compute_dummy_xor_match(int * postion_match, const int old_dimension, const int new_dimension){
  size_t i,j;
  int temp;
  double *randN = IOHprofiler_allocate_vector(1);
  int flag;
  int dummyins = 10000;
  for(i = 0; i < new_dimension;){
    IOHprofiler_unif(randN, 1, dummyins++);
    temp = (int)(randN[0] * old_dimension);
    flag = 1;
    for(j = 0; j < i; ++j){
      if(postion_match[j] == temp){
        flag = 0;
        break;
      }
    }
    if(flag == 1){
      postion_match[i] = temp;
      ++i;
    }
    else{
      continue;
    }
  }
  IOHprofiler_free_memory(randN);
}

static int dummy_xor_compute(const int x1, const int x2){
    return (int) x1 != x2;
}


static void transform_vars_dummy_xor_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_dummy_xor_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (transform_vars_dummy_xor_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->reduncted_x[i] = x[data->postion_match[i]];
  }
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->xor_x[i] = dummy_xor_compute(data->reduncted_x[i],data->offset[i]);
  }
  IOHprofiler_evaluate_function(inner_problem, data->xor_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_dummy_xor_free(void *thing) {
  transform_vars_dummy_xor_data_t *data = (transform_vars_dummy_xor_data_t *) thing;
  IOHprofiler_free_memory(data->reduncted_x);
  IOHprofiler_free_memory(data->postion_match);
  IOHprofiler_free_memory(data->xor_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_dummy_xor(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int *offset1,
                                            const int dummy_bounds) {
    
  transform_vars_dummy_xor_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  size_t new_dimension;
  if (dummy_bounds)
    IOHprofiler_error("dummy_bounds not implemented.");

  new_dimension = offset[0];
  data = (transform_vars_dummy_xor_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset1, new_dimension);
  data->reduncted_x = IOHprofiler_allocate_int_vector(new_dimension);
  data->postion_match = IOHprofiler_allocate_int_vector(new_dimension);
  data->xor_x = IOHprofiler_allocate_int_vector(new_dimension);
  compute_dummy_xor_match(data->postion_match,inner_problem->number_of_variables,new_dimension);
  
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_dummy_xor_free, "transform_vars_dummy_xor");
  problem->number_of_variables = new_dimension;
  inner_problem->number_of_variables = problem->number_of_variables;
  
  while(inner_problem->data != NULL){
    inner_problem = IOHprofiler_problem_transformed_get_inner_problem(inner_problem);
    inner_problem->number_of_variables = problem->number_of_variables;
  }

  problem->evaluate_function = transform_vars_dummy_xor_evaluate;
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = problem->best_parameter[data->postion_match[i]];
  }
  IOHprofiler_evaluate_function(inner_problem, problem->best_parameter, problem->best_value);
  return problem;
}
#endif
#line 28 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy1.c"
#line 29 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy1.c"


/**
 * @brief Implements the one_max_dummy1 function without connections to any IOHprofiler structures.
 */
static double f_one_max_dummy1_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        result += (double)x[i];
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_one_max_dummy1_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_one_max_dummy1_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic one_max_dummy1 problem.
 */
static IOHprofiler_problem_t *f_one_max_dummy1_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("one_max_dummy1 function",
                                                                               f_one_max_dummy1_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "one_max_dummy1", number_of_variables);

    /* Compute best solution */
    f_one_max_dummy1_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler one_max_dummy1 problem.
 */
static IOHprofiler_problem_t *f_one_max_dummy1_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {

    int * dummy;
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    
    



    dummy = IOHprofiler_allocate_int_vector(1);
    problem = f_one_max_dummy1_allocate(dimension);

    if(instance == 1){
        dummy[0] = dimension * 0.5;
        problem = transform_vars_dummy(problem, dummy, 0);   
    }
    else if(instance > 1 && instance <= 50){
        dummy[0] = dimension * 0.5;

        z = IOHprofiler_allocate_int_vector(dummy[0]);
        IOHprofiler_compute_xopt(z,rseed,dummy[0]);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_dummy_xor(problem,dummy,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);

        IOHprofiler_free_memory(z);
    }
    else if(instance > 50 && instance <= 100)
    {
        dummy[0] = dimension * 0.5;
        sigma = IOHprofiler_allocate_int_vector(dummy[0]);
        xins = IOHprofiler_allocate_vector(dummy[0]);
        IOHprofiler_compute_xopt_double(xins,rseed,dummy[0]);
        for(i = 0; i < dummy[0]; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dummy[0]; i++){
            t = (int)(xins[i] * (double)dummy[0]);
            assert(t >= 0 && t < dummy[0]);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_dummy_sigma(problem, dummy, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);

        IOHprofiler_free_memory(sigma);
        IOHprofiler_free_memory(xins);
    } else {
        dummy[0] = dimension * 0.5;
        problem = transform_vars_dummy(problem, dummy, 0);  
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(dummy);
    return problem;
}
#line 19 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy2.c"
/**
 * @Onemax function
 */

/**
 * @file f_one_max_dummy2.c
 * @brief Implementation of the one_max_dummy2 function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy2.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy2.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy2.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy2.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy2.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy2.c"
#line 26 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy2.c"
#line 27 "code-experiments/src/profiler/../suite/PBO/f_one_max_dummy2.c"
 
/**
 * @brief Implements the one_max_dummy2 function without connections to any IOHprofiler structures.
 */
static double f_one_max_dummy2_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        result += (double)x[i];
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_one_max_dummy2_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_one_max_dummy2_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic one_max_dummy2 problem.
 */
static IOHprofiler_problem_t *f_one_max_dummy2_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("one_max_dummy2 function",
                                                                               f_one_max_dummy2_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "one_max_dummy2", number_of_variables);

    /* Compute best solution */
    f_one_max_dummy2_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler one_max_dummy2 problem.
 */
static IOHprofiler_problem_t *f_one_max_dummy2_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {

    int * dummy;
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    

    dummy = IOHprofiler_allocate_int_vector(1);
    problem = f_one_max_dummy2_allocate(dimension);
    if(instance == 1){
        dummy[0] = dimension * 0.9;
        problem = transform_vars_dummy(problem, dummy, 0);   
    }
    else if(instance > 1 && instance <= 50){
        dummy[0] = dimension * 0.9;
        z = IOHprofiler_allocate_int_vector(dummy[0]);
        IOHprofiler_compute_xopt(z,rseed,dummy[0]);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_dummy_xor(problem,dummy,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);

        IOHprofiler_free_memory(z);
    }
    else if(instance > 50 && instance <= 100)
    {

        dummy[0] = dimension * 0.9;
        sigma = IOHprofiler_allocate_int_vector(dummy[0]);
        xins = IOHprofiler_allocate_vector(dummy[0]);
        IOHprofiler_compute_xopt_double(xins,rseed,dummy[0]);
        for(i = 0; i < dummy[0]; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dummy[0]; i++){
            t = (int)(xins[i] * (double)dummy[0]);
            assert(t >= 0 && t < dummy[0]);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_dummy_sigma(problem, dummy, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
        IOHprofiler_free_memory(sigma);
        IOHprofiler_free_memory(xins);
    } else {
        dummy[0] = dimension * 0.9;
        problem = transform_vars_dummy(problem, dummy, 0);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(dummy);
    
    return problem;
}
#line 20 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_one_max_epistasis.c"
/**
 * @Onemax function
 */

/**
 * @file f_one_max_epistasis.c
 * @brief Implementation of the one_max_epistasis function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_one_max_epistasis.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_one_max_epistasis.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_one_max_epistasis.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_one_max_epistasis.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_epistasis.c"
/**
 * @file transform_vars_epistasis.c
 * @brief Implementation of epistasis all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_EPISTASIS
#define TRANSFORM_VARS_EPISTASIS

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_epistasis.c"
#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_epistasis.c"

/**
 * @brief Data type for transform_vars_epistasis.
 */
typedef struct {
  int *offset;
  int *epistasis_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_epistasis_data_t;


static void epistasis_compute(const int *x, int * epistasis_x,  int block_size, const size_t dimension){
  int i,j,h,epistasis_result;

  h = 0;
  while(h + block_size - 1 < dimension){
    i = 0;
    while(i < block_size){
      epistasis_result = -1;
      for(j = 0; j < block_size; ++j){
        if( (block_size - j - 1) != ((block_size - i - 1) - 1) % 4){
          if(epistasis_result == -1){
            epistasis_result = x[h+j];
          }
          else{
            epistasis_result = (epistasis_result != x[h+j]);
          }
        }
      }
      epistasis_x[h+i] = epistasis_result;
      ++i;
    }
    h += block_size;
  }
  if(dimension - h > 0){
    block_size = dimension - h;
    i = 0;
    while(i < block_size){
      epistasis_result = -1;
      for(j = 0; j < block_size; ++j){
        if( (block_size - j - 1) != ((block_size - i - 1) - 1) % 4){
          if(epistasis_result == -1){
            epistasis_result = x[h+j];
          }
          else{
            epistasis_result = (epistasis_result != x[h+j]);
          }
        }
      }
      epistasis_x[h+i] = epistasis_result;
      ++i;
    }
  }
}

static void transform_vars_epistasis_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_epistasis_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (transform_vars_epistasis_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);

  epistasis_compute(x, data->epistasis_x, data->offset[0], problem->number_of_variables);

  IOHprofiler_evaluate_function(inner_problem, data->epistasis_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_epistasis_free(void *thing) {
  transform_vars_epistasis_data_t *data = (transform_vars_epistasis_data_t *) thing;
  IOHprofiler_free_memory(data->epistasis_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_epistasis(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int epistasis_bounds) {
    
  if(*offset==0){return inner_problem;}
  transform_vars_epistasis_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  if (epistasis_bounds)
    IOHprofiler_error("epistasis_bounds not implemented.");

 
  data = (transform_vars_epistasis_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, 1);
  data->epistasis_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);

  
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_epistasis_free, "transform_vars_epistasis");
  problem->evaluate_function = transform_vars_epistasis_evaluate;
  /* Compute best parameter */
  /*Best parameter will not change with this transformation*/

  return problem;
}
#endif
#line 24 "code-experiments/src/profiler/../suite/PBO/f_one_max_epistasis.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_one_max_epistasis.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_epistasis_xor.c"
/**
 * @file transform_vars_epistasis_xor.c
 * @brief Implementation of epistasis_xor all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_EPISTASIS_XOR
#define TRANSFORM_VARS_EPISTASIS_XOR
#include <assert.h>

#line 10 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_epistasis_xor.c"
#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_epistasis_xor.c"

/**
 * @brief Data type for transform_vars_epistasis_xor.
 */
typedef struct {
  int *offset;
  int *offset1;
  int *epistasis_x;
  int *epistasis_xor_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_epistasis_xor_data_t;


static void epistasis_compute_beforexor(const int *x, int * epistasis_x,  int block_size, const size_t dimension){
  int i,j,h,epistasis_result;

  h = 0;
  while(h + block_size - 1 < dimension){
    i = 0;
    while(i < block_size){
      epistasis_result = -1;
      for(j = 0; j < block_size; ++j){
        if( (block_size - j - 1) != ((block_size - i - 1) - 1) % 4){
          if(epistasis_result == -1){
            epistasis_result = x[h+j];
          }
          else{
            epistasis_result = (epistasis_result != x[h+j]);
          }
        }
      }
      epistasis_x[h+i] = epistasis_result;
      ++i;
    }
    h += block_size;
  }
  if(dimension - h > 0){
    block_size = dimension - h;
    i = 0;
    while(i < block_size){
      epistasis_result = -1;
      for(j = 0; j < block_size; ++j){
        if( (block_size - j - 1) != ((block_size - i - 1) - 1) % 4){
          if(epistasis_result == -1){
            epistasis_result = x[h+j];
          }
          else{
            epistasis_result = (epistasis_result != x[h+j]);
          }
        }
      }
      epistasis_x[h+i] = epistasis_result;
      ++i;
    }
  }
}

static int epistasis_xor_compute(const int x1, const int x2){
    return (int) x1 != x2;
}


static void transform_vars_epistasis_xor_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_epistasis_xor_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (transform_vars_epistasis_xor_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);

  epistasis_compute_beforexor(x, data->epistasis_x, data->offset[0], problem->number_of_variables);
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->epistasis_xor_x[i] = epistasis_xor_compute(data->epistasis_x[i],data->offset1[i]);
  }

  IOHprofiler_evaluate_function(inner_problem, data->epistasis_xor_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_epistasis_xor_free(void *thing) {
  transform_vars_epistasis_xor_data_t *data = (transform_vars_epistasis_xor_data_t *) thing;
  IOHprofiler_free_memory(data->epistasis_xor_x);
  IOHprofiler_free_memory(data->offset);
  IOHprofiler_free_memory(data->offset1);
  IOHprofiler_free_memory(data->epistasis_x);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_epistasis_xor(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int *offset1,
                                            const int epistasis_xor_bounds) {
    
  transform_vars_epistasis_xor_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  if (epistasis_xor_bounds)
    IOHprofiler_error("epistasis_xor_bounds not implemented.");

 
  data = (transform_vars_epistasis_xor_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, 1);
  data->offset1 = IOHprofiler_duplicate_int_vector(offset1, inner_problem->number_of_variables);
  data->epistasis_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);
  data->epistasis_xor_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);


  
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_epistasis_xor_free, "transform_vars_epistasis_xor");
  problem->evaluate_function = transform_vars_epistasis_xor_evaluate;
  /* Compute best parameter */
  /*Best parameter will not change with this transformation*/

  return problem;
}
#endif
#line 26 "code-experiments/src/profiler/../suite/PBO/f_one_max_epistasis.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_epistasis_sigma.c"
/**
 * @file transform_vars_epistasis_sigma.c
 * @brief Implementation of epistasis_sigma all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_EPISTASIS_SIGMA
#define TRANSFORM_VARS_EPISTASIS_SIGMA

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_epistasis_sigma.c"
#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_epistasis_sigma.c"

/**
 * @brief Data type for transform_vars_epistasis_sigma.
 */
typedef struct {
  int *offset;
  int *offset1;
  int *epistasis_x;
  int *epistasis_sigma_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_epistasis_sigma_data_t;


static void epistasis_compute_beforesigma(const int *x, int * epistasis_x,  int block_size, const size_t dimension){
  int i,j,h,epistasis_result;

  h = 0;
  while(h + block_size - 1 < dimension){
    i = 0;
    while(i < block_size){
      epistasis_result = -1;
      for(j = 0; j < block_size; ++j){
        if( (block_size - j - 1) != ((block_size - i - 1) - 1) % 4){
          if(epistasis_result == -1){
            epistasis_result = x[h+j];
          }
          else{
            epistasis_result = (epistasis_result != x[h+j]);
          }
        }
      }
      epistasis_x[h+i] = epistasis_result;
      ++i;
    }
    h += block_size;
  }
  if(dimension - h > 0){
    block_size = dimension - h;
    i = 0;
    while(i < block_size){
      epistasis_result = -1;
      for(j = 0; j < block_size; ++j){
        if( (block_size - j - 1) != ((block_size - i - 1) - 1) % 4){
          if(epistasis_result == -1){
            epistasis_result = x[h+j];
          }
          else{
            epistasis_result = (epistasis_result != x[h+j]);
          }
        }
      }
      epistasis_x[h+i] = epistasis_result;
      ++i;
    }
  }
}

static int epistasis_sigma_compute(const int *x, const int pos){
  return x[pos];
}


static void transform_vars_epistasis_sigma_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_epistasis_sigma_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (transform_vars_epistasis_sigma_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);

  epistasis_compute_beforesigma(x, data->epistasis_x, data->offset[0], problem->number_of_variables);
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->epistasis_sigma_x[i] = epistasis_sigma_compute(data->epistasis_x,data->offset1[i]);
  }

  IOHprofiler_evaluate_function(inner_problem, data->epistasis_sigma_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_epistasis_sigma_free(void *thing) {
  transform_vars_epistasis_sigma_data_t *data = (transform_vars_epistasis_sigma_data_t *) thing;
  IOHprofiler_free_memory(data->epistasis_sigma_x);
  IOHprofiler_free_memory(data->offset);
  IOHprofiler_free_memory(data->offset1);
  IOHprofiler_free_memory(data->epistasis_x);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_epistasis_sigma(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int *offset1,
                                            const int epistasis_sigma_bounds) {
    
  transform_vars_epistasis_sigma_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  if (epistasis_sigma_bounds)
    IOHprofiler_error("epistasis_sigma_bounds not implemented.");

 
  data = (transform_vars_epistasis_sigma_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, 1);
  data->offset1 = IOHprofiler_duplicate_int_vector(offset1, inner_problem->number_of_variables);
  data->epistasis_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);
  data->epistasis_sigma_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);


  
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_epistasis_sigma_free, "transform_vars_epistasis_sigma");
  problem->evaluate_function = transform_vars_epistasis_sigma_evaluate;
  /* Compute best parameter */
  /*Best parameter will not change with this transformation*/

  return problem;
}
#endif
#line 27 "code-experiments/src/profiler/../suite/PBO/f_one_max_epistasis.c"
/**
 * @brief Implements the one_max_epistasis function without connections to any IOHprofiler structures.
 */
static double f_one_max_epistasis_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        result += (double)x[i];
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_one_max_epistasis_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_one_max_epistasis_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic one_max_epistasis problem.
 */
static IOHprofiler_problem_t *f_one_max_epistasis_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("one_max_epistasis function",
                                                                               f_one_max_epistasis_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "one_max_epistasis", number_of_variables);

    /* Compute best solution */
    f_one_max_epistasis_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler one_max_epistasis problem.
 */
static IOHprofiler_problem_t *f_one_max_epistasis_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {

    int * epistasis;
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);

    epistasis = IOHprofiler_allocate_int_vector(1);
    problem = f_one_max_epistasis_allocate(dimension);
    if(instance == 1){
        epistasis[0] = 4;
        problem = transform_vars_epistasis(problem, epistasis,0);
    }
    else if(instance > 1 && instance <= 50){
        epistasis[0] = 4;


        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_vars_epistasis_xor(problem,epistasis, z, 0);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        epistasis[0] = 4;

        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_epistasis_sigma(problem,epistasis, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        epistasis[0] = 4;
        problem = transform_vars_epistasis(problem, epistasis,0);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(epistasis);
    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 21 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_one_max_neutrality.c"
/**
 * @Onemax function
 */

/**
 * @file f_one_max_neutrality.c
 * @brief Implementation of the one_max_neutrality function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_one_max_neutrality.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_one_max_neutrality.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_one_max_neutrality.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_one_max_neutrality.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_neutrality.c"
/**
 * @file transform_vars_neutrality.c
 * @brief Implementation of neutrality all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_NEUTRALITY
#define TRANSFORM_VARS_NEUTRALITY

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_neutrality.c"
#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_neutrality.c"

/**
 * @brief Data type for transform_vars_neutrality.
 */
typedef struct {
  int *offset;
  int *neutrality_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_neutrality_data_t;

static int neutrality_compute(const int *x, const int index, const int block_size){
  size_t number_of_one, number_of_zero, i;
  number_of_zero = 0;
  number_of_one = 0;
  i = 0;
  while(i < block_size){
    if(x[index + i] == 0){
      number_of_zero++;
    }
    if(x[index + i] == 1){
      number_of_one++;
    }
    ++i;
  }
  return (number_of_zero >= number_of_one ? 0 : 1);
}

static void transform_vars_neutrality_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_neutrality_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (transform_vars_neutrality_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->neutrality_x[i] = neutrality_compute(x, i*data->offset[0], data->offset[0]);
  }
  IOHprofiler_evaluate_function(inner_problem, data->neutrality_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_neutrality_free(void *thing) {
  transform_vars_neutrality_data_t *data = (transform_vars_neutrality_data_t *) thing;
  IOHprofiler_free_memory(data->neutrality_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_neutrality(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int neutrality_bounds) {
    
  if(*offset==0){return inner_problem;}
  transform_vars_neutrality_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  size_t new_dimension;
  if (neutrality_bounds)
    IOHprofiler_error("neutrality_bounds not implemented.");

  if(inner_problem->number_of_variables >= offset[0])
  {
    new_dimension = inner_problem->number_of_variables / offset[0];
  }
  else{
    return inner_problem;
  }
  
  assert(new_dimension > 0);
  data = (transform_vars_neutrality_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, inner_problem->number_of_variables);
  data->neutrality_x = IOHprofiler_allocate_int_vector(new_dimension);

  
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_neutrality_free, "transform_vars_neutrality");
  problem->number_of_variables = new_dimension;
  inner_problem->number_of_variables = problem->number_of_variables;
  problem->evaluate_function = transform_vars_neutrality_evaluate;
  while(inner_problem->data != NULL){
    inner_problem = IOHprofiler_problem_transformed_get_inner_problem(inner_problem);
    inner_problem->number_of_variables = problem->number_of_variables;
  }
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = neutrality_compute(inner_problem->best_parameter, i*data->offset[0], data->offset[0]);
  }
  problem->evaluate_function(problem, problem->best_parameter, problem->best_value);
  return problem;
}
#endif
#line 24 "code-experiments/src/profiler/../suite/PBO/f_one_max_neutrality.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_one_max_neutrality.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_neutrality_sigma.c"
/**
 * @file transform_vars_neutrality_sigma_sigma.c
 * @brief Implementation of neutrality_sigma all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_NEUTRALITY_SIGMA
#define TRANSFORM_VARS_NEUTRALITY_SIGMA
#include <assert.h>

#line 10 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_neutrality_sigma.c"
#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_neutrality_sigma.c"

/**
 * @brief Data type for transform_vars_neutrality_sigma.
 */
typedef struct {
  int *offset;
  int *offset1;
  int *neutrality_x;
  int *sigma_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_neutrality_sigma_data_t;

static int neutrality_compute_before_sigma(const int *x, const int index, const int block_size){
  size_t number_of_one, number_of_zero, i;
  number_of_zero = 0;
  number_of_one = 0;
  i = 0;
  while(i < block_size){
    if(x[index + i] == 0){
      number_of_zero++;
    }
    if(x[index + i] == 1){
      number_of_one++;
    }
    ++i;
  }
  return (number_of_zero >= number_of_one ? 0 : 1);
}

static int neutrality_sigma_compute(const int *x, const int pos){
  return x[pos];
}

static void transform_vars_neutrality_sigma_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_neutrality_sigma_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (transform_vars_neutrality_sigma_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->neutrality_x[i] = neutrality_compute_before_sigma(x, i*data->offset[0], data->offset[0]);
  }
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->sigma_x[i] = neutrality_sigma_compute(data->neutrality_x,data->offset1[i]);
  }
  IOHprofiler_evaluate_function(inner_problem, data->sigma_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_neutrality_sigma_free(void *thing) {
  transform_vars_neutrality_sigma_data_t *data = (transform_vars_neutrality_sigma_data_t *) thing;
  IOHprofiler_free_memory(data->neutrality_x);
  IOHprofiler_free_memory(data->offset);
  IOHprofiler_free_memory(data->offset1);
  IOHprofiler_free_memory(data->sigma_x);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_neutrality_sigma(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int *offset1,
                                            const int neutrality_sigma_bounds) {
    
  transform_vars_neutrality_sigma_data_t *data;
  IOHprofiler_problem_t *problem;
  int * temp_best;
  size_t i;
  size_t new_dimension;
  if (neutrality_sigma_bounds)
    IOHprofiler_error("neutrality_sigma_bounds not implemented.");

  if(inner_problem->number_of_variables >= offset[0])
  {
    new_dimension = inner_problem->number_of_variables / offset[0];
  }
  else{
    return inner_problem;
  }
  
  assert(new_dimension > 0);
  data = (transform_vars_neutrality_sigma_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, 1);
  data->offset1 = IOHprofiler_duplicate_int_vector(offset1,new_dimension);
  data->neutrality_x = IOHprofiler_allocate_int_vector(new_dimension);
  data->sigma_x = IOHprofiler_allocate_int_vector(new_dimension);
  temp_best = IOHprofiler_allocate_int_vector(new_dimension);

  
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_neutrality_sigma_free, "transform_vars_neutrality_sigma");
  problem->number_of_variables = new_dimension;
  inner_problem->number_of_variables = problem->number_of_variables;
  problem->evaluate_function = transform_vars_neutrality_sigma_evaluate;
  while(inner_problem->data != NULL){
    inner_problem = IOHprofiler_problem_transformed_get_inner_problem(inner_problem);
    inner_problem->number_of_variables = problem->number_of_variables;
  }
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = neutrality_compute_before_sigma(inner_problem->best_parameter, i*data->offset[0], data->offset[0]);
  }
  for (i = 0; i < problem->number_of_variables; i++) {
      temp_best[i] = neutrality_sigma_compute(problem->best_parameter,data->offset1[i]);
  }
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = temp_best[i];
  }
  IOHprofiler_evaluate_function(inner_problem, problem->best_parameter, problem->best_value);
  IOHprofiler_free_memory(temp_best);
  return problem;
}
#endif
#line 26 "code-experiments/src/profiler/../suite/PBO/f_one_max_neutrality.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_neutrality_xor.c"
/**
 * @file transform_vars_neutrality_xor.c
 * @brief Implementation of neutrality_xor all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_NEUTRALITY_XOR
#define TRANSFORM_VARS_NEUTRALITY_XOR
#include <assert.h>

#line 10 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_neutrality_xor.c"
#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_vars_neutrality_xor.c"

/**
 * @brief Data type for transform_vars_neutrality_xor.
 */
typedef struct {
  int *offset;
  int *offset1;
  int *neutrality_x;
  int *xor_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_neutrality_xor_data_t;

static int neutrality_compute_before_xor(const int *x, const int index, const int block_size){
  size_t number_of_one, number_of_zero, i;
  number_of_zero = 0;
  number_of_one = 0;
  i = 0;
  while(i < block_size){
    if(x[index + i] == 0){
      number_of_zero++;
    }
    if(x[index + i] == 1){
      number_of_one++;
    }
    ++i;
  }
  return (number_of_zero >= number_of_one ? 0 : 1);
}

static int neutrality_xor_compute(const int x1, const int x2){
    return (int) x1 != x2;
}

static void transform_vars_neutrality_xor_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_neutrality_xor_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (transform_vars_neutrality_xor_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->neutrality_x[i] = neutrality_compute_before_xor(x, i*data->offset[0], data->offset[0]);
  }
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->xor_x[i] = neutrality_xor_compute(data->neutrality_x[i],data->offset1[i]);
  }
  IOHprofiler_evaluate_function(inner_problem, data->xor_x, y);
  problem->raw_fitness[0] = y[0];
  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_neutrality_xor_free(void *thing) {
  transform_vars_neutrality_xor_data_t *data = (transform_vars_neutrality_xor_data_t *) thing;
  IOHprofiler_free_memory(data->neutrality_x);
  IOHprofiler_free_memory(data->offset);
  IOHprofiler_free_memory(data->offset1);
  IOHprofiler_free_memory(data->xor_x);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_neutrality_xor(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int *offset1,
                                            const int neutrality_xor_bounds) {
    
  transform_vars_neutrality_xor_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  size_t new_dimension;
  if (neutrality_xor_bounds)
    IOHprofiler_error("neutrality_xor_bounds not implemented.");

  if(inner_problem->number_of_variables >= offset[0])
  {
    new_dimension = inner_problem->number_of_variables / offset[0];
  }
  else{
    return inner_problem;
  }
  
  assert(new_dimension > 0);
  data = (transform_vars_neutrality_xor_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, 1);
  data->offset1 = IOHprofiler_duplicate_int_vector(offset1,new_dimension);
  data->neutrality_x = IOHprofiler_allocate_int_vector(new_dimension);
  data->xor_x = IOHprofiler_allocate_int_vector(new_dimension);

  
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_neutrality_xor_free, "transform_vars_neutrality_xor");
  problem->number_of_variables = new_dimension;
  inner_problem->number_of_variables = problem->number_of_variables;
  problem->evaluate_function = transform_vars_neutrality_xor_evaluate;
  while(inner_problem->data != NULL){
    inner_problem = IOHprofiler_problem_transformed_get_inner_problem(inner_problem);
    inner_problem->number_of_variables = problem->number_of_variables;
  }
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = neutrality_compute_before_xor(inner_problem->best_parameter, i*data->offset[0], data->offset[0]);
  }

  IOHprofiler_evaluate_function(inner_problem, problem->best_parameter, problem->best_value);
  return problem;
}
#endif
#line 27 "code-experiments/src/profiler/../suite/PBO/f_one_max_neutrality.c"
/**
 * @brief Implements the one_max_neutrality function without connections to any IOHprofiler structures.
 */
static double f_one_max_neutrality_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        result += (double)x[i];
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_one_max_neutrality_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_one_max_neutrality_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic one_max_neutrality problem.
 */
static IOHprofiler_problem_t *f_one_max_neutrality_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("one_max_neutrality function",
                                                                               f_one_max_neutrality_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "one_max_neutrality", number_of_variables);

    /* Compute best solution */
    f_one_max_neutrality_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler one_max_neutrality problem.
 */
static IOHprofiler_problem_t *f_one_max_neutrality_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {


    int * neutrality;
    int *z, *sigma;
    int temp,t,new_dim;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;

  
    neutrality = IOHprofiler_allocate_int_vector(1);
    problem = f_one_max_neutrality_allocate(dimension);
    if(instance == 1){
        neutrality[0] = 3;
        problem = transform_vars_neutrality(problem, neutrality, 0);
    }
    else if(instance > 1 && instance <= 50){
        neutrality[0] = 3;
        new_dim = dimension/neutrality[0];
        z = IOHprofiler_allocate_int_vector(new_dim);

        IOHprofiler_compute_xopt(z,rseed,new_dim);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_vars_neutrality_xor(problem, neutrality,z, 0);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
        IOHprofiler_free_memory(z);
    }
    else if(instance > 50 && instance <= 100)
    {
        neutrality[0] = 3;
        new_dim = dimension / 3;
        sigma = IOHprofiler_allocate_int_vector(new_dim);
        xins = IOHprofiler_allocate_vector(new_dim);

        
        IOHprofiler_compute_xopt_double(xins,rseed,new_dim);
        for(i = 0; i < new_dim; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < new_dim; i++){
            t = (int)(xins[i] * (double)new_dim);
            assert(t >= 0 && t < new_dim);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        assert(a <= 5.0 && a >= 0.2);

        problem = transform_vars_neutrality_sigma(problem, neutrality,sigma, 0);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);

        IOHprofiler_free_memory(sigma);
        IOHprofiler_free_memory(xins);
    } else {
        neutrality[0] = 3;
        problem = transform_vars_neutrality(problem, neutrality, 0);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(neutrality);


    return problem;
}
#line 22 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness1.c"
/**
 * @Onemax function
 */

/**
 * @file f_one_max_ruggedness1.c
 * @brief Implementation of the one_max_ruggedness1 function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness1.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness1.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness1.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness1.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness1.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_ruggedness1.c"
/**
 * @file transform_obj_ruggedness1.c
 * @brief Implementation of ruggedness1ing the objective value by the given offset.
 */

#ifndef TRANSFORM_OBJ_RUGGEDNESS1
#define TRANSFORM_OBJ_RUGGEDNESS1

#include <assert.h>

#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_ruggedness1.c"
#line 13 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_ruggedness1.c"

/**
 * @brief Data type for transform_obj_ruggedness1.
 */
typedef struct {
  double offset;
} transform_obj_ruggedness1_data_t;

double compute_ruggedness1(double y, size_t dimension){
  double ruggedness_y, s;
  s = (double)dimension;
  if(y == s){
    ruggedness_y = ceil(y/2.0) + 1.0;
  }
  else if(y < s && dimension % 2 == 0){
    ruggedness_y = floor(y / 2.0) + 1.0;
  }
  else if(y < s && dimension % 2 != 0){
    ruggedness_y = ceil(y / 2.0) + 1.0;
  }
  else{
    ruggedness_y = y;
    assert(y <= s);
  }
  
  return ruggedness_y;
}

/**
 * @brief Evaluates the transformation.
 */
static void transform_obj_ruggedness1_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  transform_obj_ruggedness1_data_t *data;
  size_t i;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }

  data = (transform_obj_ruggedness1_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  IOHprofiler_evaluate_function(IOHprofiler_problem_transformed_get_inner_problem(problem), x, y);
  for (i = 0; i < problem->number_of_objectives; i++) {
      y[i] = compute_ruggedness1(y[i],problem->number_of_variables);
      problem->raw_fitness[i] = y[i];
      
  }
  assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_obj_ruggedness1(IOHprofiler_problem_t *inner_problem) {
  IOHprofiler_problem_t *problem;
  transform_obj_ruggedness1_data_t *data;
  size_t i;
  data = (transform_obj_ruggedness1_data_t *) IOHprofiler_allocate_memory(sizeof(*data));

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, NULL, "transform_obj_ruggedness1");
  problem->evaluate_function = transform_obj_ruggedness1_evaluate;
  for (i = 0; i < problem->number_of_objectives; i++) {
      problem->best_value[i] = compute_ruggedness1(problem->best_value[i],problem->number_of_variables); 
  }
  return problem;
}
#endif
#line 25 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness1.c"
/**
 * @brief Implements the one_max_ruggedness1 function without connections to any IOHprofiler structures.
 */
static double f_one_max_ruggedness1_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        result += (double)x[i];
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_one_max_ruggedness1_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_one_max_ruggedness1_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic one_max_ruggedness1 problem.
 */
static IOHprofiler_problem_t *f_one_max_ruggedness1_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("one_max_ruggedness1 function",
                                                                               f_one_max_ruggedness1_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "one_max_ruggedness1", number_of_variables);

    /* Compute best solution */
    f_one_max_ruggedness1_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler one_max_ruggedness1 problem.
 */
static IOHprofiler_problem_t *f_one_max_ruggedness1_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);

    problem = f_one_max_ruggedness1_allocate(dimension);
    if(instance == 1){
       problem = transform_obj_ruggedness1(problem);
    }
    else if(instance > 1 && instance <= 50){

        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_ruggedness1(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {   

        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);

        problem = transform_obj_ruggedness1(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        problem = transform_obj_ruggedness1(problem);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 23 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness2.c"
/**
 * @Onemax function
 */

/**
 * @file f_one_max_ruggedness2.c
 * @brief Implementation of the one_max_ruggedness2 function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness2.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness2.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness2.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness2.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness2.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_ruggedness2.c"
/**
 * @file transform_obj_ruggedness2.c
 * @brief Implementation of ruggedness2ing the objective value by the given offset.
 */
#ifndef TRANSFORM_OBJ_RUGGEDNESS2
#define TRANSFORM_OBJ_RUGGEDNESS2

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_ruggedness2.c"
#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_ruggedness2.c"

/**
 * @brief Data type for transform_obj_ruggedness2.
 */
typedef struct {
  double offset;
} transform_obj_ruggedness2_data_t;

double compute_ruggedness2(double y, size_t dimension){
  double ruggedness_y;
  int tempy=(int)(y+0.5);
  if(tempy == dimension){
    ruggedness_y = y;
  }
  else if(tempy < dimension && tempy % 2 == 0 && dimension % 2 == 0){
    ruggedness_y = y + 1.0;
  }
  else if(tempy < dimension && tempy % 2 == 0 && dimension % 2 != 0){
    ruggedness_y = (y - 1.0) > 0 ? (y - 1.0) : 0;
  }
  else if(tempy < dimension && tempy % 2 != 0 && dimension % 2 == 0){
    ruggedness_y = (y - 1.0) > 0 ? (y - 1.0) : 0;
  }
  else if(tempy < dimension && tempy % 2 != 0 && dimension % 2 != 0){
    ruggedness_y = y + 1.0;
  }
  else{
    ruggedness_y = y;
    assert(tempy <= dimension);
  }
  
  return ruggedness_y;
}

/**
 * @brief Evaluates the transformation.
 */
static void transform_obj_ruggedness2_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  transform_obj_ruggedness2_data_t *data;
  size_t i;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }

  data = (transform_obj_ruggedness2_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  IOHprofiler_evaluate_function(IOHprofiler_problem_transformed_get_inner_problem(problem), x, y);
  for (i = 0; i < problem->number_of_objectives; i++) {
      y[i] = compute_ruggedness2(y[i],problem->number_of_variables);
      problem->raw_fitness[i] = y[i];
      
  }
  assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_obj_ruggedness2(IOHprofiler_problem_t *inner_problem) {
  IOHprofiler_problem_t *problem;
  transform_obj_ruggedness2_data_t *data;
  size_t i;
  data = (transform_obj_ruggedness2_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, NULL, "transform_obj_ruggedness2");
  problem->evaluate_function = transform_obj_ruggedness2_evaluate;
  for (i = 0; i < problem->number_of_objectives; i++) {
      problem->best_value[i] = compute_ruggedness2(problem->best_value[i],problem->number_of_variables); 
  }
  return problem;
}
#endif
#line 25 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness2.c"
/**
 * @brief Implements the one_max_ruggedness2 function without connections to any IOHprofiler structures.
 */
static double f_one_max_ruggedness2_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        result += (double)x[i];
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_one_max_ruggedness2_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_one_max_ruggedness2_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic one_max_ruggedness2 problem.
 */
static IOHprofiler_problem_t *f_one_max_ruggedness2_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("one_max_ruggedness2 function",
                                                                               f_one_max_ruggedness2_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "one_max_ruggedness2", number_of_variables);

    /* Compute best solution */
    f_one_max_ruggedness2_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler one_max_ruggedness2 problem.
 */
static IOHprofiler_problem_t *f_one_max_ruggedness2_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);

    problem = f_one_max_ruggedness2_allocate(dimension);
    if(instance == 1){
       problem = transform_obj_ruggedness2(problem);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);

        problem = transform_obj_ruggedness2(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);

        problem = transform_obj_ruggedness2(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        problem = transform_obj_ruggedness2(problem);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 24 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness3.c"
/**
 * @Onemax function
 */

/**
 * @file f_one_max_ruggedness3.c
 * @brief Implementation of the one_max_ruggedness3 function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness3.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness3.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness3.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness3.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness3.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_ruggedness3.c"
/**
 * @file transform_obj_ruggedness3.c
 * @brief Implementation of ruggedness3ing the objective value by the given offset.
 */
#ifndef TRANSFORM_OBJ_RUGGEDNESS3
#define TRANSFORM_OBJ_RUGGEDNESS3

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_ruggedness3.c"
#line 12 "code-experiments/src/profiler/../suite/PBO/../../transform/transform_obj_ruggedness3.c"

/**
 * @brief Data type for transform_obj_ruggedness3.
 */
typedef struct {
  double offset;
  double *ruggedness_mapping;
} transform_obj_ruggedness3_data_t;


static void compute_ruggedness3(double * y, size_t dimension){
  size_t j,k;
  for(j = 1; j <= dimension/5; ++j){
    for(k = 0; k < 5; ++k){
      y[dimension-5*j+k] = (double)(dimension - 5 * j + (4-k));
    }
  }
  for(k = 0; k < dimension - dimension / 5 * 5; ++k){
    y[k] = dimension - dimension / 5 * 5 - 1 - k;
  }
  y[dimension] = (double)dimension;
}


/**
 * @brief Evaluates the transformation.
 */
static void transform_obj_ruggedness3_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
   transform_obj_ruggedness3_data_t *data;
  size_t i;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }

  data = (transform_obj_ruggedness3_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  IOHprofiler_evaluate_function(IOHprofiler_problem_transformed_get_inner_problem(problem), x, y);
  for (i = 0; i < problem->number_of_objectives; i++) {
      y[i] = data->ruggedness_mapping[(int)(y[i]+0.5)];
      problem->raw_fitness[i] = y[i];

  }
  assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_obj_ruggedness3(IOHprofiler_problem_t *inner_problem) {
   IOHprofiler_problem_t *problem;
  transform_obj_ruggedness3_data_t *data;
  
  size_t i;
  data = (transform_obj_ruggedness3_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->ruggedness_mapping = IOHprofiler_allocate_vector(inner_problem->number_of_variables+1);
  compute_ruggedness3(data->ruggedness_mapping,inner_problem->number_of_variables);


  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, NULL, "transform_obj_ruggedness3");
  problem->evaluate_function = transform_obj_ruggedness3_evaluate;

  for (i = 0; i < problem->number_of_objectives; i++) {
      problem->best_value[i] = (double)problem->number_of_variables;
  }
  
  return problem;
}
#line 25 "code-experiments/src/profiler/../suite/PBO/f_one_max_ruggedness3.c"


/**
 * @brief Implements the one_max_ruggedness3 function without connections to any IOHprofiler structures.
 */
static double f_one_max_ruggedness3_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        result += (double)x[i];
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_one_max_ruggedness3_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_one_max_ruggedness3_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic one_max_ruggedness3 problem.
 */
static IOHprofiler_problem_t *f_one_max_ruggedness3_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("one_max_ruggedness3 function",
                                                                               f_one_max_ruggedness3_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "one_max_ruggedness3", number_of_variables);

    /* Compute best solution */
    f_one_max_ruggedness3_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler one_max_ruggedness3 problem.
 */
static IOHprofiler_problem_t *f_one_max_ruggedness3_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);

    problem = f_one_max_ruggedness3_allocate(dimension);
    if(instance == 1){
       problem = transform_obj_ruggedness3(problem);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_ruggedness3(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_ruggedness3(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        problem = transform_obj_ruggedness3(problem);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 25 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy1.c"
/**
 * @Onemax function
 */

/**
 * @file f_leading_ones_dummy1.c
 * @brief Implementation of the leading_ones_dummy1 function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy1.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy1.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy1.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy1.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy1.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy1.c"
#line 26 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy1.c"
#line 27 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy1.c"
 
/**
 * @brief Implements the leading_ones_dummy1 function without connections to any IOHprofiler structures.
 */
static double f_leading_ones_dummy1_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        if (x[i] == 1.0) {
            result = (double)(i + 1);
        } else {
            break;
        }
    }
    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_leading_ones_dummy1_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_leading_ones_dummy1_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic leading_ones_dummy1 problem.
 */
static IOHprofiler_problem_t *f_leading_ones_dummy1_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("leading_ones_dummy1 function",
                                                                               f_leading_ones_dummy1_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "leading_ones_dummy1", number_of_variables);

    /* Compute best solution */
    f_leading_ones_dummy1_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler leading_ones_dummy1 problem.
 */
static IOHprofiler_problem_t *f_leading_ones_dummy1_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {

    int *z, *sigma,*dummy;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
   

    dummy = IOHprofiler_allocate_int_vector(1);
    problem = f_leading_ones_dummy1_allocate(dimension);
    
    if(instance == 1){
        dummy[0] = dimension * 0.5;
        problem = transform_vars_dummy(problem, dummy, 0);  
    }
    else if(instance > 1 && instance <= 50){
        dummy[0] = dimension * 0.5;
        
        z = IOHprofiler_allocate_int_vector(dummy[0]);
        IOHprofiler_compute_xopt(z,rseed,dummy[0]);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_dummy_xor(problem,dummy,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
        IOHprofiler_free_memory(z);
    }
    else if(instance > 50 && instance <= 100)
    {

        dummy[0] = dimension * 0.5;
        sigma = IOHprofiler_allocate_int_vector(dummy[0]);
        xins = IOHprofiler_allocate_vector(dummy[0]);
        IOHprofiler_compute_xopt_double(xins,rseed,dummy[0]);
        for(i = 0; i < dummy[0]; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dummy[0]; i++){
            t = (int)(xins[i] * (double)dummy[0]);
            assert(t >= 0 && t < dummy[0]);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_dummy_sigma(problem, dummy, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
        IOHprofiler_free_memory(sigma);
        IOHprofiler_free_memory(xins);
    } else {
        dummy[0] = dimension * 0.5;
        problem = transform_vars_dummy(problem, dummy, 0);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(dummy);
    
    return problem;
}
#line 26 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy2.c"
/**
 * @Onemax function
 */

/**
 * @file f_leading_ones_dummy2.c
 * @brief Implementation of the leading_ones_dummy2 function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy2.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy2.c"
#endif

#line 23 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy2.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy2.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy2.c"
#line 26 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy2.c"
#line 27 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy2.c"
#line 28 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_dummy2.c"
 
/**
 * @brief Implements the leading_ones_dummy2 function without connections to any IOHprofiler structures.
 */
static double f_leading_ones_dummy2_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        if (x[i] == 1.0) {
            result = (double)(i + 1);
        } else {
            break;
        }
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_leading_ones_dummy2_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_leading_ones_dummy2_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic leading_ones_dummy2 problem.
 */
static IOHprofiler_problem_t *f_leading_ones_dummy2_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("leading_ones_dummy2 function",
                                                                               f_leading_ones_dummy2_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "leading_ones_dummy2", number_of_variables);

    /* Compute best solution */
    f_leading_ones_dummy2_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler leading_ones_dummy2 problem.
 */
static IOHprofiler_problem_t *f_leading_ones_dummy2_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {

    int *z, *sigma,*dummy;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;

    dummy = IOHprofiler_allocate_int_vector(1);
    problem = f_leading_ones_dummy2_allocate(dimension);
    if(instance == 1){
        dummy[0] = dimension * 0.9;
        problem = transform_vars_dummy(problem, dummy, 0);   
    }
    else if(instance > 1 && instance <= 50){
        dummy[0] = dimension * 0.9;
        
        z = IOHprofiler_allocate_int_vector(dummy[0]);
        IOHprofiler_compute_xopt(z,rseed,dummy[0]);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_dummy_xor(problem,dummy,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
        IOHprofiler_free_memory(z);
    }
    else if(instance > 50 && instance <= 100)
    {

        dummy[0] = dimension * 0.9;
        sigma = IOHprofiler_allocate_int_vector(dummy[0]);
        xins = IOHprofiler_allocate_vector(dummy[0]);
        IOHprofiler_compute_xopt_double(xins,rseed,dummy[0]);
        for(i = 0; i < dummy[0]; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dummy[0]; i++){
            t = (int)(xins[i] * (double)dummy[0]);
            assert(t >= 0 && t < dummy[0]);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_dummy_sigma(problem, dummy, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
        IOHprofiler_free_memory(sigma);
        IOHprofiler_free_memory(xins);
    } else {
        dummy[0] = dimension * 0.9;
        problem = transform_vars_dummy(problem, dummy, 0);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(dummy);
    
    return problem;
}
#line 27 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_epistasis.c"
/**
 * @Onemax function
 */

/**
 * @file f_leading_ones_epistasis.c
 * @brief Implementation of the leading_ones_epistasis function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_epistasis.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_epistasis.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_epistasis.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_epistasis.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_epistasis.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_epistasis.c"
/**
 * @brief Implements the leading_ones_epistasis function without connections to any IOHprofiler structures.
 */
static double f_leading_ones_epistasis_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        if (x[i] == 1.0) {
            result = (double)(i + 1);
        } else {
            break;
        }
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_leading_ones_epistasis_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_leading_ones_epistasis_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic leading_ones_epistasis problem.
 */
static IOHprofiler_problem_t *f_leading_ones_epistasis_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("leading_ones_epistasis function",
                                                                               f_leading_ones_epistasis_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "leading_ones_epistasis", number_of_variables);

    /* Compute best solution */
    f_leading_ones_epistasis_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler leading_ones_epistasis problem.
 */
static IOHprofiler_problem_t *f_leading_ones_epistasis_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {

    int * epistasis;
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);

    epistasis = IOHprofiler_allocate_int_vector(1);
    problem = f_leading_ones_epistasis_allocate(dimension);
    if(instance == 1){
        epistasis[0] = 4;
        problem = transform_vars_epistasis(problem, epistasis,0);
    }
    else if(instance > 1 && instance <= 50){
        epistasis[0] = 4;


        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_vars_epistasis_xor(problem,epistasis, z, 0);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        epistasis[0] = 4;

        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_epistasis_sigma(problem,epistasis, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        epistasis[0] = 4;
        problem = transform_vars_epistasis(problem, epistasis,0);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(epistasis);
    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 28 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_neutrality.c"
/**
 * @Onemax function
 */

/**
 * @file f_leading_ones_neutrality.c
 * @brief Implementation of the leading_ones_neutrality function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_neutrality.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_neutrality.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_neutrality.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_neutrality.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_neutrality.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_neutrality.c"
/**
 * @brief Implements the leading_ones_neutrality function without connections to any IOHprofiler structures.
 */
static double f_leading_ones_neutrality_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        if (x[i] == 1.0) {
            result = (double)(i + 1);
        } else {
            break;
        }
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_leading_ones_neutrality_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_leading_ones_neutrality_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic leading_ones_neutrality problem.
 */
static IOHprofiler_problem_t *f_leading_ones_neutrality_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("leading_ones_neutrality function",
                                                                               f_leading_ones_neutrality_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "leading_ones_neutrality", number_of_variables);

    /* Compute best solution */
    f_leading_ones_neutrality_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler leading_ones_neutrality problem.
 */
static IOHprofiler_problem_t *f_leading_ones_neutrality_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {


    int * neutrality;
    int *z, *sigma;
    int temp,t,new_dim;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
   
    neutrality = IOHprofiler_allocate_int_vector(1);
    problem = f_leading_ones_neutrality_allocate(dimension);
    if(instance == 1){
        neutrality[0] = 3;
        problem = transform_vars_neutrality(problem, neutrality, 0);
    }
    else if(instance > 1 && instance <= 50){
        neutrality[0] = 3;
        new_dim = dimension/neutrality[0];
        z = IOHprofiler_allocate_int_vector(new_dim);

        IOHprofiler_compute_xopt(z,rseed,new_dim);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_vars_neutrality_xor(problem, neutrality,z, 0);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
        IOHprofiler_free_memory(z);
    }
    else if(instance > 50 && instance <= 100)
    {
        neutrality[0] = 3;
        new_dim = dimension / 3;
        sigma = IOHprofiler_allocate_int_vector(new_dim);
        xins = IOHprofiler_allocate_vector(new_dim);

        
        IOHprofiler_compute_xopt_double(xins,rseed,new_dim);
        for(i = 0; i < new_dim; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < new_dim; i++){
            t = (int)(xins[i] * (double)new_dim);
            assert(t >= 0 && t < new_dim);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        assert(a <= 5.0 && a >= 0.2);

        problem = transform_vars_neutrality_sigma(problem, neutrality,sigma, 0);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);

        IOHprofiler_free_memory(sigma);
        IOHprofiler_free_memory(xins);
    } else {
        neutrality[0] = 3;
        problem = transform_vars_neutrality(problem, neutrality, 0);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(neutrality);


    return problem;
}
#line 29 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness1.c"
/**
 * @Onemax function
 */

/**
 * @file f_leading_ones_ruggedness1.c
 * @brief Implementation of the leading_ones_ruggedness1 function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness1.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness1.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness1.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness1.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness1.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness1.c"
/**
 * @brief Implements the leading_ones_ruggedness1 function without connections to any IOHprofiler structures.
 */
static double f_leading_ones_ruggedness1_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        if (x[i] == 1.0) {
            result = (double)(i + 1);
        } else {
            break;
        }
    }
    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_leading_ones_ruggedness1_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_leading_ones_ruggedness1_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic leading_ones_ruggedness1 problem.
 */
static IOHprofiler_problem_t *f_leading_ones_ruggedness1_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("leading_ones_ruggedness1 function",
                                                                               f_leading_ones_ruggedness1_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "leading_ones_ruggedness1", number_of_variables);

    /* Compute best solution */
    f_leading_ones_ruggedness1_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler leading_ones_ruggedness1 problem.
 */
static IOHprofiler_problem_t *f_leading_ones_ruggedness1_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);

    problem = f_leading_ones_ruggedness1_allocate(dimension);
    if(instance == 1){
       problem = transform_obj_ruggedness1(problem);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_ruggedness1(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_ruggedness1(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 30 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness2.c"
/**
 * @Onemax function
 */

/**
 * @file f_leading_ones_ruggedness2.c
 * @brief Implementation of the leading_ones_ruggedness2 function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness2.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness2.c"
#endif

#line 23 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness2.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness2.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness2.c"
#line 26 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness2.c"
/**
 * @brief Implements the leading_ones_ruggedness2 function without connections to any IOHprofiler structures.
 */
static double f_leading_ones_ruggedness2_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        if (x[i] == 1.0) {
            result = (double)(i + 1);
        } else {
            break;
        }
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_leading_ones_ruggedness2_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_leading_ones_ruggedness2_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic leading_ones_ruggedness2 problem.
 */
static IOHprofiler_problem_t *f_leading_ones_ruggedness2_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("leading_ones_ruggedness2 function",
                                                                               f_leading_ones_ruggedness2_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "leading_ones_ruggedness2", number_of_variables);

    /* Compute best solution */
    f_leading_ones_ruggedness2_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler leading_ones_ruggedness2 problem.
 */
static IOHprofiler_problem_t *f_leading_ones_ruggedness2_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);

    problem = f_leading_ones_ruggedness2_allocate(dimension);
    if(instance == 1){
       problem = transform_obj_ruggedness2(problem);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_ruggedness2(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_ruggedness2(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 31 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness3.c"
/**
 * @Onemax function
 */

/**
 * @file f_leading_ones_ruggedness3.c
 * @brief Implementation of the leading_ones_ruggedness3 function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness3.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 20 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness3.c"
#endif
#line 22 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness3.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness3.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness3.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_leading_ones_ruggedness3.c"
/**
 * @brief Implements the leading_ones_ruggedness3 function without connections to any IOHprofiler structures.
 */
static double f_leading_ones_ruggedness3_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    double result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0.0;
    for (i = 0; i < number_of_variables; ++i) {
        if (x[i] == 1.0) {
            result = (double)(i + 1);
        } else {
            break;
        }
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_leading_ones_ruggedness3_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_leading_ones_ruggedness3_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic leading_ones_ruggedness3 problem.
 */
static IOHprofiler_problem_t *f_leading_ones_ruggedness3_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("leading_ones_ruggedness3 function",
                                                                               f_leading_ones_ruggedness3_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "leading_ones_ruggedness3", number_of_variables);

    /* Compute best solution */
    f_leading_ones_ruggedness3_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler leading_ones_ruggedness3 problem.
 */
static IOHprofiler_problem_t *f_leading_ones_ruggedness3_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {
    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);

    problem = f_leading_ones_ruggedness3_allocate(dimension);
    if(instance == 1){
       problem = transform_obj_ruggedness3(problem);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_ruggedness3(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_ruggedness3(problem);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 32 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_ising_1D.c"
/**
 * @file f_ising_1D.c
 * @brief Implementation of the ising_1D function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 12 "code-experiments/src/profiler/../suite/PBO/f_ising_1D.c"
#endif

#ifndef IOHPROFILER_UTILITIES
#define IOHPROFILER_UTILITIES
#line 17 "code-experiments/src/profiler/../suite/PBO/f_ising_1D.c"
#endif

#line 20 "code-experiments/src/profiler/../suite/PBO/f_ising_1D.c"
#line 21 "code-experiments/src/profiler/../suite/PBO/f_ising_1D.c"
#line 22 "code-experiments/src/profiler/../suite/PBO/f_ising_1D.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_ising_1D.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_ising_1D.c"


/**
 * @brief Implements the Ising one dimension function without connections to any IOHprofiler structures.
 */


int modulo_ising_1D(int x,int N){
    return (x % N + N) %N;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static int f_ising_1D_raw(const int *x, const size_t number_of_variables) {
    int result= 0;
    size_t i;
    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;

    for (i = 0; i < number_of_variables; ++i) {
        int first_neig=x[modulo_ising_1D((i+1), number_of_variables)];
        int second_neig=x[modulo_ising_1D((i -1) , number_of_variables)];

        result += (x[i] *first_neig) + ((1- x[i])*(1- first_neig));
        result += (x[i] *second_neig) + ((1- x[i])*(1- second_neig));
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_ising_1D_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_ising_1D_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic ising_1D problem.
 */
static IOHprofiler_problem_t *f_ising_1D_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("ising_1D function",
                                                                               f_ising_1D_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "ising_1D", number_of_variables);

    /* Compute best solution */
    f_ising_1D_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler ising_1D problem.
 */
static IOHprofiler_problem_t *f_ising_1D_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {


    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);
    problem = f_ising_1D_allocate(dimension);

    if(instance == 1){
        for(i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem,z,0);
        problem = transform_obj_shift(problem,a);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 33 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_ising_2D.c"
/**
 * @file f_ising_2D.c
 * @brief Implementation of the ising_2D function and problem.
 */

#include <assert.h>
#include <stdio.h>
#include <math.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 13 "code-experiments/src/profiler/../suite/PBO/f_ising_2D.c"
#endif

#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 18 "code-experiments/src/profiler/../suite/PBO/f_ising_2D.c"
#endif

#line 21 "code-experiments/src/profiler/../suite/PBO/f_ising_2D.c"
#line 22 "code-experiments/src/profiler/../suite/PBO/f_ising_2D.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_ising_2D.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_ising_2D.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_ising_2D.c"

/**
 * @brief Implements the ising_2D function without connections to any IOHprofiler structures.
 */

int modulo_ising_2D(int x,int N){
    return (x % N + N) %N;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static int f_ising_2D_raw(const int *x, const size_t number_of_variables) {
    if(floor(sqrt(number_of_variables))!=sqrt(number_of_variables)){
      fprintf(stderr, "Number of parameters in the Ising square problem must be a square number\n");
      exit(-1);
    }

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    size_t i,j,neig;
    int result= 0;
    int neighbors[4];
    int lattice_size = (int)sqrt(number_of_variables);
    int (*spin_array)[lattice_size] = (int (*)[lattice_size])x;

    for (i = 0; i < lattice_size; ++i) {
           for (j = 0; j < lattice_size; ++j) {
                neighbors[0]  = spin_array[modulo_ising_2D(i - 1, lattice_size)][j];
                neighbors[1]  = spin_array[modulo_ising_2D(i + 1, lattice_size)][j];
                neighbors[2]  = spin_array[i][modulo_ising_2D((j - 1) , lattice_size)];
                neighbors[3]  = spin_array[i][modulo_ising_2D((j + 1) , lattice_size)];

                for (neig=0; neig<4; neig++) {
                    result+= (spin_array[i][j] * neighbors[neig]) + ((1- spin_array[i][j])*(1- neighbors[neig]));
                }
           }
    }

    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_ising_2D_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_ising_2D_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic ising_2D problem.
 */
static IOHprofiler_problem_t *f_ising_2D_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("ising_2D function",
                                                                               f_ising_2D_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "ising_2D", number_of_variables);

    /* Compute best solution */
    f_ising_2D_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler ising_2D problem.
 */
static IOHprofiler_problem_t *f_ising_2D_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {


    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);
    problem = f_ising_2D_allocate(dimension);

    if(instance == 1){
        for(i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem,z,0);
        problem = transform_obj_shift(problem,a);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 34 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_ising_triangle.c"
/**
 * @ising_triangle function
 */

/**
 * @file f_ising_triangle.c
 * @brief Implementation of the ising_triangle function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 16 "code-experiments/src/profiler/../suite/PBO/f_ising_triangle.c"
#endif

#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 21 "code-experiments/src/profiler/../suite/PBO/f_ising_triangle.c"
#endif

#line 24 "code-experiments/src/profiler/../suite/PBO/f_ising_triangle.c"
#line 25 "code-experiments/src/profiler/../suite/PBO/f_ising_triangle.c"
#line 26 "code-experiments/src/profiler/../suite/PBO/f_ising_triangle.c"
#line 27 "code-experiments/src/profiler/../suite/PBO/f_ising_triangle.c"
#line 28 "code-experiments/src/profiler/../suite/PBO/f_ising_triangle.c"

/**
 * @brief Implements the Ising_triangle function without connections to any IOHprofiler structures.
 */
int modulo_ising_triangle(int x,int N){
    return (x % N + N) %N;
}


/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */

static int f_ising_triangle_raw(const int *x, const size_t number_of_variables) {

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    size_t i,j,neig;
    int result = 0;
    int neighbors[6];
    int lattice_size = (int)sqrt(number_of_variables);
    int (*spin_array)[lattice_size] = (int (*)[lattice_size])x;

    for (i = 0; i < lattice_size; ++i) {
           for (j = 0; j < lattice_size; ++j) {
                neighbors[0] = spin_array[modulo_ising_triangle((i - 1), lattice_size)][j] ;
                neighbors[1] = spin_array[modulo_ising_triangle((i + 1) , lattice_size)][j] ;
                neighbors[2] = spin_array[i][modulo_ising_triangle((j - 1) , lattice_size)] ;
                neighbors[3] = spin_array[i][modulo_ising_triangle((i + 1) , lattice_size)] ;
                neighbors[4] = spin_array[modulo_ising_triangle((i - 1) , lattice_size)][modulo_ising_triangle((j - 1) , lattice_size)] ;
                neighbors[5] = spin_array[modulo_ising_triangle((i + 1) , lattice_size)][modulo_ising_triangle((j + 1) , lattice_size)];

                for (neig=0; neig<6; neig++) {
                    result+= (spin_array[i][j] * neighbors[neig]) + ((1- spin_array[i][j])*(1- neighbors[neig]));
                }
           }
    }

    return result;
}



/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_ising_triangle_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_ising_triangle_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic ising_triangle problem.
 */
static IOHprofiler_problem_t *f_ising_triangle_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("ising_triangle function",
                                                                               f_ising_triangle_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "ising_triangle", number_of_variables);

    /* Compute best solution */
    f_ising_triangle_evaluate(problem, problem->best_parameter, problem->best_value);
    return problem;
}

/**
 * @brief Creates the IOHprofiler ising_triangle problem.
 */
static IOHprofiler_problem_t *f_ising_triangle_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {


    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);
    problem = f_ising_triangle_allocate(dimension);

    if(instance == 1){
        for(i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem,z,0);
        problem = transform_obj_shift(problem,a);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 35 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_N_queens.c"

/**
 * @file f_N_queens.c
 * @brief Implementation of the N_queens function and problem.
 */

#include <assert.h>
#include <stdio.h>
#include <math.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 14 "code-experiments/src/profiler/../suite/PBO/f_N_queens.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 18 "code-experiments/src/profiler/../suite/PBO/f_N_queens.c"
#endif
#line 20 "code-experiments/src/profiler/../suite/PBO/f_N_queens.c"
#line 21 "code-experiments/src/profiler/../suite/PBO/f_N_queens.c"
#line 22 "code-experiments/src/profiler/../suite/PBO/f_N_queens.c"
#line 23 "code-experiments/src/profiler/../suite/PBO/f_N_queens.c"
#line 24 "code-experiments/src/profiler/../suite/PBO/f_N_queens.c"

/**
 * @brief Implements the N Queens one dimension function without connections to any IOHprofiler structures.
 */

static double max(double element1 , double element2) {
    if (element1>element2) return element1;
    else return element2;
}
/**
 * @brief Implements the N_queens function without connections to any IOHprofiler structures.
 */
static double f_N_queens_raw(const int *x, const size_t number_of_variables) {
    if(floor(sqrt(number_of_variables))!=sqrt(number_of_variables)){
      fprintf(stderr, "Number of parameters in the N Queen problem must be a square number\n");
      exit(-1);
    }

    double result;
    int index,j,i,k,l;
    int N_queens=sqrt(number_of_variables);
    int number_of_queens_on_board = 0;
    double k_penalty=0.0;
    double l_penalty =0.0;
    double raws_penalty=0.0;
    double columns_penalty=0.0;
    int indx=0;
    float C = N_queens;
    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;


    for (index=0; index<number_of_variables; index++){
        if (x[index]==1){
            number_of_queens_on_board+=1;
        }
    }

    for(j=1; j <=N_queens; j++){
        double sum_column = 0.0;
        for(i=1; i<=N_queens; i++){
            indx=((i-1)*N_queens) + ((j-1)%N_queens);
            sum_column+=(double)x[indx];
        }
        columns_penalty+=max(0.0, (-1.0+sum_column));
    }

    for(i=1; i<=N_queens; i++){
        double sum_raw = 0.0;
        double sum_k = 0.0;
        double sum_l = 0.0;
        for(j=1; j <=N_queens; j++){
            indx=((i-1)*N_queens) + ((j-1)%N_queens);
            sum_raw+=(double)x[indx];
        }
        raws_penalty+=max(0.0, (-1.0+sum_raw));
    }

    for(k=2-N_queens; k<=N_queens-2; k++){
        double sum_k=0.0;
        for(i=1; i<=N_queens; i++){
            if (k+i>=1 && k+i<=N_queens){
                indx=((i-1)*N_queens) + ((k+i-1)%N_queens);
                sum_k += (double)x[indx];
            }
        }
        k_penalty+=max(0.0, (-1.0+sum_k));
    }
    for(l=3; l<=2*N_queens-1; l++){
        double sum_l=0.0;
        for(i=1; i<=N_queens; i++){
            if (l-i>=1 && l-i<=N_queens){
                indx=((i-1)*N_queens) + ((l-i-1)%N_queens);
                sum_l += (double)x[indx];
            }
        }
        l_penalty+=max(0.0, (-1.0+sum_l));
    }
    result = (double) (number_of_queens_on_board - (C*raws_penalty) - (C*columns_penalty) -(C*k_penalty) - (C*l_penalty));
    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_N_queens_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_N_queens_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic N_queens problem.
 */
static IOHprofiler_problem_t *f_N_queens_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("N_queens function",
                                                                               f_N_queens_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "N_queens", number_of_variables);

    /* Compute best solution */
    /*f_N_queens_evaluate(problem, problem->best_parameter, problem->best_value);*/
    problem->best_value[0] = sqrt(number_of_variables);
    return problem;
}

/**
 * @brief Creates the IOHprofiler N_queens problem.
 */
static IOHprofiler_problem_t *f_N_queens_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {


    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);
    problem = f_N_queens_allocate(dimension);

    if(instance == 1){
        for(i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem,z,0);
        problem = transform_obj_shift(problem,a);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 36 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"
#line 1 "code-experiments/src/profiler/../suite/PBO/f_MIS.c"
/**
 * @file f_MIS.c
 * @brief Implementation of the Maximum Independent Set function and problem.
 */

#include <assert.h>
#include <stdio.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 12 "code-experiments/src/profiler/../suite/PBO/f_MIS.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 16 "code-experiments/src/profiler/../suite/PBO/f_MIS.c"
#endif
#line 18 "code-experiments/src/profiler/../suite/PBO/f_MIS.c"
#line 19 "code-experiments/src/profiler/../suite/PBO/f_MIS.c"
#line 20 "code-experiments/src/profiler/../suite/PBO/f_MIS.c"
#line 21 "code-experiments/src/profiler/../suite/PBO/f_MIS.c"
#line 22 "code-experiments/src/profiler/../suite/PBO/f_MIS.c"

/**
 * @brief Implements the Maximum Independent Set function without connections to any IOHprofiler structures.
 */

 static int isEdge(int i, int j, size_t problem_size) {
    if (i!=problem_size/2 && j==i+1){return 1;}
    else if (i<=(problem_size/2)-1 && j==i+(problem_size/2)+1 ){return 1;}
    else if (i<=(problem_size/2) && i>=2 && j==i+(problem_size/2)-1){return 1;}
    else {return 0;}
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static int f_MIS_raw(const int *x, const size_t number_of_variables) {

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    int i, j,index;
    int result= 0;
    int num_of_ones=0;
    int sum_edges_in_the_set=0;
    int number_of_variables_even=number_of_variables;

    if (number_of_variables%2!=0){
        number_of_variables_even=number_of_variables-1;
    }

    int ones_array[number_of_variables_even+1];

    for (index=0; index<number_of_variables_even; index++){
        if (x[index]==1){
            ones_array[num_of_ones] = index;
            num_of_ones+=1;
        }
    }

    for (i=0; i<num_of_ones; i++){
        for (j=i+1; j<num_of_ones; j++){
            if(isEdge(ones_array[i]+1,ones_array[j]+1,number_of_variables_even)==1){
                sum_edges_in_the_set+=1;
            }
        }
    }
    result=num_of_ones - (number_of_variables_even*sum_edges_in_the_set);
    return result;
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_MIS_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_MIS_raw(x, problem->number_of_variables);
    assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Allocates the basic MIS problem.
 */
static IOHprofiler_problem_t *f_MIS_allocate(const size_t number_of_variables) {
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars("MIS function",
                                                                               f_MIS_evaluate, NULL, number_of_variables, 0, 1, 1);

    IOHprofiler_problem_set_id(problem, "%s_d%02lu", "MIS", number_of_variables);

    /* Compute best solution */
    /*f_MIS_evaluate(problem, problem->best_parameter, problem->best_value);*/
    problem->best_value[0] = number_of_variables / 2 + 1.0;
    return problem;
}

/**
 * @brief Creates the IOHprofiler MIS problem.
 */
static IOHprofiler_problem_t *f_MIS_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template) {


    int *z, *sigma;
    int temp,t;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem;
    z = IOHprofiler_allocate_int_vector(dimension);
    sigma = IOHprofiler_allocate_int_vector(dimension);
    xins = IOHprofiler_allocate_vector(dimension);
    problem = f_MIS_allocate(dimension);

    if(instance == 1){
        for(i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem,z,0);
        problem = transform_obj_shift(problem,a);
    }
    else if(instance > 1 && instance <= 50){
        IOHprofiler_compute_xopt(z,rseed,dimension);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        problem = transform_vars_xor(problem,z,0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    }
    else if(instance > 50 && instance <= 100)
    {
        IOHprofiler_compute_xopt_double(xins,rseed,dimension);
        for(i = 0; i < dimension; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < dimension; i++){
            t = (int)(xins[i] * (double)dimension);
            assert(t >= 0 && t < dimension);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        problem = transform_vars_sigma(problem, sigma, 0);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
    } else {
        for (i = 0; i < dimension; i++)
            z[i] = 0;
        a = 0.0;
        problem = transform_vars_xor(problem, z, 0);
        problem = transform_obj_shift(problem, a);
    }
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");

    IOHprofiler_free_memory(z);
    IOHprofiler_free_memory(sigma);
    IOHprofiler_free_memory(xins);
    return problem;
}
#line 37 "code-experiments/src/profiler/../suite/PBO/suite_PBO.c"


static IOHprofiler_suite_t *IOHprofiler_suite_allocate(const char *suite_name,
                                                       const size_t number_of_functions,
                                                       const size_t number_of_dimensions,
                                                       const size_t *dimensions,
                                                       const char *default_instances);

/**
 * @brief Sets the dimensions and default instances for the IOHprofiler suite.
 */
static IOHprofiler_suite_t *suite_PBO_initialize(void) {
    IOHprofiler_suite_t *suite;
    size_t i;
    const char *suite_name = "PBO";
    const size_t number_of_functions = 24;

    size_t dimensions[20000];

    const size_t number_of_dimensions = sizeof(dimensions) / sizeof(dimensions[0]);
    for (i = 0; i < number_of_dimensions; ++i){
        dimensions[i] = i + 1;
    }
    /* IMPORTANT: Make sure to change the default instance for every new workshop! */
    suite = IOHprofiler_suite_allocate(suite_name, number_of_functions, number_of_dimensions, dimensions, "year: 2018");

    return suite;
}

/**
 * @brief Sets the instances associated with years for the IOHprofiler suite.
 */
static const char *suite_PBO_get_instances_by_year(const int year) {
    if (year == 2018) {
        return "1-100";
    } else {
        IOHprofiler_error("suite_PBO_get_instances_by_year(): year %d not defined for suite_IOHprofiler", year);
        return NULL;
    }
}

/**
 * @brief Creates and returns a IOHprofiler problem without needing the actual IOHprofiler suite.
 *
 * Useful for other suites as well (see for example suite_biobj.c).
 */
static IOHprofiler_problem_t *PBO_get_problem(const size_t function,
                                              const size_t dimension,
                                              const size_t instance) {
    IOHprofiler_problem_t *problem = NULL;

    const char *problem_id_template = "PBO_f%03lu_i%02lu_d%02lu";
    const char *problem_name_template = "PBO suite problem f%lu instance %lu in %luD";

    const long rseed = (long)(function + 10000 * instance);

    if (function == 1) {
        problem = f_one_max_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                         problem_id_template, problem_name_template);
    } else if (function == 2) {
        problem = f_leading_ones_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                              problem_id_template, problem_name_template);
    } else if (function == 3) {
        problem = f_linear_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                      problem_id_template, problem_name_template);
    } else if (function == 4) {
        problem = f_one_max_dummy1_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 5) {
        problem = f_one_max_dummy2_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 6) {
        problem = f_one_max_neutrality_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 7) {
        problem = f_one_max_epistasis_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 8) {
        problem = f_one_max_ruggedness1_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 9) {
        problem = f_one_max_ruggedness2_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 10) {
        problem = f_one_max_ruggedness3_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 11) {
        problem = f_leading_ones_dummy1_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 12) {
        problem = f_leading_ones_dummy2_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 13) {
        problem = f_leading_ones_neutrality_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 14) {
        problem = f_leading_ones_epistasis_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 15) {
        problem = f_leading_ones_ruggedness1_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 16) {
        problem = f_leading_ones_ruggedness2_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 17) {
        problem = f_leading_ones_ruggedness3_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 18) {
        problem = f_labs_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 19) {
        problem = f_ising_1D_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 20) {
        problem = f_ising_2D_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 21) {
        problem = f_ising_triangle_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 22) {
        problem = f_MIS_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template);
    } else if (function == 23) {
        problem = f_N_queens_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template); 
    } else if (function == 24) {
        problem = f_jump_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                        problem_id_template, problem_name_template); 
    }else {
        IOHprofiler_error("get_IOHprofiler_problem(): cannot retrieve problem f%lu instance %lu in %luD",
                          (unsigned long)function, (unsigned long)instance, (unsigned long)dimension);
        return NULL; /* Never reached */
    }

    return problem;
}

/**
 * @brief Returns the problem from the IOHprofiler suite that corresponds to the given parameters.
 *
 * @param suite The IOHprofiler suite.
 * @param function_idx Index of the function (starting from 0).
 * @param dimension_idx Index of the dimension (starting from 0).
 * @param instance_idx Index of the instance (starting from 0).
 * @return The problem that corresponds to the given parameters.
 */
static IOHprofiler_problem_t *suite_PBO_get_problem(IOHprofiler_suite_t *suite,
                                                    const size_t function_idx,
                                                    const size_t dimension_idx,
                                                    const size_t instance_idx) {
    IOHprofiler_problem_t *problem = NULL;

    const size_t function = suite->functions[function_idx];
    const size_t dimension = suite->dimensions[dimension_idx];
    const size_t instance = suite->instances[instance_idx];

    problem = PBO_get_problem(function, dimension, instance);

    problem->suite_dep_function = function;
    problem->suite_dep_instance = instance;
    problem->suite_dep_index = IOHprofiler_suite_encode_problem_index(suite, function_idx, dimension_idx, instance_idx);

    return problem;
}
#line 21 "code-experiments/src/profiler/IOHprofiler_suite.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/suite_WModel.c"
/**
 * @file suite_IOHprofiler.c
 * @brief Implementation of the IOHprofiler suite for W_Model
 */
#ifndef SUITE_WMODEL
#define SUITE_WMODEL
#line 1 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler.h"
/**
 * @file IOHprofiler.h
 * @brief All public IOHprofiler functions and variables are defined in this file.
 *
 * It is the authoritative reference, if any function deviates from the documented behavior it is considered
 * a bug. See the function definitions for their detailed descriptions.
 */

#ifndef __IOHprofiler_H__
#define __IOHprofiler_H__

#include <stddef.h>

/* Definitions of some 32 and 64-bit types (used by the random number generator) */
#ifdef _MSC_VER
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

/* Include definition for NAN among other things */
#include <float.h>
#include <math.h>
#ifndef NAN
/** @brief Definition of NAN to be used only if undefined by the included headers */
#define NAN 8.8888e88
#endif
#ifndef isnan
/** @brief Definition of isnan to be used only if undefined by the included headers */
#define isnan(x) (0)
#endif
#ifndef INFINITY
/** @brief Definition of INFINITY to be used only if undefined by the included headers */
#define INFINITY 1e22
/* why not using 1e99? */
#endif
#ifndef isinf
/** @brief Definition of isinf to be used only if undefined by the included headers */
#define isinf(x) (0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief IOHprofiler's version.
 *
 * Automatically updated by do.py.
 */
/**@{*/
static const char IOHprofiler_version[32] = "";
/**@}*/

/***********************************************************************************************************/
/**
 * @brief IOHprofiler's own pi constant. Simplifies the case, when the value of pi changes.
 */
/**@{*/
static const double IOHprofiler_pi = 3.14159265358979323846;
/**@}*/

/***********************************************************************************************************/

/** @brief Logging level type. */
typedef enum {
    IOHprofiler_ERROR,   /**< @brief only error messages are output */
    IOHprofiler_WARNING, /**< @brief error and warning messages are output */
    IOHprofiler_INFO,    /**< @brief error, warning and info messages are output */
    IOHprofiler_DEBUG    /**< @brief error, warning, info and debug messages are output */
} IOHprofiler_log_level_type_e;

/***********************************************************************************************************/

/** @brief Structure containing a IOHprofiler problem. */
struct IOHprofiler_problem_s;

/**
 * @brief The IOHprofiler problem type.
 *
 * See IOHprofiler_problem_s for more information on its fields. */
typedef struct IOHprofiler_problem_s IOHprofiler_problem_t;

/** @brief Structure containing a IOHprofiler suite. */
struct IOHprofiler_suite_s;

/**
 * @brief The IOHprofiler suite type.
 *
 * See IOHprofiler_suite_s for more information on its fields. */
typedef struct IOHprofiler_suite_s IOHprofiler_suite_t;

/** @brief Structure containing a IOHprofiler observer. */
struct IOHprofiler_observer_s;

/**
 * @brief The IOHprofiler observer type.
 *
 * See IOHprofiler_observer_s for more information on its fields. */
typedef struct IOHprofiler_observer_s IOHprofiler_observer_t;

/** @brief Structure containing a IOHprofiler archive. */
struct IOHprofiler_archive_s;

/**
 * @brief The IOHprofiler archive type.
 *
 * See IOHprofiler_archive_s for more information on its fields. */
typedef struct IOHprofiler_archive_s IOHprofiler_archive_t;

/** @brief Structure containing a IOHprofiler random state. */
struct IOHprofiler_random_state_s;

/**
 * @brief The IOHprofiler random state type.
 *
 * See IOHprofiler_random_state_s for more information on its fields. */
typedef struct IOHprofiler_random_state_s IOHprofiler_random_state_t;

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler suite
 */
/**@{*/

/**
 * @brief Constructs a IOHprofiler suite.
 */
IOHprofiler_suite_t *IOHprofiler_suite(const char *suite_name, const char *suite_instance, const char *suite_options,int number, char** layer_param,char * temp_dim);

/**
 * @brief Frees the given suite.
 */
void IOHprofiler_suite_free(IOHprofiler_suite_t *suite);

/**
 * @brief Returns the next (observed) problem of the suite or NULL if there is no next problem left.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_next_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 *
 * @returns The current problem of the suite.
 */
IOHprofiler_problem_t *IOHprofiler_suite_reset_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 * @brief Returns the problem of the suite defined by problem_index.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_problem(IOHprofiler_suite_t *suite, const size_t problem_index);

/**
 * @brief Returns the number of problems in the given suite.
 */
size_t IOHprofiler_suite_get_number_of_problems(const IOHprofiler_suite_t *suite);

/**
 * @brief Returns the function number in the suite in position function_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_function_from_function_index(const IOHprofiler_suite_t *suite, const size_t function_idx);

/**
 * @brief Returns the dimension number in the suite in position dimension_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_dimension_from_dimension_index(const IOHprofiler_suite_t *suite, const size_t dimension_idx);

/**
 * @brief Returns the instance number in the suite in position instance_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_instance_from_instance_index(const IOHprofiler_suite_t *suite, const size_t instance_idx);
/**@}*/

/**
 * @name Encoding/decoding problem index
 *
 * General schema for encoding/decoding a problem index. Note that the index depends on the number of
 * instances a suite is defined with (it should be called a suite-instance-depending index...).
 * Also, while functions, instances and dimensions start from 1, function_idx, instance_idx and dimension_idx
 * as well as suite_dep_index start from 0!
 *
 * Showing an example with 2 dimensions (2, 3), 5 instances (6, 7, 8, 9, 10) and 2 functions (1, 2):
 *
   \verbatim
   index | instance | function | dimension
   ------+----------+----------+-----------
       0 |        6 |        1 |         2
       1 |        7 |        1 |         2
       2 |        8 |        1 |         2
       3 |        9 |        1 |         2
       4 |       10 |        1 |         2
       5 |        6 |        2 |         2
       6 |        7 |        2 |         2
       7 |        8 |        2 |         2
       8 |        9 |        2 |         2
       9 |       10 |        2 |         2
      10 |        6 |        1 |         3
      11 |        7 |        1 |         3
      12 |        8 |        1 |         3
      13 |        9 |        1 |         3
      14 |       10 |        1 |         3
      15 |        6 |        2 |         2
      16 |        7 |        2 |         3
      17 |        8 |        2 |         3
      18 |        9 |        2 |         3
      19 |       10 |        2 |         3

   index | instance_idx | function_idx | dimension_idx
   ------+--------------+--------------+---------------
       0 |            0 |            0 |             0
       1 |            1 |            0 |             0
       2 |            2 |            0 |             0
       3 |            3 |            0 |             0
       4 |            4 |            0 |             0
       5 |            0 |            1 |             0
       6 |            1 |            1 |             0
       7 |            2 |            1 |             0
       8 |            3 |            1 |             0
       9 |            4 |            1 |             0
      10 |            0 |            0 |             1
      11 |            1 |            0 |             1
      12 |            2 |            0 |             1
      13 |            3 |            0 |             1
      14 |            4 |            0 |             1
      15 |            0 |            1 |             1
      16 |            1 |            1 |             1
      17 |            2 |            1 |             1
      18 |            3 |            1 |             1
      19 |            4 |            1 |             1
   \endverbatim
 */
/**@{*/
/**
 * @brief Computes the index of the problem in the suite that corresponds to the given function, dimension
 * and instance indices.
 */
size_t IOHprofiler_suite_encode_problem_index(const IOHprofiler_suite_t *suite,
                                              const size_t function_idx,
                                              const size_t dimension_idx,
                                              const size_t instance_idx);

/**
 * @brief Computes the function, dimension and instance indexes of the problem with problem_index in the
 * given suite.
 */
void IOHprofiler_suite_decode_problem_index(const IOHprofiler_suite_t *suite,
                                            const size_t problem_index,
                                            size_t *function_idx,
                                            size_t *dimension_idx,
                                            size_t *instance_idx);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler observer
 */
/**@{*/
/**
 * @brief Constructs a IOHprofiler observer.
 */
IOHprofiler_observer_t *IOHprofiler_observer(const char *observer_name, const char *options);

/**
 * @brief Frees the given observer.
 */
void IOHprofiler_observer_free(IOHprofiler_observer_t *observer);

/**
 * @brief Adds an observer to the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_add_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**
 * @brief Removes an observer from the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_remove_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler problem
 */
/**@{*/
/**
 * @brief Evaluates the problem function in point x and save the result in y.
  logger_** functions use number_of_parameters and parameters to log extra informations of algorithms' adaptive parameters.
  If there is no need to log parameters, set number_of_parameters and parameters as 0 and NULL respectively.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Evaluates the problem constraints in point x and save the result in y.
 */
void IOHprofiler_evaluate_constraint(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Recommends a solution as the current best guesses to the problem.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief Frees the given problem.
 */
void IOHprofiler_problem_free(IOHprofiler_problem_t *problem);

void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters);

/**
 * @brief Returns the name of the problem.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the ID of the problem.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of variables i.e. the dimension of the problem.
 */
size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of objectives of the problem.
 */
size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of evaluations done on the problem.
 */
size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns 1 if the final target was hit, 0 otherwise.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the best observed value for the first objective.
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the target value for the first objective.
 */
double depreciated_IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with lower bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with upper bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the problem_index of the problem in its current suite.
 */
size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns an initial solution, i.e. a feasible variable setting, to the problem.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding random numbers
 */
/**@{*/

/**
 * @brief Creates and returns a new random number state using the given seed.
 */
IOHprofiler_random_state_t *IOHprofiler_random_new(uint32_t seed);

/**
 * @brief Frees all memory associated with the random state.
 */
void IOHprofiler_random_free(IOHprofiler_random_state_t *state);

/**
 * @brief Returns one uniform [0, 1) random value from the random number generator associated with the given
 * state.
 */
double IOHprofiler_random_uniform(IOHprofiler_random_state_t *state);

/**
 * @brief Generates an approximately normal random number.
 */
double IOHprofiler_random_normal(IOHprofiler_random_state_t *state);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods managing memory
 */
/**@{*/
/**
 * @brief Safe memory allocation that either succeeds or triggers a IOHprofiler_error.
 */
void *IOHprofiler_allocate_memory(const size_t size);

/**
 * @brief Safe memory allocation for a vector of doubles that either succeeds or triggers a IOHprofiler_error.
 */
double *IOHprofiler_allocate_vector(const size_t size);

/**
 * @brief Safe memory allocation for a vector of int that either succeeds or triggers a IOHprofiler_error.
 */
int *IOHprofiler_allocate_int_vector(const size_t size);

/**
 * @brief Frees the allocated memory.
 */
void IOHprofiler_free_memory(void *data);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler messages
 */
/**@{*/
/**
 * @brief Signals a fatal error.
 */
void IOHprofiler_error(const char *message, ...);

/**
 * @brief Warns about error conditions.
 */
void IOHprofiler_warning(const char *message, ...);

/**
 * @brief Outputs some information.
 */
void IOHprofiler_info(const char *message, ...);

/**
 * @brief Prints only the given message without any prefix and new line.
 *
 * A function similar to IOHprofiler_info but producing no additional text than
 * the given message.
 *
 * The output is only produced if IOHprofiler_log_level >= IOHprofiler_INFO.
 */
void IOHprofiler_info_partial(const char *message, ...);

/**
 * @brief Outputs detailed information usually used for debugging.
 */
void IOHprofiler_debug(const char *message, ...);

/**
 * @brief Sets the IOHprofiler log level to the given value and returns the previous value of the log level.
 */
const char *IOHprofiler_set_log_level(const char *level);
/**@}*/

/***********************************************************************************************************/

/**
 * @brief Constructs a IOHprofiler archive.
 */
IOHprofiler_archive_t *IOHprofiler_archive(const char *suite_name,
                                           const size_t function,
                                           const size_t dimension,
                                           const size_t instance);
/**
 * @brief Adds a solution with objectives (y1, y2) to the archive if none of the existing solutions in the
 * archive dominates it. In this case, returns 1, otherwise the archive is not updated and the method
 * returns 0.
 */

int IOHprofiler_archive_add_solution(IOHprofiler_archive_t *archive, const double y1, const double y2, const char *text);

/**
 * @brief Returns the number of (non-dominated) solutions in the archive (computed first, if needed).
 */
size_t IOHprofiler_archive_get_number_of_solutions(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the hypervolume of the archive (computed first, if needed).
 */
double IOHprofiler_archive_get_hypervolume(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the text of the next (non-dominated) solution in the archive and "" when there are no
 * solutions left. The first two solutions are always the extreme ones.
 */
const char *IOHprofiler_archive_get_next_solution_text(IOHprofiler_archive_t *archive);

/**
 * @brief Frees the archive.
 */
void IOHprofiler_archive_free(IOHprofiler_archive_t *archive);

/***********************************************************************************************************/

/**
 * @name Other useful methods
 */
/**@{*/
/**
 * @brief Removes the given directory and all its contents.
 */
int IOHprofiler_remove_directory(const char *path);

/**
 * @brief Formatted string duplication.
 */
char *IOHprofiler_strdupf(const char *str, ...);
/**@}*/

/***********************************************************************************************************/
typedef int (*int_to_int_func)(int);

struct WModel{
  size_t number_of_layers;
  int *layer1;
  int min1; int_to_int_func l_max1;
  int *layer2;
  int min2;int_to_int_func l_max2;
  int *layer3;
  int min3; int_to_int_func l_max3;
  int *layer4;
  int min4; int_to_int_func l_max4;
  int *counter;
};


#ifdef __cplusplus
}
#endif
#endif
#line 8 "code-experiments/src/profiler/../suite/WModel/suite_WModel.c"

#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"
#ifndef MODULAR_PROBLEM
#define MODULAR_PROBLEM

#include <assert.h>
#include <stdio.h>

#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler.h"
/**
 * @file IOHprofiler.h
 * @brief All public IOHprofiler functions and variables are defined in this file.
 *
 * It is the authoritative reference, if any function deviates from the documented behavior it is considered
 * a bug. See the function definitions for their detailed descriptions.
 */

#ifndef __IOHprofiler_H__
#define __IOHprofiler_H__

#include <stddef.h>

/* Definitions of some 32 and 64-bit types (used by the random number generator) */
#ifdef _MSC_VER
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

/* Include definition for NAN among other things */
#include <float.h>
#include <math.h>
#ifndef NAN
/** @brief Definition of NAN to be used only if undefined by the included headers */
#define NAN 8.8888e88
#endif
#ifndef isnan
/** @brief Definition of isnan to be used only if undefined by the included headers */
#define isnan(x) (0)
#endif
#ifndef INFINITY
/** @brief Definition of INFINITY to be used only if undefined by the included headers */
#define INFINITY 1e22
/* why not using 1e99? */
#endif
#ifndef isinf
/** @brief Definition of isinf to be used only if undefined by the included headers */
#define isinf(x) (0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief IOHprofiler's version.
 *
 * Automatically updated by do.py.
 */
/**@{*/
static const char IOHprofiler_version[32] = "";
/**@}*/

/***********************************************************************************************************/
/**
 * @brief IOHprofiler's own pi constant. Simplifies the case, when the value of pi changes.
 */
/**@{*/
static const double IOHprofiler_pi = 3.14159265358979323846;
/**@}*/

/***********************************************************************************************************/

/** @brief Logging level type. */
typedef enum {
    IOHprofiler_ERROR,   /**< @brief only error messages are output */
    IOHprofiler_WARNING, /**< @brief error and warning messages are output */
    IOHprofiler_INFO,    /**< @brief error, warning and info messages are output */
    IOHprofiler_DEBUG    /**< @brief error, warning, info and debug messages are output */
} IOHprofiler_log_level_type_e;

/***********************************************************************************************************/

/** @brief Structure containing a IOHprofiler problem. */
struct IOHprofiler_problem_s;

/**
 * @brief The IOHprofiler problem type.
 *
 * See IOHprofiler_problem_s for more information on its fields. */
typedef struct IOHprofiler_problem_s IOHprofiler_problem_t;

/** @brief Structure containing a IOHprofiler suite. */
struct IOHprofiler_suite_s;

/**
 * @brief The IOHprofiler suite type.
 *
 * See IOHprofiler_suite_s for more information on its fields. */
typedef struct IOHprofiler_suite_s IOHprofiler_suite_t;

/** @brief Structure containing a IOHprofiler observer. */
struct IOHprofiler_observer_s;

/**
 * @brief The IOHprofiler observer type.
 *
 * See IOHprofiler_observer_s for more information on its fields. */
typedef struct IOHprofiler_observer_s IOHprofiler_observer_t;

/** @brief Structure containing a IOHprofiler archive. */
struct IOHprofiler_archive_s;

/**
 * @brief The IOHprofiler archive type.
 *
 * See IOHprofiler_archive_s for more information on its fields. */
typedef struct IOHprofiler_archive_s IOHprofiler_archive_t;

/** @brief Structure containing a IOHprofiler random state. */
struct IOHprofiler_random_state_s;

/**
 * @brief The IOHprofiler random state type.
 *
 * See IOHprofiler_random_state_s for more information on its fields. */
typedef struct IOHprofiler_random_state_s IOHprofiler_random_state_t;

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler suite
 */
/**@{*/

/**
 * @brief Constructs a IOHprofiler suite.
 */
IOHprofiler_suite_t *IOHprofiler_suite(const char *suite_name, const char *suite_instance, const char *suite_options,int number, char** layer_param,char * temp_dim);

/**
 * @brief Frees the given suite.
 */
void IOHprofiler_suite_free(IOHprofiler_suite_t *suite);

/**
 * @brief Returns the next (observed) problem of the suite or NULL if there is no next problem left.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_next_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 *
 * @returns The current problem of the suite.
 */
IOHprofiler_problem_t *IOHprofiler_suite_reset_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 * @brief Returns the problem of the suite defined by problem_index.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_problem(IOHprofiler_suite_t *suite, const size_t problem_index);

/**
 * @brief Returns the number of problems in the given suite.
 */
size_t IOHprofiler_suite_get_number_of_problems(const IOHprofiler_suite_t *suite);

/**
 * @brief Returns the function number in the suite in position function_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_function_from_function_index(const IOHprofiler_suite_t *suite, const size_t function_idx);

/**
 * @brief Returns the dimension number in the suite in position dimension_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_dimension_from_dimension_index(const IOHprofiler_suite_t *suite, const size_t dimension_idx);

/**
 * @brief Returns the instance number in the suite in position instance_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_instance_from_instance_index(const IOHprofiler_suite_t *suite, const size_t instance_idx);
/**@}*/

/**
 * @name Encoding/decoding problem index
 *
 * General schema for encoding/decoding a problem index. Note that the index depends on the number of
 * instances a suite is defined with (it should be called a suite-instance-depending index...).
 * Also, while functions, instances and dimensions start from 1, function_idx, instance_idx and dimension_idx
 * as well as suite_dep_index start from 0!
 *
 * Showing an example with 2 dimensions (2, 3), 5 instances (6, 7, 8, 9, 10) and 2 functions (1, 2):
 *
   \verbatim
   index | instance | function | dimension
   ------+----------+----------+-----------
       0 |        6 |        1 |         2
       1 |        7 |        1 |         2
       2 |        8 |        1 |         2
       3 |        9 |        1 |         2
       4 |       10 |        1 |         2
       5 |        6 |        2 |         2
       6 |        7 |        2 |         2
       7 |        8 |        2 |         2
       8 |        9 |        2 |         2
       9 |       10 |        2 |         2
      10 |        6 |        1 |         3
      11 |        7 |        1 |         3
      12 |        8 |        1 |         3
      13 |        9 |        1 |         3
      14 |       10 |        1 |         3
      15 |        6 |        2 |         2
      16 |        7 |        2 |         3
      17 |        8 |        2 |         3
      18 |        9 |        2 |         3
      19 |       10 |        2 |         3

   index | instance_idx | function_idx | dimension_idx
   ------+--------------+--------------+---------------
       0 |            0 |            0 |             0
       1 |            1 |            0 |             0
       2 |            2 |            0 |             0
       3 |            3 |            0 |             0
       4 |            4 |            0 |             0
       5 |            0 |            1 |             0
       6 |            1 |            1 |             0
       7 |            2 |            1 |             0
       8 |            3 |            1 |             0
       9 |            4 |            1 |             0
      10 |            0 |            0 |             1
      11 |            1 |            0 |             1
      12 |            2 |            0 |             1
      13 |            3 |            0 |             1
      14 |            4 |            0 |             1
      15 |            0 |            1 |             1
      16 |            1 |            1 |             1
      17 |            2 |            1 |             1
      18 |            3 |            1 |             1
      19 |            4 |            1 |             1
   \endverbatim
 */
/**@{*/
/**
 * @brief Computes the index of the problem in the suite that corresponds to the given function, dimension
 * and instance indices.
 */
size_t IOHprofiler_suite_encode_problem_index(const IOHprofiler_suite_t *suite,
                                              const size_t function_idx,
                                              const size_t dimension_idx,
                                              const size_t instance_idx);

/**
 * @brief Computes the function, dimension and instance indexes of the problem with problem_index in the
 * given suite.
 */
void IOHprofiler_suite_decode_problem_index(const IOHprofiler_suite_t *suite,
                                            const size_t problem_index,
                                            size_t *function_idx,
                                            size_t *dimension_idx,
                                            size_t *instance_idx);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler observer
 */
/**@{*/
/**
 * @brief Constructs a IOHprofiler observer.
 */
IOHprofiler_observer_t *IOHprofiler_observer(const char *observer_name, const char *options);

/**
 * @brief Frees the given observer.
 */
void IOHprofiler_observer_free(IOHprofiler_observer_t *observer);

/**
 * @brief Adds an observer to the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_add_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**
 * @brief Removes an observer from the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_remove_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler problem
 */
/**@{*/
/**
 * @brief Evaluates the problem function in point x and save the result in y.
  logger_** functions use number_of_parameters and parameters to log extra informations of algorithms' adaptive parameters.
  If there is no need to log parameters, set number_of_parameters and parameters as 0 and NULL respectively.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Evaluates the problem constraints in point x and save the result in y.
 */
void IOHprofiler_evaluate_constraint(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Recommends a solution as the current best guesses to the problem.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief Frees the given problem.
 */
void IOHprofiler_problem_free(IOHprofiler_problem_t *problem);

void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters);

/**
 * @brief Returns the name of the problem.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the ID of the problem.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of variables i.e. the dimension of the problem.
 */
size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of objectives of the problem.
 */
size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of evaluations done on the problem.
 */
size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns 1 if the final target was hit, 0 otherwise.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the best observed value for the first objective.
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the target value for the first objective.
 */
double depreciated_IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with lower bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with upper bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the problem_index of the problem in its current suite.
 */
size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns an initial solution, i.e. a feasible variable setting, to the problem.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding random numbers
 */
/**@{*/

/**
 * @brief Creates and returns a new random number state using the given seed.
 */
IOHprofiler_random_state_t *IOHprofiler_random_new(uint32_t seed);

/**
 * @brief Frees all memory associated with the random state.
 */
void IOHprofiler_random_free(IOHprofiler_random_state_t *state);

/**
 * @brief Returns one uniform [0, 1) random value from the random number generator associated with the given
 * state.
 */
double IOHprofiler_random_uniform(IOHprofiler_random_state_t *state);

/**
 * @brief Generates an approximately normal random number.
 */
double IOHprofiler_random_normal(IOHprofiler_random_state_t *state);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods managing memory
 */
/**@{*/
/**
 * @brief Safe memory allocation that either succeeds or triggers a IOHprofiler_error.
 */
void *IOHprofiler_allocate_memory(const size_t size);

/**
 * @brief Safe memory allocation for a vector of doubles that either succeeds or triggers a IOHprofiler_error.
 */
double *IOHprofiler_allocate_vector(const size_t size);

/**
 * @brief Safe memory allocation for a vector of int that either succeeds or triggers a IOHprofiler_error.
 */
int *IOHprofiler_allocate_int_vector(const size_t size);

/**
 * @brief Frees the allocated memory.
 */
void IOHprofiler_free_memory(void *data);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler messages
 */
/**@{*/
/**
 * @brief Signals a fatal error.
 */
void IOHprofiler_error(const char *message, ...);

/**
 * @brief Warns about error conditions.
 */
void IOHprofiler_warning(const char *message, ...);

/**
 * @brief Outputs some information.
 */
void IOHprofiler_info(const char *message, ...);

/**
 * @brief Prints only the given message without any prefix and new line.
 *
 * A function similar to IOHprofiler_info but producing no additional text than
 * the given message.
 *
 * The output is only produced if IOHprofiler_log_level >= IOHprofiler_INFO.
 */
void IOHprofiler_info_partial(const char *message, ...);

/**
 * @brief Outputs detailed information usually used for debugging.
 */
void IOHprofiler_debug(const char *message, ...);

/**
 * @brief Sets the IOHprofiler log level to the given value and returns the previous value of the log level.
 */
const char *IOHprofiler_set_log_level(const char *level);
/**@}*/

/***********************************************************************************************************/

/**
 * @brief Constructs a IOHprofiler archive.
 */
IOHprofiler_archive_t *IOHprofiler_archive(const char *suite_name,
                                           const size_t function,
                                           const size_t dimension,
                                           const size_t instance);
/**
 * @brief Adds a solution with objectives (y1, y2) to the archive if none of the existing solutions in the
 * archive dominates it. In this case, returns 1, otherwise the archive is not updated and the method
 * returns 0.
 */

int IOHprofiler_archive_add_solution(IOHprofiler_archive_t *archive, const double y1, const double y2, const char *text);

/**
 * @brief Returns the number of (non-dominated) solutions in the archive (computed first, if needed).
 */
size_t IOHprofiler_archive_get_number_of_solutions(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the hypervolume of the archive (computed first, if needed).
 */
double IOHprofiler_archive_get_hypervolume(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the text of the next (non-dominated) solution in the archive and "" when there are no
 * solutions left. The first two solutions are always the extreme ones.
 */
const char *IOHprofiler_archive_get_next_solution_text(IOHprofiler_archive_t *archive);

/**
 * @brief Frees the archive.
 */
void IOHprofiler_archive_free(IOHprofiler_archive_t *archive);

/***********************************************************************************************************/

/**
 * @name Other useful methods
 */
/**@{*/
/**
 * @brief Removes the given directory and all its contents.
 */
int IOHprofiler_remove_directory(const char *path);

/**
 * @brief Formatted string duplication.
 */
char *IOHprofiler_strdupf(const char *str, ...);
/**@}*/

/***********************************************************************************************************/
typedef int (*int_to_int_func)(int);

struct WModel{
  size_t number_of_layers;
  int *layer1;
  int min1; int_to_int_func l_max1;
  int *layer2;
  int min2;int_to_int_func l_max2;
  int *layer3;
  int min3; int_to_int_func l_max3;
  int *layer4;
  int min4; int_to_int_func l_max4;
  int *counter;
};


#ifdef __cplusplus
}
#endif
#endif
#line 8 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_problem.c"
/**
 * @file IOHprofiler_problem.c
 * @brief Definitions of functions regarding IOHprofiler problems.
 */
#ifndef IOH_PROFILER_PROBLEM
#define IOH_PROFILER_PROBLEM

#include <float.h>
#line 10 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_internal.h"
/**
 * @file IOHprofiler_internal.h
 * @brief Definitions of internal IOHprofiler structures and typedefs.
 *
 * These are used throughout the IOHprofiler code base but should not be used by any external code.
 */

#ifndef __IOHprofiler_INTERNAL__
#define __IOHprofiler_INTERNAL__

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************************************/
/**
 * @brief The data free function type.
 *
 * This is a template for functions that free the contents of data (used to free the contents of data
 * fields in IOHprofiler_problem, IOHprofiler_suite and IOHprofiler_observer).
 */
typedef void (*IOHprofiler_data_free_function_t)(void *data);

/**
 * @brief The problem free function type.
 *
 * This is a template for functions that free the problem structure.
 */
typedef void (*IOHprofiler_problem_free_function_t)(IOHprofiler_problem_t *problem);

/**
 * @brief The initial solution function type.
 *
 * This is a template for functions that return an initial solution of the problem.
 */
typedef void (*IOHprofiler_initial_solution_function_t)(const IOHprofiler_problem_t *problem, int *x);

/**
 * @brief The evaluate function type.
 *
 * This is a template for functions that perform an evaluation of the problem (to evaluate the problem
 * function, the problems constraints etc.).
 */
typedef void (*IOHprofiler_evaluate_function_t)(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief The recommend solutions function type.
 *
 * This is a template for functions that log a recommended solution.
 */
typedef void (*IOHprofiler_recommend_function_t)(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief The allocate logger function type.
 *
 * This is a template for functions that allocate a logger (wrap a logger around the given problem and return
 * the wrapped problem).
 */
typedef IOHprofiler_problem_t *(*IOHprofiler_logger_allocate_function_t)(IOHprofiler_observer_t *observer,
                                                                         IOHprofiler_problem_t *problem);

/**
 * @brief The transformed IOHprofiler problem data type.
 *
 * This is a type of a generic structure for a transformed ("outer") IOHprofiler_problem. It makes possible the
 * wrapping of problems as layers of an onion. Initialized in the IOHprofiler_problem_transformed_allocate function,
 * it makes the current ("outer") transformed problem a "derived problem class", which inherits from the
 * "inner" problem, the "base class".
 *
 * From the perspective of the inner problem:
 * - data holds the meta-information to administer the inheritance
 * - data->data holds the additional fields of the derived class (the outer problem)
 * - data->inner_problem points to the inner problem (now we have a linked list)
 */
typedef struct {
    IOHprofiler_problem_t *inner_problem;                /**< @brief Pointer to the inner problem */
    void *data;                                          /**< @brief Pointer to data, which enables further
                                                  wrapping of the problem */
    IOHprofiler_data_free_function_t data_free_function; /**< @brief Function to free the contents of data */
} IOHprofiler_problem_transformed_data_t;

/**
 * @brief The free logger function type.
 *
 * This is a template for functions that free a logger.
 */
typedef void (*IOHprofiler_logger_free_function_t)(void *logger);

/**
 * @brief The stacked IOHprofiler problem data type.
 *
 * This is a type of a structure used when stacking two problems (especially useful for constructing
 * multi-objective problems).
 */
typedef struct {
    IOHprofiler_problem_t *problem1; /**< @brief Pointer to the first problem (objective) */
    IOHprofiler_problem_t *problem2; /**< @brief Pointer to the second problem (objective) */
} IOHprofiler_problem_stacked_data_t;

/**
 * @brief The option keys data type.
 *
 * This is a type of a structure used to contain a set of known option keys (used by suites and observers).
 */
typedef struct {
    size_t count; /**< @brief Number of option keys */
    char **keys;  /**< @brief Pointer to option keys */
} IOHprofiler_option_keys_t;

/***********************************************************************************************************/

/**
 * @brief The IOHprofiler problem structure.
 *
 * This is one of the main structures in IOHprofiler. It contains information about a problem to be optimized. The
 * problems can be wrapped around each other (similar to the onion layers) by means of the data field and
 * the IOHprofiler_problem_transformed_data_t structure creating some kind of "object inheritance". Even the logger
 * is considered as just another IOHprofiler_problem instance wrapped around the original problem.
 */
struct IOHprofiler_problem_s {
    IOHprofiler_initial_solution_function_t initial_solution;  /**< @brief  The function for creating an initial solution. */
    IOHprofiler_evaluate_function_t evaluate_function;         /**< @brief  The function for evaluating the problem. */
    IOHprofiler_recommend_function_t recommend_solution;       /**< @brief  The function for recommending a solution. */
    IOHprofiler_problem_free_function_t problem_free_function; /**< @brief  The function for freeing this problem. */

    size_t dimension; /**< @brief Number of variables expected before any transformation, used for logging files. */
    size_t number_of_variables;  /**< @brief Number of variables expected by the function, i.e.
                                       problem dimension */
    size_t number_of_objectives; /**< @brief Number of objectives. */
    size_t number_of_parameters; /**<  IOHprofiler @brief Number of parameters. */

    int *smallest_values_of_interest; /**< @brief The lower bounds of the ROI in the decision space. */
    int *largest_values_of_interest;  /**< @brief The upper bounds of the ROI in the decision space. */

    double *best_value;  /**< @brief Optimal (smallest) function value */
    double *nadir_value; /**< @brief The nadir point (defined when number_of_objectives > 1) */
    int *best_parameter; /**< @brief Optimal decision vector (defined only when unique) */
    double *parameters;  /** IOHprofiler @brief parameters setting */
    double *raw_fitness;

    char *problem_name; /**< @brief Problem name. */
    char *problem_id;   /**< @brief Problem ID (unique in the containing suite) */
    char *problem_type; /**< @brief Problem type */

    size_t evaluations; /**< @brief Number of evaluations performed on the problem. */

    /* Convenience fields for output generation */

    double final_target_delta[1];       /**< @brief Final target delta. */
    double best_observed_fvalue[1];     /**< @brief The best observed value so far. */
    size_t best_observed_evaluation[1]; /**< @brief The evaluation when the best value so far was achieved. */

    /* Fields depending on the containing benchmark suite */

    IOHprofiler_suite_t *suite; /**< @brief Pointer to the containing suite (NULL if not given) */
    size_t suite_dep_index;     /**< @brief Suite-depending problem index (starting from 0) */
    size_t suite_dep_function;  /**< @brief Suite-depending function */
    size_t suite_dep_instance;  /**< @brief Suite-depending instance */

    void *data; /**< @brief Pointer to a data instance @see IOHprofiler_problem_transformed_data_t */
};

/**
 * @brief The IOHprofiler observer structure.
 *
 * An observer observes the whole benchmark process. It is independent of suites and problems. Each time a
 * new problem of the suite is being observed, the observer initializes a new logger (wraps the observed
 * problem with the corresponding logger).
 */
struct IOHprofiler_observer_s {
    int is_active;         /**< @brief Whether the observer is active (the logger will log some output). */
    char *observer_name;   /**< @brief Name of the observer for identification purposes. */
    char *result_folder;   /**< @brief Name of the result folder. */
    char *algorithm_name;  /**< @brief Name of the algorithm to be used in logger output. */
    char *algorithm_info;  /**< @brief Additional information on the algorithm to be used in logger output. */
    char *parameters_name; /**< @brief Name of recorded parameters to be used in logger output. */
    size_t number_target_triggers;
    /**< @brief The number of targets between each 10**i and 10**(i+1). */
    double target_precision; /**< @brief The minimal precision used for targets. */
    size_t number_evaluation_triggers;
    /**< @brief The number of triggers between each 10**i and 10**(i+1) evaluation number. */
    char *base_evaluation_triggers;
    /**< @brief The "base evaluations" used to evaluations that trigger logging. */
    size_t number_interval_triggers;
    /**< @brief The size of interval between two triggers. */
    char *complete_triggers; /**< @brief The symbol for recording all evaluation. */

    int precision_x; /**< @brief Output precision for decision variables. */
    int precision_f; /**< @brief Output precision for function values. */
    void *data;      /**< @brief Void pointer that can be used to point to data specific to an observer. */

    IOHprofiler_data_free_function_t data_free_function;             /**< @brief  The function for freeing this observer. */
    IOHprofiler_logger_allocate_function_t logger_allocate_function; /**< @brief  The function for allocating the logger. */
    IOHprofiler_logger_free_function_t logger_free_function;         /**< @brief  The function for freeing the logger. */
};

/**
 * @brief The IOHprofiler suite structure.
 *
 * A suite is a collection of problems constructed by a Cartesian product of the suite's optimization
 * functions, dimensions and instances. The functions and dimensions are fixed for a suite with some name,
 * while the instances are defined dynamically. The suite can be filtered - only the chosen functions,
 * dimensions and instances will be taken into account when iterating through the suite.
 */
struct IOHprofiler_suite_s {
    char *suite_name; /**< @brief Name of the suite. */

    size_t number_of_dimensions; /**< @brief Number of dimensions contained in the suite. */
    size_t *dimensions;          /**< @brief The dimensions contained in the suite. */

    size_t number_of_functions; /**< @brief Number of functions contained in the suite. */
    size_t *functions;          /**< @brief The functions contained in the suite. */

    size_t number_of_instances; /**< @brief Number of instances contained in the suite. */
    char *default_instances;    /**< @brief The instances contained in the suite by default. */
    size_t *instances;          /**< @brief The instances contained in the suite. */

    IOHprofiler_problem_t *current_problem; /**< @brief Pointer to the currently tackled problem. */
    long current_dimension_idx;             /**< @brief The dimension index of the currently tackled problem. */
    long current_function_idx;              /**< @brief The function index of the currently tackled problem. */
    long current_instance_idx;              /**< @brief The instance index of the currently tackled problem. */

    void *data; /**< @brief Void pointer that can be used to point to data specific to a suite. */

    IOHprofiler_data_free_function_t data_free_function; /**< @brief The function for freeing this suite. */
};

#ifdef __cplusplus
}
#endif
#endif
#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_problem.c"

#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_utilities.c"
/**
 * @file IOHprofiler_utilities.c
 * @brief Definitions of miscellaneous functions used throughout the IOHprofiler framework.
 */
#ifndef IOH_PROFILER_UTILITIES
#define IOH_PROFILER_UTILITIES

#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_platform.h"
/**
 * @file IOHprofiler_platform.h
 * @brief Automatic platform-dependent configuration of the IOHprofiler framework.
 *
 * Some platforms and standard conforming compilers require extra defines or includes to provide some
 * functionality.
 *
 * Because most feature defines need to be set before the first system header is included and we do not
 * know when a system header is included for the first time in the amalgamation, all internal files
 * that need these definitions should include this file before any system headers.
 */

#ifndef __COCO_PLATFORM__
#define __COCO_PLATFORM__

#include <stddef.h>

/* Definitions of IOHprofiler_PATH_MAX, IOHprofiler_path_separator, HAVE_GFA and HAVE_STAT heavily used by functions in
 * IOHprofiler_utilities.c */
#if defined(_WIN32) || defined(_WIN64) || defined(__MINGW64__) || defined(__CYGWIN__)
#include <windows.h>
static const char *IOHprofiler_path_separator = "\\";
#define IOHprofiler_PATH_MAX MAX_PATH
#define HAVE_GFA 1
#elif defined(__gnu_linux__)
#include <linux/limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__APPLE__)
#include <sys/stat.h>
#include <sys/syslimits.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__FreeBSD__)
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif (defined(__sun) || defined(sun)) && (defined(__SVR4) || defined(__svr4__))
/* Solaris */
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#else
#error Unknown platform
#endif
#if !defined(IOHprofiler_PATH_MAX)
#error IOHprofiler_PATH_MAX undefined
#endif

/* Definitions needed for creating and removing directories */
/* Separately handle the special case of Microsoft Visual Studio 2008 with x86_64-w64-mingw32-gcc */
#if _MSC_VER
#include <direct.h>
#elif defined(__MINGW32__) || defined(__MINGW64__)
#include <dirent.h>
#else
#include <dirent.h>

#ifdef __cplusplus
extern "C" {
#endif

/* To silence the compiler (implicit-function-declaration warning). */
/** @cond */
int rmdir(const char *pathname);
int unlink(const char *file_name);
int mkdir(const char *pathname, mode_t mode);
/** @endcond */
#endif

/* Definition of the S_IRWXU constant needed to set file permissions */
#if defined(HAVE_GFA)
#define S_IRWXU 0700
#endif

/* To silence the Visual Studio compiler (C4996 warnings in the python build). */
#ifdef _MSC_VER
#pragma warning(disable : 4996)
#endif

#ifdef __cplusplus
}
#endif

#endif
#line 9 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_utilities.c"

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#line 18 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_utilities.c"
#line 19 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_utilities.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_string.c"
/**
 * @file IOHprofiler_string.c
 * @brief Definitions of functions that manipulate strings.
 */
#ifndef IOH_PROFILER_STRING
#define IOH_PROFILER_STRING

#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#line 13 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_string.c"

static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements);

/**
 * @brief Creates a duplicate copy of string and returns a pointer to it.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strdup(const char *string) {
    size_t len;
    char *duplicate;
    if (string == NULL)
        return NULL;
    len = strlen(string);
    duplicate = (char *)IOHprofiler_allocate_memory(len + 1);
    memcpy(duplicate, string, len + 1);
    return duplicate;
}

/**
 * @brief The length of the buffer used in the IOHprofiler_vstrdupf function.
 *
 * @note This should be handled differently!
 */
#define IOHprofiler_VSTRDUPF_BUFLEN 444

/**
 * @brief Formatted string duplication, with va_list arguments.
 */
static char *IOHprofiler_vstrdupf(const char *str, va_list args) {
    static char buf[IOHprofiler_VSTRDUPF_BUFLEN];
    long written;
    /* apparently args can only be used once, therefore
   * len = vsnprintf(NULL, 0, str, args) to find out the
   * length does not work. Therefore we use a buffer
   * which limits the max length. Longer strings should
   * never appear anyway, so this is rather a non-issue. */

#if 0
  written = vsnprintf(buf, IOHprofiler_VSTRDUPF_BUFLEN - 2, str, args);
  if (written < 0)
  IOHprofiler_error("IOHprofiler_vstrdupf(): vsnprintf failed on '%s'", str);
#else /* less safe alternative, if vsnprintf is not available */
    assert(strlen(str) < IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2);
    if (strlen(str) >= IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2)
        IOHprofiler_error("IOHprofiler_vstrdupf(): string is too long");
    written = vsprintf(buf, str, args);
    if (written < 0)
        IOHprofiler_error("IOHprofiler_vstrdupf(): vsprintf failed on '%s'", str);
#endif
    if (written > IOHprofiler_VSTRDUPF_BUFLEN - 3)
        IOHprofiler_error("IOHprofiler_vstrdupf(): A suspiciously long string is tried to being duplicated '%s'", buf);
    return IOHprofiler_strdup(buf);
}

#undef IOHprofiler_VSTRDUPF_BUFLEN

/**
 * Optional arguments are used like in sprintf.
 */
char *IOHprofiler_strdupf(const char *str, ...) {
    va_list args;
    char *s;

    va_start(args, str);
    s = IOHprofiler_vstrdupf(str, args);
    va_end(args);
    return s;
}

/**
 * @brief Returns a concatenate copy of string1 + string2.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strconcat(const char *s1, const char *s2) {
    size_t len1 = strlen(s1);
    size_t len2 = strlen(s2);
    char *s = (char *)IOHprofiler_allocate_memory(len1 + len2 + 1);

    memcpy(s, s1, len1);
    memcpy(&s[len1], s2, len2 + 1);
    return s;
}

/**
 * @brief Returns the first index where seq occurs in base and -1 if it doesn't.
 *
 * @note If there is an equivalent standard C function, this can/should be removed.
 */
static long IOHprofiler_strfind(const char *base, const char *seq) {
    const size_t strlen_seq = strlen(seq);
    const size_t last_first_idx = strlen(base) - strlen(seq);
    size_t i, j;

    if (strlen(base) < strlen(seq))
        return -1;

    for (i = 0; i <= last_first_idx; ++i) {
        if (base[i] == seq[0]) {
            for (j = 0; j < strlen_seq; ++j) {
                if (base[i + j] != seq[j])
                    break;
            }
            if (j == strlen_seq) {
                if (i > 1e9)
                    IOHprofiler_error("IOHprofiler_strfind(): strange values observed i=%lu, j=%lu, strlen(base)=%lu",
                                      (unsigned long)i, (unsigned long)j, (unsigned long)strlen(base));
                return (long)i;
            }
        }
    }
    return -1;
}

/**
 * @brief Splits a string based on the given delimiter.
 *
 * Returns a pointer to the resulting substrings with NULL as the last one.
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char **IOHprofiler_string_split(const char *string, const char delimiter) {
    char **result;
    char *str_copy, *ptr, *token;
    char str_delimiter[2];
    size_t i;
    size_t count = 1;

    str_copy = IOHprofiler_strdup(string);

    /* Counts the parts between delimiters */
    ptr = str_copy;
    while (*ptr != '\0') {
        if (*ptr == delimiter) {
            count++;
        }
        ptr++;
    }
    /* Makes room for an empty string that will be appended at the end */
    count++;

    result = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));

    /* Iterates through tokens
   * NOTE: strtok() ignores multiple delimiters, therefore the final number of detected substrings might be
   * lower than the count. This is OK. */
    i = 0;
    /* A char* delimiter needs to be used, otherwise strtok() can surprise */
    str_delimiter[0] = delimiter;
    str_delimiter[1] = '\0';
    token = strtok(str_copy, str_delimiter);
    while (token) {
        assert(i < count);
        *(result + i++) = IOHprofiler_strdup(token);
        token = strtok(NULL, str_delimiter);
    }
    *(result + i) = NULL;

    IOHprofiler_free_memory(str_copy);

    return result;
}

/**
 * @brief Creates and returns a string with removed characters between from and to.
 *
 * If you wish to remove characters from the beginning of the string, set from to "".
 * If you wish to remove characters until the end of the string, set to to "".
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_remove_from_string(const char *string, const char *from, const char *to) {
    char *result, *start, *stop;

    result = IOHprofiler_strdup(string);

    if (strcmp(from, "") == 0) {
        /* Remove from the start */
        start = result;
    } else
        start = strstr(result, from);

    if (strcmp(to, "") == 0) {
        /* Remove until the end */
        stop = result + strlen(result);
    } else
        stop = strstr(result, to);

    if ((start == NULL) || (stop == NULL) || (stop < start)) {
        IOHprofiler_error("IOHprofiler_remove_from_string(): failed to remove characters between %s and %s from string %s",
                          from, to, string);
        return NULL; /* Never reached */
    }

    memmove(start, stop, strlen(stop) + 1);

    return result;
}

/**
 * @brief Returns the numbers defined by the ranges.
 *
 * Reads ranges from a string of positive ranges separated by commas. For example: "-3,5-6,8-". Returns the
 * numbers that are defined by the ranges if min and max are used as their extremes. If the ranges with open
 * beginning/end are not allowed, use 0 as min/max. The returned string has an appended 0 to mark its end.
 * A maximum of max_count values is returned. If there is a problem with one of the ranges, the parsing stops
 * and the current result is returned. The memory of the returned object needs to be freed by the caller.
 */
static size_t *IOHprofiler_string_parse_ranges(const char *string,
                                               const size_t min,
                                               const size_t max,
                                               const char *name,
                                               const size_t max_count) {
    char *ptr, *dash = NULL;
    char **ranges, **numbers;
    size_t i, j, count;
    size_t num[2];

    size_t *result;
    size_t i_result = 0;

    char *str = IOHprofiler_strdup(string);

    /* Check for empty string */
    if ((str == NULL) || (strlen(str) == 0)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): cannot parse empty ranges");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    ptr = str;
    /* Check for disallowed characters */
    while (*ptr != '\0') {
        if ((*ptr != '-') && (*ptr != ',') && !isdigit((unsigned char)*ptr)) {
            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - cannot parse ranges with '%c'", str,
                                *ptr);
            IOHprofiler_free_memory(str);
            return NULL;
        } else
            ptr++;
    }
    /* Check for incorrect boundaries */
    if ((max > 0) && (min > max)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): incorrect boundaries");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    result = IOHprofiler_allocate_vector_size_t(max_count + 1);

    /* Split string to ranges w.r.t commas */
    ranges = IOHprofiler_string_split(str, ',');
    IOHprofiler_free_memory(str);
    if (ranges) {
        /* Go over the current range */
        for (i = 0; *(ranges + i); i++) {
            ptr = *(ranges + i);
            /* Count the number of '-' */
            count = 0;
            while (*ptr != '\0') {
                if (*ptr == '-') {
                    if (count == 0)
                        /* Remember the position of the first '-' */
                        dash = ptr;
                    count++;
                }
                ptr++;
            }
            /* Point again to the start of the range */
            ptr = *(ranges + i);

            /* Check for incorrect number of '-' */
            if (count > 1) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - too many '-'s", string);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            } else if (count == 0) {
                /* Range is in the format: n (no range) */
                num[0] = (size_t)strtol(ptr, NULL, 10);
                num[1] = num[0];
            } else {
                /* Range is in one of the following formats: n-m / -n / n- / - */

                /* Split current range to numbers w.r.t '-' */
                numbers = IOHprofiler_string_split(ptr, '-');
                j = 0;
                if (numbers) {
                    /* Read the numbers */
                    for (j = 0; *(numbers + j); j++) {
                        assert(j < 2);
                        num[j] = (size_t)strtol(*(numbers + j), NULL, 10);
                        IOHprofiler_free_memory(*(numbers + j));
                    }
                }
                IOHprofiler_free_memory(numbers);

                if (j == 0) {
                    /* Range is in the format - (open ends) */
                    if ((min == 0) || (max == 0)) {
                        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open ends; some ranges ignored", name);
                        /* Cleanup */
                        for (j = i; *(ranges + j); j++)
                            IOHprofiler_free_memory(*(ranges + j));
                        IOHprofiler_free_memory(ranges);
                        if (i_result == 0) {
                            IOHprofiler_free_memory(result);
                            return NULL;
                        }
                        result[i_result] = 0;
                        return result;
                    }
                    num[0] = min;
                    num[1] = max;
                } else if (j == 1) {
                    if (dash - *(ranges + i) == 0) {
                        /* Range is in the format -n */
                        if (min == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open beginning; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = num[0];
                        num[0] = min;
                    } else {
                        /* Range is in the format n- */
                        if (max == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open end; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = max;
                    }
                }
                /* if (j == 2), range is in the format n-m and there is nothing to do */
            }

            /* Make sure the boundaries are taken into account */
            if ((min > 0) && (num[0] < min)) {
                num[0] = min;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be >= %lu", name,
                                    (unsigned long)min);
              }
            if ((max > 0) && (num[1] > max)) {
                num[1] = max;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be <= %lu", name, (unsigned long) max);
            }
            if (num[0] > num[1]) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges not within boundaries; some ranges ignored", name);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            }

            /* Write in result */
            for (j = num[0]; j <= num[1]; j++) {
                if (i_result > max_count - 1)
                    break;
                result[i_result++] = j;
            }

            IOHprofiler_free_memory(*(ranges + i));
            *(ranges + i) = NULL;
        }
    }

    IOHprofiler_free_memory(ranges);

    if (i_result == 0) {
        IOHprofiler_free_memory(result);
        return NULL;
    }

    result[i_result] = 0;
    return result;
}

/**
 * @brief Trims the given string (removes any leading and trailing spaces).
 *
 * If the string contains any leading spaces, the contents are shifted so that if it was dynamically
 * allocated, it can be still freed on the returned pointer.
 */
static char *IOHprofiler_string_trim(char *string) {
    size_t len = 0;
    char *frontp = string;
    char *endp = NULL;

    if (string == NULL) {
        return NULL;
    }
    if (string[0] == '\0') {
        return string;
    }

    len = strlen(string);
    endp = string + len;

    /* Move the front and back pointers to address the first non-whitespace characters from each end. */
    while (isspace((unsigned char)*frontp)) {
        ++frontp;
    }
    if (endp != frontp) {
        while (isspace((unsigned char)*(--endp)) && endp != frontp) {
        }
    }

    if (string + len - 1 != endp)
        *(endp + 1) = '\0';
    else if (frontp != string && endp == frontp)
        *string = '\0';

    /* Shift the string. Note the reuse of endp to mean the front of the string buffer now. */
    endp = string;
    if (frontp != string) {
        while (*frontp) {
            *endp++ = *frontp++;
        }
        *endp = '\0';
    }

    return string;
}
#endif
#line 20 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_utilities.c"

/***********************************************************************************************************/

/**
 * @brief Initializes the logging level to IOHprofiler_INFO.
 */
static IOHprofiler_log_level_type_e IOHprofiler_log_level = IOHprofiler_INFO;

/**
 * @param log_level Denotes the level of information given to the user through the standard output and
 * error streams. Can take on the values:
 * - "error" (only error messages are output),
 * - "warning" (only error and warning messages are output),
 * - "info" (only error, warning and info messages are output) and
 * - "debug" (all messages are output).
 * - "" does not set a new value
 * The default value is info.
 *
 * @return The previous IOHprofiler_log_level value as an immutable string.
 */
const char *IOHprofiler_set_log_level(const char *log_level) {
    IOHprofiler_log_level_type_e previous_log_level = IOHprofiler_log_level;

    if (strcmp(log_level, "error") == 0)
        IOHprofiler_log_level = IOHprofiler_ERROR;
    else if (strcmp(log_level, "warning") == 0)
        IOHprofiler_log_level = IOHprofiler_WARNING;
    else if (strcmp(log_level, "info") == 0)
        IOHprofiler_log_level = IOHprofiler_INFO;
    else if (strcmp(log_level, "debug") == 0)
        IOHprofiler_log_level = IOHprofiler_DEBUG;
    else if (strcmp(log_level, "") == 0) {
        /* Do nothing */
    } else {
        IOHprofiler_warning("IOHprofiler_set_log_level(): unknown level %s", log_level);
    }

    if (previous_log_level == IOHprofiler_ERROR)
        return "error";
    else if (previous_log_level == IOHprofiler_WARNING)
        return "warning";
    else if (previous_log_level == IOHprofiler_INFO)
        return "info";
    else if (previous_log_level == IOHprofiler_DEBUG)
        return "debug";
    else {
        IOHprofiler_error("IOHprofiler_set_log_level(): unknown previous log level");
        return "";
    }
}

/***********************************************************************************************************/

/**
 * @name Methods regarding file, directory and path manipulations
 */
/**@{*/
/**
 * @brief Creates a platform-dependent path from the given strings.
 *
 * @note The last argument must be NULL.
 * @note The first parameter must be able to accommodate path_max_length characters and the length
 * of the joined path must not exceed path_max_length characters.
 * @note Should work cross-platform.
 *
 * Usage examples:
 * - IOHprofiler_join_path(base_path, 100, folder1, folder2, folder3, NULL) creates base_path/folder1/folder2/folder3
 * - IOHprofiler_join_path(base_path, 100, folder1, file_name, NULL) creates base_path/folder1/file_name
 * @param path The base path; it's also where the joined path is stored to.
 * @param path_max_length The maximum length of the path.
 * @param ... Additional strings, must end with NULL
 */
static void IOHprofiler_join_path(char *path, const size_t path_max_length, ...) {
    const size_t path_separator_length = strlen(IOHprofiler_path_separator);
    va_list args;
    char *path_component;
    size_t path_length = strlen(path);

    va_start(args, path_max_length);
    while (NULL != (path_component = va_arg(args, char *))) {
        size_t component_length = strlen(path_component);
        if (path_length + path_separator_length + component_length >= path_max_length) {
            IOHprofiler_error("IOHprofiler_join_path() failed because the ${path} is too short.");
            return; /* never reached */
        }
        /* Both should be safe because of the above check. */
        if (strlen(path) > 0)
            strncat(path, IOHprofiler_path_separator, path_max_length - strlen(path) - 1);
        strncat(path, path_component, path_max_length - strlen(path) - 1);
    }
    va_end(args);
}

/**
 * @brief Checks if the given directory exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a directory and 0 otherwise.
 */
static int IOHprofiler_directory_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Checks if the given file exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a file and 0 otherwise.
 */
static int IOHprofiler_file_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES) && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && !S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Calls the right mkdir() method (depending on the platform).
 *
 * @param path The directory path.
 *
 * @return 0 on successful completion, and -1 on error.
 */
static int IOHprofiler_mkdir(const char *path) {
#if _MSC_VER
    return _mkdir(path);
#elif defined(__MINGW32__) || defined(__MINGW64__)
    return mkdir(path);
#else
    return mkdir(path, S_IRWXU);
#endif
}

/**
 * @brief Creates a directory with full privileges for the user.
 *
 * @note Should work cross-platform.
 *
 * @param path The directory path.
 */
static void IOHprofiler_create_directory(const char *path) {
    char *tmp = NULL;
    char *p;
    size_t len = strlen(path);
    char path_sep = IOHprofiler_path_separator[0];

    /* Nothing to do if the path exists. */
    if (IOHprofiler_directory_exists(path))
        return;

    tmp = IOHprofiler_strdup(path);
    /* Remove possible trailing slash */
    if (tmp[len - 1] == path_sep)
        tmp[len - 1] = 0;
    for (p = tmp + 1; *p; p++) {
        if (*p == path_sep) {
            *p = 0;
            if (!IOHprofiler_directory_exists(tmp)) {
                if (0 != IOHprofiler_mkdir(tmp))
                    IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
            }
            *p = path_sep;
        }
    }
    if (0 != IOHprofiler_mkdir(tmp))
        IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
    IOHprofiler_free_memory(tmp);
    return;
}

/* Commented to silence the compiler (unused function warning) */
#if 0

#endif

/**
 * @brief Creates a unique directory from the given path.
 *
 * If the given path does not yet exit, it is left as is, otherwise it is changed(!) by appending a number
 * to it. If path already exists, path-01 will be tried. If this one exists as well, path-02 will be tried,
 * and so on. If path-99 exists as well, the function throws an error.
 */
static void IOHprofiler_create_unique_directory(char **path) {
    int counter = 1;
    char *new_path;

    /* Create the path if it does not yet exist */
    if (!IOHprofiler_directory_exists(*path)) {
        IOHprofiler_create_directory(*path);
        return;
    }

    while (counter < 999) {
        new_path = IOHprofiler_strdupf("%s-%03d", *path, counter);

        if (!IOHprofiler_directory_exists(new_path)) {
            IOHprofiler_free_memory(*path);
            *path = new_path;
            IOHprofiler_create_directory(*path);
            return;
        } else {
            counter++;
            IOHprofiler_free_memory(new_path);
        }
    }

    IOHprofiler_error("IOHprofiler_create_unique_path(): could not create a unique path with name %s", *path);
    return; /* Never reached */
}

/**
 * The method should work across different platforms/compilers.
 *
 * @path The path to the directory
 *
 * @return 0 on successful completion, and -1 on error.
 */
int IOHprofiler_remove_directory(const char *path) {
#if _MSC_VER
    WIN32_FIND_DATA find_data_file;
    HANDLE find_handle = NULL;
    char *buf;
    int r = -1;
    int r2 = -1;

    buf = IOHprofiler_strdupf("%s\\*.*", path);
    /* Nothing to do if the folder does not exist */
    if ((find_handle = FindFirstFile(buf, &find_data_file)) == INVALID_HANDLE_VALUE) {
        IOHprofiler_free_memory(buf);
        return 0;
    }
    IOHprofiler_free_memory(buf);

    do {
        r = 0;

        /* Skip the names "." and ".." as we don't want to recurse on them */
        if (strcmp(find_data_file.cFileName, ".") != 0 && strcmp(find_data_file.cFileName, "..") != 0) {
            /* Build the new path using the argument path the file/folder name we just found */
            buf = IOHprofiler_strdupf("%s\\%s", path, find_data_file.cFileName);

            if (find_data_file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                /* Buf is a directory, recurse on it */
                r2 = IOHprofiler_remove_directory(buf);
            } else {
                /* Buf is a file, delete it */
                /* Careful, DeleteFile returns 0 if it fails and nonzero otherwise! */
                r2 = -(DeleteFile(buf) == 0);
            }

            IOHprofiler_free_memory(buf);
        }

        r = r2;

    } while (FindNextFile(find_handle, &find_data_file)); /* Find the next file */

    FindClose(find_handle);

    if (!r) {
        /* Path is an empty directory, delete it */
        /* Careful, RemoveDirectory returns 0 if it fails and nonzero otherwise! */
        r = -(RemoveDirectory(path) == 0);
    }

    return r;
#else
    DIR *d = opendir(path);
    int r = -1;
    int r2 = -1;
    char *buf;

    /* Nothing to do if the folder does not exist */
    if (!IOHprofiler_directory_exists(path))
        return 0;

    if (d) {
        struct dirent *p;

        r = 0;

        while (!r && (p = readdir(d))) {
            /* Skip the names "." and ".." as we don't want to recurse on them */
            if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, "..")) {
                continue;
            }

            buf = IOHprofiler_strdupf("%s/%s", path, p->d_name);
            if (buf) {
                if (IOHprofiler_directory_exists(buf)) {
                    /* Buf is a directory, recurse on it */
                    r2 = IOHprofiler_remove_directory(buf);
                } else {
                    /* Buf is a file, delete it */
                    r2 = unlink(buf);
                }
            }
            IOHprofiler_free_memory(buf);

            r = r2;
        }

        closedir(d);
    }

    if (!r) {
        /* Path is an empty directory, delete it */
        r = rmdir(path);
    }

    return r;
#endif
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding memory allocations
 */
/**@{*/
double *IOHprofiler_allocate_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(double);
    return (double *)IOHprofiler_allocate_memory(block_size);
}

int *IOHprofiler_allocate_int_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(int);
    return (int *)IOHprofiler_allocate_memory(block_size);
}
/**
 * @brief Allocates memory for a vector and sets all its elements to value.
 */
static double *IOHprofiler_allocate_vector_with_value(const size_t number_of_elements, double value) {
    const size_t block_size = number_of_elements * sizeof(double);
    double *vector = (double *)IOHprofiler_allocate_memory(block_size);
    size_t i;

    for (i = 0; i < number_of_elements; i++)
        vector[i] = value;

    return vector;
}

/**
 * @brief Safe memory allocation for a vector with size_t elements that either succeeds or triggers a
 * IOHprofiler_error.
 */
static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(size_t);
    return (size_t *)IOHprofiler_allocate_memory(block_size);
}

static char *IOHprofiler_allocate_string(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(char);
    return (char *)IOHprofiler_allocate_memory(block_size);
}

static double *IOHprofiler_duplicate_vector(const double *src, const size_t number_of_elements) {
    size_t i;
    double *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}

static int *IOHprofiler_duplicate_int_vector(const int *src, const size_t number_of_elements) {
    size_t i;
    int *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_int_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding string options
 */
/**@{*/

/**
 * @brief Allocates an option keys structure holding the given number of option keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_allocate(const size_t count, const char **keys) {
    size_t i;
    IOHprofiler_option_keys_t *option_keys;

    if ((count == 0) || (keys == NULL))
        return NULL;

    option_keys = (IOHprofiler_option_keys_t *)IOHprofiler_allocate_memory(sizeof(*option_keys));

    option_keys->keys = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));
    for (i = 0; i < count; i++) {
        assert(keys[i]);
        option_keys->keys[i] = IOHprofiler_strdup(keys[i]);
    }
    option_keys->count = count;

    return option_keys;
}

/**
 * @brief Frees the given option keys structure.
 */
static void IOHprofiler_option_keys_free(IOHprofiler_option_keys_t *option_keys) {
    size_t i;

    if (option_keys) {
        for (i = 0; i < option_keys->count; i++) {
            IOHprofiler_free_memory(option_keys->keys[i]);
        }
        IOHprofiler_free_memory(option_keys->keys);
        IOHprofiler_free_memory(option_keys);
    }
}

/**
 * @brief Returns redundant option keys (the ones present in given_option_keys but not in known_option_keys).
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_get_redundant(const IOHprofiler_option_keys_t *known_option_keys,
                                                                        const IOHprofiler_option_keys_t *given_option_keys) {
    size_t i, j, count = 0;
    int found;
    char **redundant_keys;
    IOHprofiler_option_keys_t *redundant_option_keys;

    assert(known_option_keys != NULL);
    assert(given_option_keys != NULL);

    /* Find the redundant keys */
    redundant_keys = (char **)IOHprofiler_allocate_memory(given_option_keys->count * sizeof(char *));
    for (i = 0; i < given_option_keys->count; i++) {
        found = 0;
        for (j = 0; j < known_option_keys->count; j++) {
            if (strcmp(given_option_keys->keys[i], known_option_keys->keys[j]) == 0) {
                found = 1;
                break;
            }
        }
        if (!found) {
            redundant_keys[count++] = IOHprofiler_strdup(given_option_keys->keys[i]);
        }
    }
    redundant_option_keys = IOHprofiler_option_keys_allocate(count, (const char **)redundant_keys);

    /* Free memory */
    for (i = 0; i < count; i++) {
        IOHprofiler_free_memory(redundant_keys[i]);
    }
    IOHprofiler_free_memory(redundant_keys);

    return redundant_option_keys;
}

/**
 * @brief Adds additional option keys to the given basic option keys (changes the basic keys).
 */
static void IOHprofiler_option_keys_add(IOHprofiler_option_keys_t **basic_option_keys,
                                        const IOHprofiler_option_keys_t *additional_option_keys) {
    size_t i, j;
    size_t new_count;
    char **new_keys;
    IOHprofiler_option_keys_t *new_option_keys;

    assert(*basic_option_keys != NULL);
    if (additional_option_keys == NULL)
        return;

    /* Construct the union of both keys */
    new_count = (*basic_option_keys)->count + additional_option_keys->count;
    new_keys = (char **)IOHprofiler_allocate_memory(new_count * sizeof(char *));
    for (i = 0; i < (*basic_option_keys)->count; i++) {
        new_keys[i] = IOHprofiler_strdup((*basic_option_keys)->keys[i]);
    }
    for (j = 0; j < additional_option_keys->count; j++) {
        new_keys[(*basic_option_keys)->count + j] = IOHprofiler_strdup(additional_option_keys->keys[j]);
    }
    new_option_keys = IOHprofiler_option_keys_allocate(new_count, (const char **)new_keys);

    /* Free the old basic keys */
    IOHprofiler_option_keys_free(*basic_option_keys);
    *basic_option_keys = new_option_keys;
    for (i = 0; i < new_count; i++) {
        IOHprofiler_free_memory(new_keys[i]);
    }
    IOHprofiler_free_memory(new_keys);
}

/**
 * @brief Creates an instance of option keys from the given string of options containing keys and values
 * separated by colons.
 *
 * @note Relies heavily on the "key: value" format and might fail if the number of colons doesn't match the
 * number of keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys(const char *option_string) {
    size_t i;
    char **keys;
    IOHprofiler_option_keys_t *option_keys = NULL;
    char *string_to_parse, *key;

    /* Check for empty string */
    if ((option_string == NULL) || (strlen(option_string) == 0)) {
        return NULL;
    }

    /* Split the options w.r.t ':' */
    keys = IOHprofiler_string_split(option_string, ':');

    if (keys) {
        /* Keys now contain something like this: "values_of_previous_key this_key" except for the first, which
     * contains only the key and the last, which contains only the previous values */
        for (i = 0; *(keys + i); i++) {
            string_to_parse = IOHprofiler_strdup(*(keys + i));

            /* Remove any leading and trailing spaces */
            string_to_parse = IOHprofiler_string_trim(string_to_parse);

            /* Stop if this is the last substring (contains a value and no key) */
            if ((i > 0) && (*(keys + i + 1) == NULL)) {
                IOHprofiler_free_memory(string_to_parse);
                break;
            }

            /* Disregard everything before the last space */
            key = strrchr(string_to_parse, ' ');
            if ((key == NULL) || (i == 0)) {
                /* No spaces left (or this is the first key), everything is the key */
                key = string_to_parse;
            } else {
                /* Move to the start of the key (one char after the space) */
                key++;
            }

            /* Put the key in keys */
            IOHprofiler_free_memory(*(keys + i));
            *(keys + i) = IOHprofiler_strdup(key);
            IOHprofiler_free_memory(string_to_parse);
        }

        option_keys = IOHprofiler_option_keys_allocate(i, (const char **)keys);

        /* Free the keys */
        for (i = 0; *(keys + i); i++) {
            IOHprofiler_free_memory(*(keys + i));
        }
        IOHprofiler_free_memory(keys);
    }

    return option_keys;
}

/**
 * @brief Creates and returns a string containing the info_string and all keys from option_keys.
 *
 * Can be used to output information about the given option_keys.
 */
static char *IOHprofiler_option_keys_get_output_string(const IOHprofiler_option_keys_t *option_keys,
                                                       const char *info_string) {
    size_t i;
    char *string = NULL, *new_string;

    if ((option_keys != NULL) && (option_keys->count > 0)) {
        string = IOHprofiler_strdup(info_string);
        for (i = 0; i < option_keys->count; i++) {
            new_string = IOHprofiler_strdupf("%s %s\n", string, option_keys->keys[i]);
            IOHprofiler_free_memory(string);
            string = new_string;
        }
    }

    return string;
}

/**
 * @brief Parses options in the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - value needs to be a single string (no spaces allowed)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read(const char *options, const char *name, const char *format, void *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing whitespaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    return sscanf(&options[i2], format, pointer);
}

/**
 * @brief Reads an integer from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be an integer
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_int(const char *options, const char *name, int *pointer) {
    return IOHprofiler_options_read(options, name, " %i", pointer);
}

/**
 * @brief Reads a size_t from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a size_t
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_size_t(const char *options, const char *name, size_t *pointer) {
    return IOHprofiler_options_read(options, name, "%lu", pointer);
}

/**
 * @brief Reads a double value from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a double
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_double(const char *options, const char *name, double *pointer) {
    return IOHprofiler_options_read(options, name, "%lf", pointer);
}

/**
 * @brief Reads a string from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a string - either a single word or multiple words
 * in double quotes
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_string(const char *options, const char *name, char *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    if (options[i2] == '\"') {
        /* The value starts with a quote: read everything between two quotes into a string */
        return sscanf(&options[i2], "\"%[^\"]\"", pointer);
    } else
        return sscanf(&options[i2], "%s", pointer);
}

/**
 * @brief Reads (possibly delimited) values from options using the form "name1: value1,value2,value3 name2: value4",
 * i.e. reads all characters from the corresponding name up to the next whitespace or end of string.
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_values(const char *options, const char *name, char *pointer) {
    long i1, i2;
    int i;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    i = 0;
    while (!isspace((unsigned char)options[i2 + i]) && (options[i2 + i] != '\0')) {
        pointer[i] = options[i2 + i];
        i++;
    }
    pointer[i] = '\0';
    return i;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods implementing functions on double values not contained in C89 standard
 */
/**@{*/

/**
 * @brief Rounds the given double to the nearest integer.
 */
static double IOHprofiler_double_round(const double number) {
    return floor(number + 0.5);
}

/**
 * @brief Returns the maximum of a and b.
 */
static double IOHprofiler_double_max(const double a, const double b) {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Returns the minimum of a and b.
 */
static double IOHprofiler_double_min(const double a, const double b) {
    if (a <= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Performs a "safer" double to size_t conversion.
 */
static size_t IOHprofiler_double_to_size_t(const double number) {
    return (size_t)IOHprofiler_double_round(number);
}

/**
 * @brief  Returns 1 if |a - b| < precision and 0 otherwise.
 */
static int IOHprofiler_double_almost_equal(const double a, const double b, const double precision) {
    return (fabs(a - b) < precision);
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods handling NAN and INFINITY
 */
/**@{*/

/**
 * @brief Returns 1 if x is NAN and 0 otherwise.
 */
static int IOHprofiler_is_nan(const int x) {
    /*return (isnan(x) || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
*/
    return (0 || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
}

/**
 * @brief Returns 1 if the input vector of dimension dim contains any NAN values and 0 otherwise.
 */
static int IOHprofiler_vector_contains_nan(const int *x, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        if (IOHprofiler_is_nan(x[i]))
            return 1;
    }
    return 0;
}

/**
 * @brief Sets all dim values of y to NAN.
 */
static void IOHprofiler_vector_set_to_nan(double *y, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        y[i] = NAN;
    }
}

/**
 * @brief Returns 1 if x is INFINITY and 0 otherwise.
 */
static int IOHprofiler_is_inf(const int x) {
    if (IOHprofiler_is_nan(x))
        return 0;
    /*return (isinf(x) || (x <= -INFINITY) || (x >= INFINITY));*/
    return (0 || (x <= -INFINITY) || (x >= INFINITY));
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Miscellaneous methods
 */
/**@{*/

/**
 * @brief Returns the current time as a string.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_current_time_get_string(void) {
    time_t timer;
    char *time_string = IOHprofiler_allocate_string(30);
    struct tm *tm_info;
    time(&timer);
    tm_info = localtime(&timer);
    assert(tm_info != NULL);
    strftime(time_string, 30, "%d.%m.%y %H:%M:%S", tm_info);
    return time_string;
}

/**
 * @brief Returns the number of positive numbers pointed to by numbers (the count stops when the first
 * 0 is encountered of max_count numbers have been read).
 *
 * If there are more than max_count numbers, a IOHprofiler_error is raised. The name argument is used
 * only to provide more informative output in case of any problems.
 */
static size_t IOHprofiler_count_numbers(const size_t *numbers, const size_t max_count, const char *name) {
    size_t count = 0;
    while ((count < max_count) && (numbers[count] != 0)) {
        count++;
    }
    if (count == max_count) {
        IOHprofiler_error("IOHprofiler_count_numbers(): over %lu numbers in %s", (unsigned long)max_count, name);
        return 0; /* Never reached*/
    }

    return count;
}

/**@}*/

/***********************************************************************************************************/
#endif
#line 13 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../profiler/IOHprofiler_problem.c"

/**
 * Evaluates the problem function, increases the number of evaluations and updates the best observed value
 * and the best observed evaluation number.
 *
 * @note Both x and y must point to correctly sized allocated memory regions.
 *
 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 * @param y The objective vector that is the result of the evaluation (in single-objective problems only the
 * first vector item is being set). Currently multi-objective is not supported.
 * @param number_of_parameters The number of parameters need to be logged. Set as zero by default.
 * @param parameters The list of parameters. Set as NULL by default.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {

    assert(problem != NULL);
    assert(problem->evaluate_function != NULL);
    problem->evaluate_function(problem, x, y);
    problem->evaluations++; /* each derived class has its own counter, only the most outer will be visible */

    /* A little bit of bookkeeping */
    if (y[0] > problem->best_observed_fvalue[0]) {
        problem->best_observed_fvalue[0] = y[0];
        problem->best_observed_evaluation[0] = problem->evaluations;
    }
}

/**
 * Evaluates and logs the given solution (as the IOHprofiler_evaluate_function), but does not return the evaluated
 * value.
 *
 * @note None of the observers implements this function yet!
 * @note x must point to a correctly sized allocated memory region.

 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    assert(problem != NULL);
    if (problem->recommend_solution == NULL) {
        IOHprofiler_error("IOHprofiler_recommend_solutions(): No recommend solution function implemented for problem %s",
                          problem->problem_id);
    }
    problem->recommend_solution(problem, x);
}

/**
 * @brief Allocates a new IOHprofiler_problem_t for the given number of variables and number of objectives.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate(const size_t number_of_variables,
                                                           const size_t number_of_objectives) {
    IOHprofiler_problem_t *problem;
    problem = (IOHprofiler_problem_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    /* Initialize fields to sane/safe defaults */
    problem->initial_solution = NULL;
    problem->evaluate_function = NULL;
    problem->recommend_solution = NULL;
    problem->problem_free_function = NULL;
    problem->dimension = number_of_variables;
    problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = number_of_objectives;
    problem->number_of_parameters = 0;
    problem->parameters = NULL;
    problem->smallest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->largest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_parameter = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_value = IOHprofiler_allocate_vector(number_of_objectives);
    problem->raw_fitness = IOHprofiler_allocate_vector(number_of_objectives);
    if (number_of_objectives > 1)
        problem->nadir_value = IOHprofiler_allocate_vector(number_of_objectives);
    else
        problem->nadir_value = NULL;
    problem->problem_name = NULL;
    problem->problem_id = NULL;
    problem->problem_type = NULL;
    problem->evaluations = 0;
    problem->final_target_delta[0] = 1e-8; /* in case to be modified by the benchmark */
    problem->best_observed_fvalue[0] = DBL_MIN_EXP;
    problem->best_observed_evaluation[0] = 0;
    problem->suite = NULL; /* To be initialized in the IOHprofiler_suite_get_problem_from_indices() function */
    problem->suite_dep_index = 0;
    problem->suite_dep_function = 0;
    problem->suite_dep_instance = 0;
    problem->data = NULL;
    return problem;
}

/**
 * @brief Creates a duplicate of the 'other' problem for all fields except for data, which points to NULL.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_duplicate(const IOHprofiler_problem_t *other) {
    size_t i;
    IOHprofiler_problem_t *problem;
    problem = IOHprofiler_problem_allocate(other->number_of_variables, other->number_of_objectives);

    problem->dimension = other->dimension;
    problem->initial_solution = other->initial_solution;
    problem->evaluate_function = other->evaluate_function;
    problem->recommend_solution = other->recommend_solution;
    problem->problem_free_function = other->problem_free_function;

    for (i = 0; i < problem->number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = other->smallest_values_of_interest[i];
        problem->largest_values_of_interest[i] = other->largest_values_of_interest[i];
        if (other->best_parameter)
            problem->best_parameter[i] = other->best_parameter[i];
    }

    if (other->best_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->best_value[i] = other->best_value[i];
        }

    if (other->nadir_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->nadir_value[i] = other->nadir_value[i];
        }

    if (other->raw_fitness)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->raw_fitness[i] = other->raw_fitness[i];
        }

    problem->number_of_parameters = other->number_of_parameters;
    for (i = 0; i < problem->number_of_parameters; ++i) {
        problem->parameters[i] = other->parameters[i];
    }

    problem->problem_name = IOHprofiler_strdup(other->problem_name);
    problem->problem_id = IOHprofiler_strdup(other->problem_id);
    problem->problem_type = IOHprofiler_strdup(other->problem_type);

    problem->evaluations = other->evaluations;
    problem->final_target_delta[0] = other->final_target_delta[0];
    problem->best_observed_fvalue[0] = other->best_observed_fvalue[0];
    problem->best_observed_evaluation[0] = other->best_observed_evaluation[0];

    problem->suite = other->suite;
    problem->suite_dep_index = other->suite_dep_index;
    problem->suite_dep_function = other->suite_dep_function;
    problem->suite_dep_instance = other->suite_dep_instance;

    problem->data = NULL;

    return problem;
}

/**
 * @brief Allocates a problem using scalar values for smallest_value_of_interest, largest_value_of_interest
 * and best_parameter.
 * Note that the number of objectives is set as 1 by default.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate_from_scalars(const char *problem_name,
                                                                        IOHprofiler_evaluate_function_t evaluate_function,
                                                                        IOHprofiler_problem_free_function_t problem_free_function,
                                                                        const size_t number_of_variables,
                                                                        const int smallest_value_of_interest,
                                                                        const int largest_value_of_interest,
                                                                        const int best_parameter) {
    size_t i;

    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate(number_of_variables, 1);

    problem->problem_name = IOHprofiler_strdup(problem_name);
    /*problem->dimension = number_of_variables;
    */problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = 1;
    problem->evaluate_function = evaluate_function;
    problem->problem_free_function = problem_free_function;

    for (i = 0; i < number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = smallest_value_of_interest;
        problem->largest_values_of_interest[i] = largest_value_of_interest;
        problem->best_parameter[i] = best_parameter;
    }
    return problem;
}

void IOHprofiler_problem_free(IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (problem->problem_free_function != NULL) {
        problem->problem_free_function(problem);
    } else {
        /* Best guess at freeing all relevant structures */
        if (problem->smallest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->smallest_values_of_interest);
        if (problem->largest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->largest_values_of_interest);
        if (problem->best_parameter != NULL)
            IOHprofiler_free_memory(problem->best_parameter);
        if (problem->best_value != NULL)
            IOHprofiler_free_memory(problem->best_value);
        if (problem->raw_fitness != NULL)
            IOHprofiler_free_memory(problem->raw_fitness);
        if (problem->nadir_value != NULL)
            IOHprofiler_free_memory(problem->nadir_value);
        if (problem->problem_name != NULL)
            IOHprofiler_free_memory(problem->problem_name);
        if (problem->problem_id != NULL)
            IOHprofiler_free_memory(problem->problem_id);
        if (problem->problem_type != NULL)
            IOHprofiler_free_memory(problem->problem_type);
        if (problem->data != NULL)
            IOHprofiler_free_memory(problem->data);
        if (problem->parameters != NULL)
            IOHprofiler_free_memory(problem->parameters);
        problem->smallest_values_of_interest = NULL;
        problem->largest_values_of_interest = NULL;
        problem->best_parameter = NULL;
        problem->best_value = NULL;
        problem->raw_fitness = NULL;
        problem->nadir_value = NULL;
        problem->suite = NULL;
        problem->data = NULL;
        problem->parameters = NULL;
        IOHprofiler_free_memory(problem);
    }
}

/**
 * @brief Checks whether the given string is in the right format to be a problem_id.
 *
 * No non-alphanumeric characters besides '-', '_' and '.' are allowed.
 */
static int IOHprofiler_problem_id_is_fine(const char *id, ...) {
    va_list args;
    const int reject = 0;
    const int accept = 1;
    const char *cp;
    char *s;
    int result = accept;

    va_start(args, id);
    s = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    for (cp = s; *cp != '\0'; ++cp) {
        if (('A' <= *cp) && (*cp <= 'Z'))
            continue;
        if (('a' <= *cp) && (*cp <= 'z'))
            continue;
        if ((*cp == '_') || (*cp == '-'))
            continue;
        if (('0' <= *cp) && (*cp <= '9'))
            continue;
        result = reject;
    }
    IOHprofiler_free_memory(s);
    return result;
}

/**
 * @brief Sets the problem_parameters.
 *
 */
void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters) {
    size_t i;
    if (number_of_parameters != 0) {
        problem->number_of_parameters = number_of_parameters;
        if (problem->parameters != NULL) {
            IOHprofiler_free_memory(problem->parameters);
        }
        problem->parameters = IOHprofiler_allocate_vector(number_of_parameters);
        for (i = 0; i < problem->number_of_parameters; ++i) {
            problem->parameters[i] = parameters[i];
        }
    }
}

/**
 * @brief Sets the problem_id using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation and verifies that the problem_id is in the correct format.
 */
static void IOHprofiler_problem_set_id(IOHprofiler_problem_t *problem, const char *id, ...) {
    va_list args;

    va_start(args, id);
    if (problem->problem_id != NULL)
        IOHprofiler_free_memory(problem->problem_id);
    problem->problem_id = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    if (!IOHprofiler_problem_id_is_fine(problem->problem_id)) {
        IOHprofiler_error("Problem id should only contain standard chars, not like '%s'", problem->problem_id);
    }
}

/**
 * @brief Sets the problem_name using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_name(IOHprofiler_problem_t *problem, const char *name, ...) {
    va_list args;

    va_start(args, name);
    if (problem->problem_name != NULL)
        IOHprofiler_free_memory(problem->problem_name);
    problem->problem_name = IOHprofiler_vstrdupf(name, args);
    va_end(args);
}

/**
 * @brief Sets the problem_type using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_type(IOHprofiler_problem_t *problem, const char *type, ...) {
    va_list args;

    va_start(args, type);
    if (problem->problem_type != NULL)
        IOHprofiler_free_memory(problem->problem_type);
    problem->problem_type = IOHprofiler_vstrdupf(type, args);
    va_end(args);
}

size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->evaluations;
}

/**
 * @brief Returns 1 if the best parameter is not (close to) zero and 0 otherwise.
 */
static int IOHprofiler_problem_best_parameter_not_zero(const IOHprofiler_problem_t *problem) {
    size_t i = 0;
    int best_is_zero = 1;

    if (IOHprofiler_vector_contains_nan(problem->best_parameter, problem->number_of_variables))
        return 1;

    while (i < problem->number_of_variables && best_is_zero) {
        best_is_zero = IOHprofiler_double_almost_equal(problem->best_parameter[i], 0, 1e-9);
        i++;
    }

    return !best_is_zero;
}

/**
 * @note Can be used to prevent unnecessary burning of CPU time.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (IOHprofiler_problem_get_number_of_objectives(problem) != 1 ||
        IOHprofiler_problem_get_evaluations(problem) < 1)
        return 0;
    if (problem->best_value == NULL)
        return 0;
    return problem->best_observed_fvalue[0] >= problem->best_value[0] - problem->final_target_delta[0] ? 1 : 0;
}

/**
 * @note Tentative...
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->best_observed_fvalue[0];
}

/**
 * @note This function breaks the black-box property: the returned  value is not
 * meant to be used by the optimization algorithm.
 */
double IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->best_value != NULL);
    assert(problem->final_target_delta != NULL);
    return problem->best_value[0] + problem->final_target_delta[0];
}

/**
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_name != NULL);
    return problem->problem_name;
}

/**
 * The ID is guaranteed to contain only characters in the set [a-z0-9_-]. It should therefore be safe to use
 * it to construct filenames or other identifiers.
 *
 * Each problem ID should be unique within each benchmark suite.
 *
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_id != NULL);
    return problem->problem_id;
}

const char *IOHprofiler_problem_get_type(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_type != NULL);
    return problem->problem_type;
}

size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->dimension > 0);
    return problem->dimension;
}

size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->number_of_objectives > 0);
    return problem->number_of_objectives;
}
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->smallest_values_of_interest != NULL);
    return problem->smallest_values_of_interest;
}

const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->largest_values_of_interest != NULL);
    return problem->largest_values_of_interest;
}

/**
 * If a special method for setting an initial solution to the problem does not exist, the center of the
 * problem's region of interest is the initial solution.
 * @param problem The given IOHprofiler problem.
 * @param initial_solution The pointer to the initial solution being set by this method.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution) {
    assert(problem != NULL);
    if (problem->initial_solution != NULL) {
        problem->initial_solution(problem, initial_solution);
    } else {
        size_t i;
        assert(problem->smallest_values_of_interest != NULL);
        assert(problem->largest_values_of_interest != NULL);
        for (i = 0; i < problem->number_of_variables; ++i)
            initial_solution[i] = (int)(problem->smallest_values_of_interest[i] + 0.5 * (problem->largest_values_of_interest[i] - problem->smallest_values_of_interest[i]));
    }
}

static IOHprofiler_suite_t *IOHprofiler_problem_get_suite(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite;
}

static void IOHprofiler_problem_set_suite(IOHprofiler_problem_t *problem, IOHprofiler_suite_t *suite) {
    assert(problem != NULL);
    problem->suite = suite;
}

size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite_dep_index;
}

static size_t IOHprofiler_problem_get_suite_dep_function(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_function > 0);
    return problem->suite_dep_function;
}

static size_t IOHprofiler_problem_get_suite_dep_instance(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_instance > 0);
    return problem->suite_dep_instance;
}

/**
 * @brief Returns the data of the transformed problem.
 */
static void *IOHprofiler_problem_transformed_get_data(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->data != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->data;
}

/**
 * @brief Returns the inner problem of the transformed problem.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_get_inner_problem(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the inner problem.
 */
static void IOHprofiler_problem_transformed_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_evaluate_function(data->inner_problem, x, y);
}

/**
 * @brief Calls the IOHprofiler_recommend_solution function on the inner problem.
 */
static void IOHprofiler_problem_transformed_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_recommend_solution(data->inner_problem, x);
}

/**
 * @brief Frees only the data of the transformed problem leaving the inner problem intact.
 *
 * @note If there is no other pointer to the inner problem, access to it will be lost.
 */
static void IOHprofiler_problem_transformed_free_data(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;

    if (data->data != NULL) {
        if (data->data_free_function != NULL) {
            data->data_free_function(data->data);
            data->data_free_function = NULL;
        }
        IOHprofiler_free_memory(data->data);
        data->data = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}

/**
 * @brief Frees the transformed problem.
 */
static void IOHprofiler_problem_transformed_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);
    if (data->inner_problem != NULL) {
        IOHprofiler_problem_free(data->inner_problem);
        data->inner_problem = NULL;
    }
    IOHprofiler_problem_transformed_free_data(problem);
}

/**
 * @brief Allocates a transformed problem that wraps the inner_problem.
 *
 * By default all methods will dispatch to the inner_problem. A prefix is prepended to the problem name
 * in order to reflect the transformation somewhere.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_allocate(IOHprofiler_problem_t *inner_problem,
                                                                       void *user_data,
                                                                       IOHprofiler_data_free_function_t data_free_function,
                                                                       const char *name_prefix) {
    IOHprofiler_problem_transformed_data_t *problem;
    IOHprofiler_problem_t *inner_copy;
    char *old_name = IOHprofiler_strdup(inner_problem->problem_name);

    problem = (IOHprofiler_problem_transformed_data_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    problem->inner_problem = inner_problem;
    problem->data = user_data;
    problem->data_free_function = data_free_function;

    inner_copy = IOHprofiler_problem_duplicate(inner_problem);
    inner_copy->evaluate_function = IOHprofiler_problem_transformed_evaluate_function;
    inner_copy->recommend_solution = IOHprofiler_problem_transformed_recommend_solution;
    inner_copy->problem_free_function = IOHprofiler_problem_transformed_free;
    inner_copy->data = problem;

    IOHprofiler_problem_set_name(inner_copy, "%s(%s)", name_prefix, old_name);
    IOHprofiler_free_memory(old_name);

    return inner_copy;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the underlying problems.
 */
static void IOHprofiler_problem_stacked_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_stacked_data_t *data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    assert(
        IOHprofiler_problem_get_number_of_objectives(problem) == IOHprofiler_problem_get_number_of_objectives(data->problem1) + IOHprofiler_problem_get_number_of_objectives(data->problem2));

    IOHprofiler_evaluate_function(data->problem1, x, &y[0]);
    IOHprofiler_evaluate_function(data->problem2, x, &y[IOHprofiler_problem_get_number_of_objectives(data->problem1)]);
}

/**
 * @brief Frees the stacked problem.
 */
static void IOHprofiler_problem_stacked_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_stacked_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    if (data->problem1 != NULL) {
        IOHprofiler_problem_free(data->problem1);
        data->problem1 = NULL;
    }
    if (data->problem2 != NULL) {
        IOHprofiler_problem_free(data->problem2);
        data->problem2 = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}
#endif
#line 9 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../suite/WModel/suite_WModel_legacy_code.c"
/**
 * @file suite_IOHprofiler_legacy_code.c
 * @brief Legacy code from required to replicate the IOHprofiler functions.
 *
 * All of this code should only be used by the suite_IOHprofiler functions to provide compatibility to the
 * legacy code. New test beds should strive to use the new IOHprofiler facilities for random number generation etc.
 */

#ifndef SUITE_WMODEL_LEGACY_CODE
#define SUITE_WMODEL_LEGACY_CODE
#ifndef SUITE_PBO_LEGACY_CODE
#define SUITE_PBO_LEGACY_CODE

#include <assert.h>
#include <math.h>
#include <stdio.h>

#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../suite/WModel/../../profiler/IOHprofiler.h"
/**
 * @file IOHprofiler.h
 * @brief All public IOHprofiler functions and variables are defined in this file.
 *
 * It is the authoritative reference, if any function deviates from the documented behavior it is considered
 * a bug. See the function definitions for their detailed descriptions.
 */

#ifndef __IOHprofiler_H__
#define __IOHprofiler_H__

#include <stddef.h>

/* Definitions of some 32 and 64-bit types (used by the random number generator) */
#ifdef _MSC_VER
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

/* Include definition for NAN among other things */
#include <float.h>
#include <math.h>
#ifndef NAN
/** @brief Definition of NAN to be used only if undefined by the included headers */
#define NAN 8.8888e88
#endif
#ifndef isnan
/** @brief Definition of isnan to be used only if undefined by the included headers */
#define isnan(x) (0)
#endif
#ifndef INFINITY
/** @brief Definition of INFINITY to be used only if undefined by the included headers */
#define INFINITY 1e22
/* why not using 1e99? */
#endif
#ifndef isinf
/** @brief Definition of isinf to be used only if undefined by the included headers */
#define isinf(x) (0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief IOHprofiler's version.
 *
 * Automatically updated by do.py.
 */
/**@{*/
static const char IOHprofiler_version[32] = "";
/**@}*/

/***********************************************************************************************************/
/**
 * @brief IOHprofiler's own pi constant. Simplifies the case, when the value of pi changes.
 */
/**@{*/
static const double IOHprofiler_pi = 3.14159265358979323846;
/**@}*/

/***********************************************************************************************************/

/** @brief Logging level type. */
typedef enum {
    IOHprofiler_ERROR,   /**< @brief only error messages are output */
    IOHprofiler_WARNING, /**< @brief error and warning messages are output */
    IOHprofiler_INFO,    /**< @brief error, warning and info messages are output */
    IOHprofiler_DEBUG    /**< @brief error, warning, info and debug messages are output */
} IOHprofiler_log_level_type_e;

/***********************************************************************************************************/

/** @brief Structure containing a IOHprofiler problem. */
struct IOHprofiler_problem_s;

/**
 * @brief The IOHprofiler problem type.
 *
 * See IOHprofiler_problem_s for more information on its fields. */
typedef struct IOHprofiler_problem_s IOHprofiler_problem_t;

/** @brief Structure containing a IOHprofiler suite. */
struct IOHprofiler_suite_s;

/**
 * @brief The IOHprofiler suite type.
 *
 * See IOHprofiler_suite_s for more information on its fields. */
typedef struct IOHprofiler_suite_s IOHprofiler_suite_t;

/** @brief Structure containing a IOHprofiler observer. */
struct IOHprofiler_observer_s;

/**
 * @brief The IOHprofiler observer type.
 *
 * See IOHprofiler_observer_s for more information on its fields. */
typedef struct IOHprofiler_observer_s IOHprofiler_observer_t;

/** @brief Structure containing a IOHprofiler archive. */
struct IOHprofiler_archive_s;

/**
 * @brief The IOHprofiler archive type.
 *
 * See IOHprofiler_archive_s for more information on its fields. */
typedef struct IOHprofiler_archive_s IOHprofiler_archive_t;

/** @brief Structure containing a IOHprofiler random state. */
struct IOHprofiler_random_state_s;

/**
 * @brief The IOHprofiler random state type.
 *
 * See IOHprofiler_random_state_s for more information on its fields. */
typedef struct IOHprofiler_random_state_s IOHprofiler_random_state_t;

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler suite
 */
/**@{*/

/**
 * @brief Constructs a IOHprofiler suite.
 */
IOHprofiler_suite_t *IOHprofiler_suite(const char *suite_name, const char *suite_instance, const char *suite_options,int number, char** layer_param,char * temp_dim);

/**
 * @brief Frees the given suite.
 */
void IOHprofiler_suite_free(IOHprofiler_suite_t *suite);

/**
 * @brief Returns the next (observed) problem of the suite or NULL if there is no next problem left.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_next_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 *
 * @returns The current problem of the suite.
 */
IOHprofiler_problem_t *IOHprofiler_suite_reset_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 * @brief Returns the problem of the suite defined by problem_index.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_problem(IOHprofiler_suite_t *suite, const size_t problem_index);

/**
 * @brief Returns the number of problems in the given suite.
 */
size_t IOHprofiler_suite_get_number_of_problems(const IOHprofiler_suite_t *suite);

/**
 * @brief Returns the function number in the suite in position function_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_function_from_function_index(const IOHprofiler_suite_t *suite, const size_t function_idx);

/**
 * @brief Returns the dimension number in the suite in position dimension_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_dimension_from_dimension_index(const IOHprofiler_suite_t *suite, const size_t dimension_idx);

/**
 * @brief Returns the instance number in the suite in position instance_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_instance_from_instance_index(const IOHprofiler_suite_t *suite, const size_t instance_idx);
/**@}*/

/**
 * @name Encoding/decoding problem index
 *
 * General schema for encoding/decoding a problem index. Note that the index depends on the number of
 * instances a suite is defined with (it should be called a suite-instance-depending index...).
 * Also, while functions, instances and dimensions start from 1, function_idx, instance_idx and dimension_idx
 * as well as suite_dep_index start from 0!
 *
 * Showing an example with 2 dimensions (2, 3), 5 instances (6, 7, 8, 9, 10) and 2 functions (1, 2):
 *
   \verbatim
   index | instance | function | dimension
   ------+----------+----------+-----------
       0 |        6 |        1 |         2
       1 |        7 |        1 |         2
       2 |        8 |        1 |         2
       3 |        9 |        1 |         2
       4 |       10 |        1 |         2
       5 |        6 |        2 |         2
       6 |        7 |        2 |         2
       7 |        8 |        2 |         2
       8 |        9 |        2 |         2
       9 |       10 |        2 |         2
      10 |        6 |        1 |         3
      11 |        7 |        1 |         3
      12 |        8 |        1 |         3
      13 |        9 |        1 |         3
      14 |       10 |        1 |         3
      15 |        6 |        2 |         2
      16 |        7 |        2 |         3
      17 |        8 |        2 |         3
      18 |        9 |        2 |         3
      19 |       10 |        2 |         3

   index | instance_idx | function_idx | dimension_idx
   ------+--------------+--------------+---------------
       0 |            0 |            0 |             0
       1 |            1 |            0 |             0
       2 |            2 |            0 |             0
       3 |            3 |            0 |             0
       4 |            4 |            0 |             0
       5 |            0 |            1 |             0
       6 |            1 |            1 |             0
       7 |            2 |            1 |             0
       8 |            3 |            1 |             0
       9 |            4 |            1 |             0
      10 |            0 |            0 |             1
      11 |            1 |            0 |             1
      12 |            2 |            0 |             1
      13 |            3 |            0 |             1
      14 |            4 |            0 |             1
      15 |            0 |            1 |             1
      16 |            1 |            1 |             1
      17 |            2 |            1 |             1
      18 |            3 |            1 |             1
      19 |            4 |            1 |             1
   \endverbatim
 */
/**@{*/
/**
 * @brief Computes the index of the problem in the suite that corresponds to the given function, dimension
 * and instance indices.
 */
size_t IOHprofiler_suite_encode_problem_index(const IOHprofiler_suite_t *suite,
                                              const size_t function_idx,
                                              const size_t dimension_idx,
                                              const size_t instance_idx);

/**
 * @brief Computes the function, dimension and instance indexes of the problem with problem_index in the
 * given suite.
 */
void IOHprofiler_suite_decode_problem_index(const IOHprofiler_suite_t *suite,
                                            const size_t problem_index,
                                            size_t *function_idx,
                                            size_t *dimension_idx,
                                            size_t *instance_idx);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler observer
 */
/**@{*/
/**
 * @brief Constructs a IOHprofiler observer.
 */
IOHprofiler_observer_t *IOHprofiler_observer(const char *observer_name, const char *options);

/**
 * @brief Frees the given observer.
 */
void IOHprofiler_observer_free(IOHprofiler_observer_t *observer);

/**
 * @brief Adds an observer to the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_add_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**
 * @brief Removes an observer from the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_remove_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler problem
 */
/**@{*/
/**
 * @brief Evaluates the problem function in point x and save the result in y.
  logger_** functions use number_of_parameters and parameters to log extra informations of algorithms' adaptive parameters.
  If there is no need to log parameters, set number_of_parameters and parameters as 0 and NULL respectively.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Evaluates the problem constraints in point x and save the result in y.
 */
void IOHprofiler_evaluate_constraint(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Recommends a solution as the current best guesses to the problem.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief Frees the given problem.
 */
void IOHprofiler_problem_free(IOHprofiler_problem_t *problem);

void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters);

/**
 * @brief Returns the name of the problem.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the ID of the problem.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of variables i.e. the dimension of the problem.
 */
size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of objectives of the problem.
 */
size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of evaluations done on the problem.
 */
size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns 1 if the final target was hit, 0 otherwise.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the best observed value for the first objective.
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the target value for the first objective.
 */
double depreciated_IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with lower bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with upper bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the problem_index of the problem in its current suite.
 */
size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns an initial solution, i.e. a feasible variable setting, to the problem.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding random numbers
 */
/**@{*/

/**
 * @brief Creates and returns a new random number state using the given seed.
 */
IOHprofiler_random_state_t *IOHprofiler_random_new(uint32_t seed);

/**
 * @brief Frees all memory associated with the random state.
 */
void IOHprofiler_random_free(IOHprofiler_random_state_t *state);

/**
 * @brief Returns one uniform [0, 1) random value from the random number generator associated with the given
 * state.
 */
double IOHprofiler_random_uniform(IOHprofiler_random_state_t *state);

/**
 * @brief Generates an approximately normal random number.
 */
double IOHprofiler_random_normal(IOHprofiler_random_state_t *state);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods managing memory
 */
/**@{*/
/**
 * @brief Safe memory allocation that either succeeds or triggers a IOHprofiler_error.
 */
void *IOHprofiler_allocate_memory(const size_t size);

/**
 * @brief Safe memory allocation for a vector of doubles that either succeeds or triggers a IOHprofiler_error.
 */
double *IOHprofiler_allocate_vector(const size_t size);

/**
 * @brief Safe memory allocation for a vector of int that either succeeds or triggers a IOHprofiler_error.
 */
int *IOHprofiler_allocate_int_vector(const size_t size);

/**
 * @brief Frees the allocated memory.
 */
void IOHprofiler_free_memory(void *data);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler messages
 */
/**@{*/
/**
 * @brief Signals a fatal error.
 */
void IOHprofiler_error(const char *message, ...);

/**
 * @brief Warns about error conditions.
 */
void IOHprofiler_warning(const char *message, ...);

/**
 * @brief Outputs some information.
 */
void IOHprofiler_info(const char *message, ...);

/**
 * @brief Prints only the given message without any prefix and new line.
 *
 * A function similar to IOHprofiler_info but producing no additional text than
 * the given message.
 *
 * The output is only produced if IOHprofiler_log_level >= IOHprofiler_INFO.
 */
void IOHprofiler_info_partial(const char *message, ...);

/**
 * @brief Outputs detailed information usually used for debugging.
 */
void IOHprofiler_debug(const char *message, ...);

/**
 * @brief Sets the IOHprofiler log level to the given value and returns the previous value of the log level.
 */
const char *IOHprofiler_set_log_level(const char *level);
/**@}*/

/***********************************************************************************************************/

/**
 * @brief Constructs a IOHprofiler archive.
 */
IOHprofiler_archive_t *IOHprofiler_archive(const char *suite_name,
                                           const size_t function,
                                           const size_t dimension,
                                           const size_t instance);
/**
 * @brief Adds a solution with objectives (y1, y2) to the archive if none of the existing solutions in the
 * archive dominates it. In this case, returns 1, otherwise the archive is not updated and the method
 * returns 0.
 */

int IOHprofiler_archive_add_solution(IOHprofiler_archive_t *archive, const double y1, const double y2, const char *text);

/**
 * @brief Returns the number of (non-dominated) solutions in the archive (computed first, if needed).
 */
size_t IOHprofiler_archive_get_number_of_solutions(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the hypervolume of the archive (computed first, if needed).
 */
double IOHprofiler_archive_get_hypervolume(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the text of the next (non-dominated) solution in the archive and "" when there are no
 * solutions left. The first two solutions are always the extreme ones.
 */
const char *IOHprofiler_archive_get_next_solution_text(IOHprofiler_archive_t *archive);

/**
 * @brief Frees the archive.
 */
void IOHprofiler_archive_free(IOHprofiler_archive_t *archive);

/***********************************************************************************************************/

/**
 * @name Other useful methods
 */
/**@{*/
/**
 * @brief Removes the given directory and all its contents.
 */
int IOHprofiler_remove_directory(const char *path);

/**
 * @brief Formatted string duplication.
 */
char *IOHprofiler_strdupf(const char *str, ...);
/**@}*/

/***********************************************************************************************************/
typedef int (*int_to_int_func)(int);

struct WModel{
  size_t number_of_layers;
  int *layer1;
  int min1; int_to_int_func l_max1;
  int *layer2;
  int min2;int_to_int_func l_max2;
  int *layer3;
  int min3; int_to_int_func l_max3;
  int *layer4;
  int min4; int_to_int_func l_max4;
  int *counter;
};


#ifdef __cplusplus
}
#endif
#endif
#line 19 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../suite/WModel/suite_WModel_legacy_code.c"

/** @brief Maximal dimension used in IOHprofiler. */
#define SUITE_IOHprofiler_MAX_DIM 5000

/** @brief Computes the minimum of the two values. */
static double IOHprofiler_fmin(double a, double b) {
    return (a < b) ? a : b;
}

/** @brief Computes the maximum of the two values. */
static double IOHprofiler_fmax(double a, double b) {
    return (a > b) ? a : b;
}

/** @brief Rounds the given value. */
static double IOHprofiler_round(double x) {
    return floor(x + 0.5);
}

/**
 * @brief Allocates a n by m matrix structured as an array of pointers to double arrays.
 */
static double **IOHprofiler_allocate_matrix(const size_t n, const size_t m) {
    double **matrix = NULL;
    size_t i;
    matrix = (double **)IOHprofiler_allocate_memory(sizeof(double *) * n);
    for (i = 0; i < n; ++i) {
        matrix[i] = IOHprofiler_allocate_vector(m);
    }
    return matrix;
}

/**
 * @brief Frees the matrix structured as an array of pointers to double arrays.
 */
static void IOHprofiler_free_matrix(double **matrix, const size_t n) {
    size_t i;
    for (i = 0; i < n; ++i) {
        if (matrix[i] != NULL) {
            IOHprofiler_free_memory(matrix[i]);
            matrix[i] = NULL;
        }
    }
    IOHprofiler_free_memory(matrix);
}

/**
 * @brief Generates N uniform random numbers using inseed as the seed and stores them in r.
 */
static void IOHprofiler_unif(double *r, size_t N, long inseed) {
    long aktseed;
    if (inseed < 0)
        inseed = -inseed;
    if (inseed < 1)
        inseed = 1;
    aktseed = inseed; 
    int i;
    IOHprofiler_random_state_t *random_generator=IOHprofiler_random_new(aktseed);
    for(i=0;i<N;i++){
       r[i]=IOHprofiler_random_uniform(random_generator);
    }
    IOHprofiler_random_free(random_generator);
}
    /* generates N uniform numbers with starting seed */
/*    long aktseed;
    long tmp;
    long rgrand[32];
    long aktrand;
    long i;

    if (inseed < 0)
        inseed = -inseed;
    if (inseed < 1)
        inseed = 1;
    aktseed = inseed;
    for (i = 39; i >= 0; i--) {
        tmp = (int)floor((double)aktseed / (double)127773);
        aktseed = 16807 * (aktseed - tmp * 127773) - 2836 * tmp;
        if (aktseed < 0)
            aktseed = aktseed + 2147483647;
        if (i < 32)
            rgrand[i] = aktseed;
    }
    aktrand = rgrand[0];
    for (i = 0; i < N; i++) {
        tmp = (int)floor((double)aktseed / (double)127773);
        aktseed = 16807 * (aktseed - tmp * 127773) - 2836 * tmp;
        if (aktseed < 0)
            aktseed = aktseed + 2147483647;
        tmp = (int)floor((double)aktrand / (double)67108865);
        aktrand = rgrand[tmp];
        rgrand[tmp] = aktseed;
        r[i] = (double)aktrand / 2.147483647e9;
        if (r[i] == 0.) {
            r[i] = 1e-99;
        }
    }
    return;
}*/

/**
 * @brief Converts from packed matrix storage to an array of array of double representation.
 */
static double **IOHprofiler_reshape(double **B, double *vector, const size_t m, const size_t n) {
    size_t i, j;
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            B[i][j] = vector[j * m + i];
        }
    }
    return B;
}

/**
 * @brief Generates N Gaussian random numbers using the given seed and stores them in g.
 */
static void IOHprofiler_gauss(double *g, const size_t N, const long seed) {
    size_t i;
    double uniftmp[6000];
    assert(2 * N < 6000);
    IOHprofiler_unif(uniftmp, 2 * N, seed);

    for (i = 0; i < N; i++) {
        g[i] = sqrt(-2 * log(uniftmp[i])) * cos(2 * IOHprofiler_pi * uniftmp[N + i]);
        if (g[i] == 0.)
            g[i] = 1e-99;
    }
    return;
}

/**
 * @brief Computes a DIM by DIM rotation matrix based on seed and stores it in B.
 */
static void IOHprofiler_compute_rotation(double **B, const long seed, const size_t DIM) {
    /* To ensure temporary data fits into gvec */
    double prod;
    double gvect[2000];
    long i, j, k; /* Loop over pairs of column vectors. */

    assert(DIM * DIM < 2000);

    IOHprofiler_gauss(gvect, DIM * DIM, seed);
    IOHprofiler_reshape(B, gvect, DIM, DIM);
    /*1st coordinate is row, 2nd is column.*/

    for (i = 0; i < DIM; i++) {
        for (j = 0; j < i; j++) {
            prod = 0;
            for (k = 0; k < DIM; k++)
                prod += B[k][i] * B[k][j];
            for (k = 0; k < DIM; k++)
                B[k][i] -= prod * B[k][j];
        }
        prod = 0;
        for (k = 0; k < DIM; k++)
            prod += B[k][i] * B[k][i];
        for (k = 0; k < DIM; k++)
            B[k][i] /= sqrt(prod);
    }
}

static void IOHprofiler_copy_rotation_matrix(double **rot, double *M, double *b, const size_t DIM) {
    size_t row, column;
    double *current_row;

    for (row = 0; row < DIM; ++row) {
        current_row = M + row * DIM;
        for (column = 0; column < DIM; ++column) {
            current_row[column] = rot[row][column];
        }
        b[row] = 0.0;
    }
}

/**
 * @brief Randomly computes the location of the global optimum.
 */
static void IOHprofiler_compute_xopt(int *xopt, const long seed, const size_t DIM) {
    long i;
    double *xopttemp;
    xopttemp = IOHprofiler_allocate_vector(DIM);
    IOHprofiler_unif(xopttemp, DIM, seed);
    for (i = 0; i < DIM; i++) {
        xopt[i] = (int)(2 * floor(1e4 * xopttemp[i]) / 1e4 / 1);
    }
    IOHprofiler_free_memory(xopttemp);
}

/**
 * @brief Randomly computes the location of the global optimum.
 */
static void IOHprofiler_compute_xopt_double(double *xopt, const long seed, const size_t DIM) {
    long i;
    IOHprofiler_unif(xopt, DIM, seed);
    for (i = 0; i < DIM; i++) {
        xopt[i] = floor(1e4 * xopt[i]) / 1e4;
        if (xopt[i] == 0.0)
            xopt[i] = -1e-5;
    }
}

/**
 * @brief Randomly chooses the objective offset for the given function and instance.
 */
static double IOHprofiler_compute_fopt(const size_t function, const size_t instance) {
  long rseed, rrseed;
  double gval, gval2;


  rseed = (long) function;

  rrseed = rseed + (long) (10000 * instance);
  IOHprofiler_gauss(&gval, 1, rrseed);
  IOHprofiler_gauss(&gval2, 1, rrseed + 1);
  return IOHprofiler_fmin(1000., IOHprofiler_fmax(-1000., IOHprofiler_round(100. * 100. * gval / gval2) / 100.));
}
#endif
#endif
#line 10 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../suite/WModel/utils.c"
#ifndef UTILS
#define UTILS

#define MAX_PARAMETER 1000
#define MAX_CHAR 5
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../suite/WModel/../../profiler/IOHprofiler_string.c"
/**
 * @file IOHprofiler_string.c
 * @brief Definitions of functions that manipulate strings.
 */
#ifndef IOH_PROFILER_STRING
#define IOH_PROFILER_STRING

#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#line 13 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../suite/WModel/../../profiler/IOHprofiler_string.c"

static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements);

/**
 * @brief Creates a duplicate copy of string and returns a pointer to it.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strdup(const char *string) {
    size_t len;
    char *duplicate;
    if (string == NULL)
        return NULL;
    len = strlen(string);
    duplicate = (char *)IOHprofiler_allocate_memory(len + 1);
    memcpy(duplicate, string, len + 1);
    return duplicate;
}

/**
 * @brief The length of the buffer used in the IOHprofiler_vstrdupf function.
 *
 * @note This should be handled differently!
 */
#define IOHprofiler_VSTRDUPF_BUFLEN 444

/**
 * @brief Formatted string duplication, with va_list arguments.
 */
static char *IOHprofiler_vstrdupf(const char *str, va_list args) {
    static char buf[IOHprofiler_VSTRDUPF_BUFLEN];
    long written;
    /* apparently args can only be used once, therefore
   * len = vsnprintf(NULL, 0, str, args) to find out the
   * length does not work. Therefore we use a buffer
   * which limits the max length. Longer strings should
   * never appear anyway, so this is rather a non-issue. */

#if 0
  written = vsnprintf(buf, IOHprofiler_VSTRDUPF_BUFLEN - 2, str, args);
  if (written < 0)
  IOHprofiler_error("IOHprofiler_vstrdupf(): vsnprintf failed on '%s'", str);
#else /* less safe alternative, if vsnprintf is not available */
    assert(strlen(str) < IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2);
    if (strlen(str) >= IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2)
        IOHprofiler_error("IOHprofiler_vstrdupf(): string is too long");
    written = vsprintf(buf, str, args);
    if (written < 0)
        IOHprofiler_error("IOHprofiler_vstrdupf(): vsprintf failed on '%s'", str);
#endif
    if (written > IOHprofiler_VSTRDUPF_BUFLEN - 3)
        IOHprofiler_error("IOHprofiler_vstrdupf(): A suspiciously long string is tried to being duplicated '%s'", buf);
    return IOHprofiler_strdup(buf);
}

#undef IOHprofiler_VSTRDUPF_BUFLEN

/**
 * Optional arguments are used like in sprintf.
 */
char *IOHprofiler_strdupf(const char *str, ...) {
    va_list args;
    char *s;

    va_start(args, str);
    s = IOHprofiler_vstrdupf(str, args);
    va_end(args);
    return s;
}

/**
 * @brief Returns a concatenate copy of string1 + string2.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strconcat(const char *s1, const char *s2) {
    size_t len1 = strlen(s1);
    size_t len2 = strlen(s2);
    char *s = (char *)IOHprofiler_allocate_memory(len1 + len2 + 1);

    memcpy(s, s1, len1);
    memcpy(&s[len1], s2, len2 + 1);
    return s;
}

/**
 * @brief Returns the first index where seq occurs in base and -1 if it doesn't.
 *
 * @note If there is an equivalent standard C function, this can/should be removed.
 */
static long IOHprofiler_strfind(const char *base, const char *seq) {
    const size_t strlen_seq = strlen(seq);
    const size_t last_first_idx = strlen(base) - strlen(seq);
    size_t i, j;

    if (strlen(base) < strlen(seq))
        return -1;

    for (i = 0; i <= last_first_idx; ++i) {
        if (base[i] == seq[0]) {
            for (j = 0; j < strlen_seq; ++j) {
                if (base[i + j] != seq[j])
                    break;
            }
            if (j == strlen_seq) {
                if (i > 1e9)
                    IOHprofiler_error("IOHprofiler_strfind(): strange values observed i=%lu, j=%lu, strlen(base)=%lu",
                                      (unsigned long)i, (unsigned long)j, (unsigned long)strlen(base));
                return (long)i;
            }
        }
    }
    return -1;
}

/**
 * @brief Splits a string based on the given delimiter.
 *
 * Returns a pointer to the resulting substrings with NULL as the last one.
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char **IOHprofiler_string_split(const char *string, const char delimiter) {
    char **result;
    char *str_copy, *ptr, *token;
    char str_delimiter[2];
    size_t i;
    size_t count = 1;

    str_copy = IOHprofiler_strdup(string);

    /* Counts the parts between delimiters */
    ptr = str_copy;
    while (*ptr != '\0') {
        if (*ptr == delimiter) {
            count++;
        }
        ptr++;
    }
    /* Makes room for an empty string that will be appended at the end */
    count++;

    result = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));

    /* Iterates through tokens
   * NOTE: strtok() ignores multiple delimiters, therefore the final number of detected substrings might be
   * lower than the count. This is OK. */
    i = 0;
    /* A char* delimiter needs to be used, otherwise strtok() can surprise */
    str_delimiter[0] = delimiter;
    str_delimiter[1] = '\0';
    token = strtok(str_copy, str_delimiter);
    while (token) {
        assert(i < count);
        *(result + i++) = IOHprofiler_strdup(token);
        token = strtok(NULL, str_delimiter);
    }
    *(result + i) = NULL;

    IOHprofiler_free_memory(str_copy);

    return result;
}

/**
 * @brief Creates and returns a string with removed characters between from and to.
 *
 * If you wish to remove characters from the beginning of the string, set from to "".
 * If you wish to remove characters until the end of the string, set to to "".
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_remove_from_string(const char *string, const char *from, const char *to) {
    char *result, *start, *stop;

    result = IOHprofiler_strdup(string);

    if (strcmp(from, "") == 0) {
        /* Remove from the start */
        start = result;
    } else
        start = strstr(result, from);

    if (strcmp(to, "") == 0) {
        /* Remove until the end */
        stop = result + strlen(result);
    } else
        stop = strstr(result, to);

    if ((start == NULL) || (stop == NULL) || (stop < start)) {
        IOHprofiler_error("IOHprofiler_remove_from_string(): failed to remove characters between %s and %s from string %s",
                          from, to, string);
        return NULL; /* Never reached */
    }

    memmove(start, stop, strlen(stop) + 1);

    return result;
}

/**
 * @brief Returns the numbers defined by the ranges.
 *
 * Reads ranges from a string of positive ranges separated by commas. For example: "-3,5-6,8-". Returns the
 * numbers that are defined by the ranges if min and max are used as their extremes. If the ranges with open
 * beginning/end are not allowed, use 0 as min/max. The returned string has an appended 0 to mark its end.
 * A maximum of max_count values is returned. If there is a problem with one of the ranges, the parsing stops
 * and the current result is returned. The memory of the returned object needs to be freed by the caller.
 */
static size_t *IOHprofiler_string_parse_ranges(const char *string,
                                               const size_t min,
                                               const size_t max,
                                               const char *name,
                                               const size_t max_count) {
    char *ptr, *dash = NULL;
    char **ranges, **numbers;
    size_t i, j, count;
    size_t num[2];

    size_t *result;
    size_t i_result = 0;

    char *str = IOHprofiler_strdup(string);

    /* Check for empty string */
    if ((str == NULL) || (strlen(str) == 0)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): cannot parse empty ranges");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    ptr = str;
    /* Check for disallowed characters */
    while (*ptr != '\0') {
        if ((*ptr != '-') && (*ptr != ',') && !isdigit((unsigned char)*ptr)) {
            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - cannot parse ranges with '%c'", str,
                                *ptr);
            IOHprofiler_free_memory(str);
            return NULL;
        } else
            ptr++;
    }
    /* Check for incorrect boundaries */
    if ((max > 0) && (min > max)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): incorrect boundaries");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    result = IOHprofiler_allocate_vector_size_t(max_count + 1);

    /* Split string to ranges w.r.t commas */
    ranges = IOHprofiler_string_split(str, ',');
    IOHprofiler_free_memory(str);
    if (ranges) {
        /* Go over the current range */
        for (i = 0; *(ranges + i); i++) {
            ptr = *(ranges + i);
            /* Count the number of '-' */
            count = 0;
            while (*ptr != '\0') {
                if (*ptr == '-') {
                    if (count == 0)
                        /* Remember the position of the first '-' */
                        dash = ptr;
                    count++;
                }
                ptr++;
            }
            /* Point again to the start of the range */
            ptr = *(ranges + i);

            /* Check for incorrect number of '-' */
            if (count > 1) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - too many '-'s", string);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            } else if (count == 0) {
                /* Range is in the format: n (no range) */
                num[0] = (size_t)strtol(ptr, NULL, 10);
                num[1] = num[0];
            } else {
                /* Range is in one of the following formats: n-m / -n / n- / - */

                /* Split current range to numbers w.r.t '-' */
                numbers = IOHprofiler_string_split(ptr, '-');
                j = 0;
                if (numbers) {
                    /* Read the numbers */
                    for (j = 0; *(numbers + j); j++) {
                        assert(j < 2);
                        num[j] = (size_t)strtol(*(numbers + j), NULL, 10);
                        IOHprofiler_free_memory(*(numbers + j));
                    }
                }
                IOHprofiler_free_memory(numbers);

                if (j == 0) {
                    /* Range is in the format - (open ends) */
                    if ((min == 0) || (max == 0)) {
                        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open ends; some ranges ignored", name);
                        /* Cleanup */
                        for (j = i; *(ranges + j); j++)
                            IOHprofiler_free_memory(*(ranges + j));
                        IOHprofiler_free_memory(ranges);
                        if (i_result == 0) {
                            IOHprofiler_free_memory(result);
                            return NULL;
                        }
                        result[i_result] = 0;
                        return result;
                    }
                    num[0] = min;
                    num[1] = max;
                } else if (j == 1) {
                    if (dash - *(ranges + i) == 0) {
                        /* Range is in the format -n */
                        if (min == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open beginning; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = num[0];
                        num[0] = min;
                    } else {
                        /* Range is in the format n- */
                        if (max == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open end; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = max;
                    }
                }
                /* if (j == 2), range is in the format n-m and there is nothing to do */
            }

            /* Make sure the boundaries are taken into account */
            if ((min > 0) && (num[0] < min)) {
                num[0] = min;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be >= %lu", name,
                                    (unsigned long)min);
              }
            if ((max > 0) && (num[1] > max)) {
                num[1] = max;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be <= %lu", name, (unsigned long) max);
            }
            if (num[0] > num[1]) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges not within boundaries; some ranges ignored", name);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            }

            /* Write in result */
            for (j = num[0]; j <= num[1]; j++) {
                if (i_result > max_count - 1)
                    break;
                result[i_result++] = j;
            }

            IOHprofiler_free_memory(*(ranges + i));
            *(ranges + i) = NULL;
        }
    }

    IOHprofiler_free_memory(ranges);

    if (i_result == 0) {
        IOHprofiler_free_memory(result);
        return NULL;
    }

    result[i_result] = 0;
    return result;
}

/**
 * @brief Trims the given string (removes any leading and trailing spaces).
 *
 * If the string contains any leading spaces, the contents are shifted so that if it was dynamically
 * allocated, it can be still freed on the returned pointer.
 */
static char *IOHprofiler_string_trim(char *string) {
    size_t len = 0;
    char *frontp = string;
    char *endp = NULL;

    if (string == NULL) {
        return NULL;
    }
    if (string[0] == '\0') {
        return string;
    }

    len = strlen(string);
    endp = string + len;

    /* Move the front and back pointers to address the first non-whitespace characters from each end. */
    while (isspace((unsigned char)*frontp)) {
        ++frontp;
    }
    if (endp != frontp) {
        while (isspace((unsigned char)*(--endp)) && endp != frontp) {
        }
    }

    if (string + len - 1 != endp)
        *(endp + 1) = '\0';
    else if (frontp != string && endp == frontp)
        *string = '\0';

    /* Shift the string. Note the reuse of endp to mean the front of the string buffer now. */
    endp = string;
    if (frontp != string) {
        while (*frontp) {
            *endp++ = *frontp++;
        }
        *endp = '\0';
    }

    return string;
}
#endif
#line 7 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../suite/WModel/utils.c"
#line 8 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../suite/WModel/utils.c"

static int layer_number;
/*static char **layer_para;*/
static char * dimensions;

#define BUFF 50
/*
 * this files contains basic functions about parameters for the layer
*/
static int layer_para[4] ={0,0,0,0};

int * copy_and_realloc(const int *src, const size_t number_of_elements,int new_size);
/*old*/
/*
void init_parameters(int number,char**lp){
  layer_number=number;
  layer_parameters=lp;

}*/
/*old*/
int number_of_op(size_t * layer){
  int i=1,sum=1;
  if (layer==NULL){return 0;}
  while(*(layer+i)!=0){
    sum++;i++;
  }
  return sum;
}
void pr_para(int * p){
fprintf(stderr,"%d  ",p[0]);
fprintf(stderr,"%d  ",p[1]);
fprintf(stderr,"%d  ",p[2]);
fprintf(stderr,"%d \n",p[3]);
}
int compute_problem_dimension(int dim,int du,int ne){
  int output_dim =dim;
  if(du>dim){return 0;}
  output_dim = (int)(output_dim- (int)(du));
  if(ne>0 && ne<output_dim){
    output_dim=(int)(output_dim/ (ne));
  }else if(ne<0 || ne>=output_dim){ return 0;}
/*  if(output_dim<4){fprintf(stderr,"\n dim %d du %d ne %d dim %d\n",dim,du,ne,output_dim);}*/
  return output_dim;
}
int correct_epistasis(int dim,int * ep){
  int sum;
  sum=0;
  int i=0;
  do{
    if (ep[i] !=0 && ep[i]<dim){sum++;}
    i++;
  }while(ep[i]!=0);
  return sum;
}
int correct_ruggedness(int dim,int * ru){
  int sum;
  sum=0;
  int i=0;
  do{
    if (ru[i]<(dim*(dim-1))/2){sum++;}
    i++;
  }while(ru[i]!=0);
  return sum;
}
float dim_proportion(int dim,int dum,int neutr){
  if(neutr==0){return ( 100-dum);}

/*  fprintf(stderr,"%d %d %f  res %d\n",dum,neutr,(100.-dum)/neutr,(100.-dum)/neutr>=5);*/
  return  (100.-dum)/neutr;
}
int is_correct_problem(const int dim, const int dum,const int neutr){
/*  if (dim_proportion(dim,dum,neutr)>=(float) 1/dim){return 1;}*/
  if (dim_proportion(dim,dum,neutr)>=5){return 1;}
  
  else{return 0;}
}
int valid(int dim, int du, int ne, int ep,int ru){
/*  if(ep==5){fprintf(stderr,"ep %d val %d \n",ep,!(ep !=0 && ep<dim));}*/
  if(!(ru<=(dim*(dim-1))/2)){return 0;}
  if(!(ep !=0 && ep<dim)){return 0;}
  return is_correct_problem(dim, du, ne);
}
int nb_elt(int *l){
  int s=0;
  do{s++;
  }while(l[s]!=0);
  return s;
}
int get_real_value(int dim,int min,int_to_int_func f,int ind){
  int max=f(dim);
  int res= (min+((int) (ind*(max-min)/100)));
  return res;
}
typedef struct  WModel WModel;
/*Count total number of problem based on the number of layer*their range*/
int compute_number_of_functions(WModel *wm,int dimension){
    int dim=dimension;
    int i;
    int * dummy=IOHprofiler_allocate_int_vector(nb_elt(wm->layer1));
    for(i=0;i<nb_elt(wm->layer1);i++){dummy[i]=get_real_value(dimension,wm->min1,wm->l_max1,wm->layer1[i]);}
    int * neutr=IOHprofiler_allocate_int_vector(nb_elt(wm->layer2));
    for(i=0;i<nb_elt(wm->layer2);i++){neutr[i]=get_real_value(dimension,wm->min2,wm->l_max2,wm->layer2[i]);}
    int * epis=IOHprofiler_allocate_int_vector(nb_elt(wm->layer3));
    for(i=0;i<nb_elt(wm->layer3);i++){epis[i]=get_real_value(dimension,wm->min3,wm->l_max3,wm->layer3[i]);}
    int * rugg=IOHprofiler_allocate_int_vector(nb_elt(wm->layer4));
    for(i=0;i<nb_elt(wm->layer4);i++){rugg[i]=get_real_value(dimension,wm->min4,wm->l_max4,wm->layer4[i]);}
    int b,c,d,e,sum,temp;
    sum=0;
    c=0;
    b=0;
    temp=0;
    d=nb_elt(wm->layer3);
    e=nb_elt(wm->layer4);
    do{c=0;
      do{
        temp+=is_correct_problem(dim,wm->layer1[b],wm->layer2[c]);
        c++;
      }while(c <nb_elt(wm->layer2));
      b++;
    }while(b<nb_elt(wm->layer1));
    sum+=temp*d*e;
/*    fprintf(stderr,"\n-------- dim %d sum %d ---------\n",dim,sum);*/
/*
for(i=0;i<nb_elt(wm->layer1);i++){fprintf(stderr," %d ",dummy[i]);}
fprintf(stderr,"\n");
for(i=0;i<nb_elt(wm->layer2);i++){fprintf(stderr," %d ",neutr[i]);}
fprintf(stderr,"\n");
for(i=0;i<nb_elt(wm->layer3);i++){fprintf(stderr," %d ",epis[i]);}
fprintf(stderr,"\n");
for(i=0;i<nb_elt(wm->layer4);i++){fprintf(stderr," %d ",rugg[i]);}
fprintf(stderr,"\nsum %d\n",sum);*/
    IOHprofiler_free_memory(dummy);
    IOHprofiler_free_memory(neutr);
    IOHprofiler_free_memory(epis);
    IOHprofiler_free_memory(rugg);
    return sum;
}



int * get_WModel_parameters(WModel* wm){

  int *res=IOHprofiler_allocate_int_vector(wm->number_of_layers);
  res[0]=wm->layer1[wm->counter[0]];
  res[1]=wm->layer2[wm->counter[1]];
  res[2]=wm->layer3[wm->counter[2]];
  if(wm->counter[3] >=0){
    res[3]=wm->layer4[wm->counter[3]];
  }else {res[3]=0;}
  return res;
}
int * get_real_parameters(int dim,WModel * wm){
  int * p=get_WModel_parameters(wm);
  int *res=IOHprofiler_allocate_int_vector(wm->number_of_layers);
  res[0]=get_real_value(dim,wm->min1,wm->l_max1,p[0]);
  res[1]=get_real_value(dim,wm->min2,wm->l_max2,p[1]);
  res[2]=get_real_value(dim,wm->min3,wm->l_max3,p[2]);
  res[3]=get_real_value(dim,wm->min4,wm->l_max4,p[3]);
  IOHprofiler_free_memory(p);
  return res;
}
static int * get_layers_parameters(void);
void increment_layers_param(WModel * wm,int dim){
int * temp1,temp2;
int x=0;


/*-----------------------------------------------*/
  if (wm->counter[3]<nb_elt(wm->layer4)-1){
    wm->counter[3]++;
  }else if(wm->counter[3]==nb_elt(wm->layer4)-1){
    wm->counter[3]=0;
    if (wm->counter[2]<nb_elt(wm->layer3)-1){
      wm->counter[2]++;
    }else if(wm->counter[2]==nb_elt(wm->layer3)-1){
     wm->counter[2]=0;
     if (wm->counter[1]<nb_elt(wm->layer2)-1){
       wm->counter[1]++;
      }else if(wm->counter[1]==nb_elt(wm->layer2)-1){
        wm->counter[1]=0;
        if (wm->counter[0]<nb_elt(wm->layer1)-1){
          wm->counter[0]++;
        }else if(wm->counter[0]==nb_elt(wm->layer1)-1){
          wm->counter[0]=0;
        }
      }
    }
  }
  int * r=get_real_parameters(dim,wm);
  int * r2=get_WModel_parameters(wm);
  if(!valid(dim, r2[0],r2[1],r[2],r[3]))
    {  IOHprofiler_free_memory(r);IOHprofiler_free_memory(r2);
       increment_layers_param(wm, dim);}
  else{IOHprofiler_free_memory(r);IOHprofiler_free_memory(r2);}
  r=get_WModel_parameters(wm);
  int i;
  for(i=0;i<4;i++){layer_para[i]=r[i];}
  IOHprofiler_free_memory(r);

}



char* get_name_problem(int id_problem, struct WModel * wm){
  int * para;
  char *name;
  para=get_WModel_parameters(wm);
  name=malloc(sizeof(char)*100);
    
/*  if(id_problem==1){
/*    sprintf(name, "one_max_dummy=%d_mu=%d_nu=%d_gamma=%d",layer_para[0],layer_para[1],layer_para[2],layer_para[3]);*/
    sprintf(name, "one_max_D%d_N%d_E%d_R%d",para[0],para[1],para[2],para[3]);
/*  }*/
  IOHprofiler_free_memory(para);
  return name;
}
char* get_name_problem2(int id_problem, int * para){
  char *name;
  name=malloc(sizeof(char)*100);
    
/*  if(id_problem==1){
/*    sprintf(name, "one_max_dummy=%d_mu=%d_nu=%d_gamma=%d",layer_para[0],layer_para[1],layer_para[2],layer_para[3]);*/
    sprintf(name, "one_max_D%d_N%d_E%d_R%d",para[0],para[1],para[2],para[3]);
/*  }*/
  return name;
}
/*old*//*
void incr(int ind){
  if(ind>0){
  size_t * p;
  p=IOHprofiler_string_parse_ranges(layer_parameters[layer_number-ind], 0, 0, "layer_parameter", MAX_PARAMETER);
  if (number_of_op(p)> (layer_para[layer_number-ind]+1)){
    layer_para[layer_number-ind]++;
  }else if(number_of_op(p)==(layer_para[layer_number-ind]+1)){
    layer_para[layer_number-ind]=0;
    incr(ind-1);
  }
  IOHprofiler_free_memory(p);
  }
}*/
/*old*//*
void incr_layer_para(void){
  int i;
  i=layer_number;
  incr(i);
}*/

static int * get_layers_parameters(void){
  int n_l=4;
  int * layer_values=IOHprofiler_allocate_int_vector(n_l);
  int i;

  for (i=0;i<n_l;i++){layer_values[i]=layer_para[i];}
  return layer_values;
}
/*
calcule la dimension du problem après les features du W-Model
casse un peu la modularité
*/

/*old*/

int compute_problem_get_dimension(int dim){
  int *p;
  p=get_layers_parameters();
  int output_dim =dim+1;
  if(p[0]>dim){return 0;}
  output_dim = output_dim- (int)(p[0]);
  if(p[1]>0 && p[1]<output_dim){
    output_dim=output_dim/ (p[1]);
/*  printf(".%d  %d %d\n",output_dim,p[1],output_dim/ (p[1]));*/
  }else if(p[1]<0 || p[1]>=output_dim){ return 0;}
  else if(p[2]>output_dim){return 0;}
  else if(p[3]>((output_dim-1)*(output_dim)/2)){return 0;}

/*  printf("%d  %d %d\n",p[0],p[1],output_dim);*/
  return output_dim;
}
/*old*/
/*Return a string of the layers parameters "k=a_mu=b_nu=c_gamma=d"*/
void get_name(int id_problem,char *name){
  int * para;
  para=get_layers_parameters();
  if(id_problem==1){
/*    sprintf(name, "one_max_dummy=%d_mu=%d_nu=%d_gamma=%d",layer_para[0],layer_para[1],layer_para[2],layer_para[3]);*/
    sprintf(name, "one_max_D%d_N%d_E%d_R%d",para[0],para[1],para[2],para[3]);
  }
  IOHprofiler_free_memory(para);
}

/*
 my own parser because at least it will work
*/
char * extract_number(char *l){
  char * res= IOHprofiler_allocate_memory(BUFF * sizeof(char *));
  if (strlen(l)==0 || l == NULL){
    res[0]=0;
  return res;
  }
  int i =0;
  while(isdigit(l[i])){
    res[i]=l[i];
    i+=1;
  }
  res[i]='\0';
  return res;
}
int* parse_range_layer(char * l){
  int i,j;
  int current_free_space=BUFF;
  int realloc=1;
  int nb_elt=0;
  int a,b,c;
  int * res= IOHprofiler_allocate_int_vector(BUFF);
  i=0;
  char * int_temp1;
  char * int_temp2;
  if (strlen(l)==0 || l == NULL){
    res[0]=0;
  return res;
  }
  while(i<=strlen(l) && l[i]!='\0'){
    if(isdigit(l[i])){
      int_temp1=extract_number(l+i);
      i+=strlen(int_temp1);
      if(l[i]=='\0'){
        if (current_free_space<=1){
         realloc+=1;
         res=copy_and_realloc(res,nb_elt,realloc*BUFF);
         current_free_space+=BUFF;
        }
        current_free_space-=1;
        res[nb_elt] = atoi((char*) int_temp1);
        nb_elt+=1;
        IOHprofiler_free_memory(int_temp1);
        i+=2;
      }else if(l[i]==','){
        if (current_free_space<=1){
         realloc+=1;
         res=copy_and_realloc(res,nb_elt,realloc*BUFF);
         current_free_space+=BUFF;
        }
        current_free_space-=1;
        res[nb_elt] = atoi((char*) int_temp1);
        nb_elt+=1;
        IOHprofiler_free_memory(int_temp1);
        i+=1;
      }else if(l[i]=='-'){
        i+=1;
        int_temp2=extract_number(l+i);
        i+=strlen(int_temp2);
        a=atoi(int_temp1);
        b=atoi(int_temp2);
        IOHprofiler_free_memory(int_temp1);
        IOHprofiler_free_memory(int_temp2);
        if(b<=a){IOHprofiler_error("parse layers wrong parameter1");}
        c=b-a;
        while (current_free_space<=c+1){
         realloc+=1;
         res=copy_and_realloc(res,nb_elt,realloc*BUFF);
         current_free_space+=BUFF;
        }
        for(j=0;j<=c;j++){
          res[nb_elt] = a+j;
          nb_elt+=1;
          current_free_space-=1;
        }if(l[i]!=',' && l[i]!='\0'){IOHprofiler_error("parse layers wrong parameter1");}
        i+=1;
      }
    }else{IOHprofiler_error("parse layers wrong parameter2");}
  }
  res[nb_elt]=0;
/*  for(i=0;i<=nb_elt;i++){
  fprintf(stderr,"\%d  ",res[i]);
} fprintf(stderr,"\n");*/
  return res;
}
int * copy_and_realloc(const int *src, const size_t number_of_elements,int new_size) {
    size_t i;
    int *dst;

    assert(src != NULL);
    assert(new_size > 0);

    dst = IOHprofiler_allocate_int_vector(new_size);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }IOHprofiler_free_memory(src);
    return dst;
}

#endif
#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"

/*Load layers of WModel*/
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/ruggedness.c"
/**
 * @file transform_obj_ruggedness1.c
 * @brief Implementation of ruggedness1ing the objective value by the given offset.
 */
#ifndef RUGGEDNESS
#define RUGGEDNESS

#include <assert.h>
#include <math.h>
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler.h"
/**
 * @file IOHprofiler.h
 * @brief All public IOHprofiler functions and variables are defined in this file.
 *
 * It is the authoritative reference, if any function deviates from the documented behavior it is considered
 * a bug. See the function definitions for their detailed descriptions.
 */

#ifndef __IOHprofiler_H__
#define __IOHprofiler_H__

#include <stddef.h>

/* Definitions of some 32 and 64-bit types (used by the random number generator) */
#ifdef _MSC_VER
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

/* Include definition for NAN among other things */
#include <float.h>
#include <math.h>
#ifndef NAN
/** @brief Definition of NAN to be used only if undefined by the included headers */
#define NAN 8.8888e88
#endif
#ifndef isnan
/** @brief Definition of isnan to be used only if undefined by the included headers */
#define isnan(x) (0)
#endif
#ifndef INFINITY
/** @brief Definition of INFINITY to be used only if undefined by the included headers */
#define INFINITY 1e22
/* why not using 1e99? */
#endif
#ifndef isinf
/** @brief Definition of isinf to be used only if undefined by the included headers */
#define isinf(x) (0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief IOHprofiler's version.
 *
 * Automatically updated by do.py.
 */
/**@{*/
static const char IOHprofiler_version[32] = "";
/**@}*/

/***********************************************************************************************************/
/**
 * @brief IOHprofiler's own pi constant. Simplifies the case, when the value of pi changes.
 */
/**@{*/
static const double IOHprofiler_pi = 3.14159265358979323846;
/**@}*/

/***********************************************************************************************************/

/** @brief Logging level type. */
typedef enum {
    IOHprofiler_ERROR,   /**< @brief only error messages are output */
    IOHprofiler_WARNING, /**< @brief error and warning messages are output */
    IOHprofiler_INFO,    /**< @brief error, warning and info messages are output */
    IOHprofiler_DEBUG    /**< @brief error, warning, info and debug messages are output */
} IOHprofiler_log_level_type_e;

/***********************************************************************************************************/

/** @brief Structure containing a IOHprofiler problem. */
struct IOHprofiler_problem_s;

/**
 * @brief The IOHprofiler problem type.
 *
 * See IOHprofiler_problem_s for more information on its fields. */
typedef struct IOHprofiler_problem_s IOHprofiler_problem_t;

/** @brief Structure containing a IOHprofiler suite. */
struct IOHprofiler_suite_s;

/**
 * @brief The IOHprofiler suite type.
 *
 * See IOHprofiler_suite_s for more information on its fields. */
typedef struct IOHprofiler_suite_s IOHprofiler_suite_t;

/** @brief Structure containing a IOHprofiler observer. */
struct IOHprofiler_observer_s;

/**
 * @brief The IOHprofiler observer type.
 *
 * See IOHprofiler_observer_s for more information on its fields. */
typedef struct IOHprofiler_observer_s IOHprofiler_observer_t;

/** @brief Structure containing a IOHprofiler archive. */
struct IOHprofiler_archive_s;

/**
 * @brief The IOHprofiler archive type.
 *
 * See IOHprofiler_archive_s for more information on its fields. */
typedef struct IOHprofiler_archive_s IOHprofiler_archive_t;

/** @brief Structure containing a IOHprofiler random state. */
struct IOHprofiler_random_state_s;

/**
 * @brief The IOHprofiler random state type.
 *
 * See IOHprofiler_random_state_s for more information on its fields. */
typedef struct IOHprofiler_random_state_s IOHprofiler_random_state_t;

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler suite
 */
/**@{*/

/**
 * @brief Constructs a IOHprofiler suite.
 */
IOHprofiler_suite_t *IOHprofiler_suite(const char *suite_name, const char *suite_instance, const char *suite_options,int number, char** layer_param,char * temp_dim);

/**
 * @brief Frees the given suite.
 */
void IOHprofiler_suite_free(IOHprofiler_suite_t *suite);

/**
 * @brief Returns the next (observed) problem of the suite or NULL if there is no next problem left.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_next_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 *
 * @returns The current problem of the suite.
 */
IOHprofiler_problem_t *IOHprofiler_suite_reset_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 * @brief Returns the problem of the suite defined by problem_index.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_problem(IOHprofiler_suite_t *suite, const size_t problem_index);

/**
 * @brief Returns the number of problems in the given suite.
 */
size_t IOHprofiler_suite_get_number_of_problems(const IOHprofiler_suite_t *suite);

/**
 * @brief Returns the function number in the suite in position function_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_function_from_function_index(const IOHprofiler_suite_t *suite, const size_t function_idx);

/**
 * @brief Returns the dimension number in the suite in position dimension_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_dimension_from_dimension_index(const IOHprofiler_suite_t *suite, const size_t dimension_idx);

/**
 * @brief Returns the instance number in the suite in position instance_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_instance_from_instance_index(const IOHprofiler_suite_t *suite, const size_t instance_idx);
/**@}*/

/**
 * @name Encoding/decoding problem index
 *
 * General schema for encoding/decoding a problem index. Note that the index depends on the number of
 * instances a suite is defined with (it should be called a suite-instance-depending index...).
 * Also, while functions, instances and dimensions start from 1, function_idx, instance_idx and dimension_idx
 * as well as suite_dep_index start from 0!
 *
 * Showing an example with 2 dimensions (2, 3), 5 instances (6, 7, 8, 9, 10) and 2 functions (1, 2):
 *
   \verbatim
   index | instance | function | dimension
   ------+----------+----------+-----------
       0 |        6 |        1 |         2
       1 |        7 |        1 |         2
       2 |        8 |        1 |         2
       3 |        9 |        1 |         2
       4 |       10 |        1 |         2
       5 |        6 |        2 |         2
       6 |        7 |        2 |         2
       7 |        8 |        2 |         2
       8 |        9 |        2 |         2
       9 |       10 |        2 |         2
      10 |        6 |        1 |         3
      11 |        7 |        1 |         3
      12 |        8 |        1 |         3
      13 |        9 |        1 |         3
      14 |       10 |        1 |         3
      15 |        6 |        2 |         2
      16 |        7 |        2 |         3
      17 |        8 |        2 |         3
      18 |        9 |        2 |         3
      19 |       10 |        2 |         3

   index | instance_idx | function_idx | dimension_idx
   ------+--------------+--------------+---------------
       0 |            0 |            0 |             0
       1 |            1 |            0 |             0
       2 |            2 |            0 |             0
       3 |            3 |            0 |             0
       4 |            4 |            0 |             0
       5 |            0 |            1 |             0
       6 |            1 |            1 |             0
       7 |            2 |            1 |             0
       8 |            3 |            1 |             0
       9 |            4 |            1 |             0
      10 |            0 |            0 |             1
      11 |            1 |            0 |             1
      12 |            2 |            0 |             1
      13 |            3 |            0 |             1
      14 |            4 |            0 |             1
      15 |            0 |            1 |             1
      16 |            1 |            1 |             1
      17 |            2 |            1 |             1
      18 |            3 |            1 |             1
      19 |            4 |            1 |             1
   \endverbatim
 */
/**@{*/
/**
 * @brief Computes the index of the problem in the suite that corresponds to the given function, dimension
 * and instance indices.
 */
size_t IOHprofiler_suite_encode_problem_index(const IOHprofiler_suite_t *suite,
                                              const size_t function_idx,
                                              const size_t dimension_idx,
                                              const size_t instance_idx);

/**
 * @brief Computes the function, dimension and instance indexes of the problem with problem_index in the
 * given suite.
 */
void IOHprofiler_suite_decode_problem_index(const IOHprofiler_suite_t *suite,
                                            const size_t problem_index,
                                            size_t *function_idx,
                                            size_t *dimension_idx,
                                            size_t *instance_idx);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler observer
 */
/**@{*/
/**
 * @brief Constructs a IOHprofiler observer.
 */
IOHprofiler_observer_t *IOHprofiler_observer(const char *observer_name, const char *options);

/**
 * @brief Frees the given observer.
 */
void IOHprofiler_observer_free(IOHprofiler_observer_t *observer);

/**
 * @brief Adds an observer to the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_add_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**
 * @brief Removes an observer from the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_remove_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler problem
 */
/**@{*/
/**
 * @brief Evaluates the problem function in point x and save the result in y.
  logger_** functions use number_of_parameters and parameters to log extra informations of algorithms' adaptive parameters.
  If there is no need to log parameters, set number_of_parameters and parameters as 0 and NULL respectively.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Evaluates the problem constraints in point x and save the result in y.
 */
void IOHprofiler_evaluate_constraint(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Recommends a solution as the current best guesses to the problem.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief Frees the given problem.
 */
void IOHprofiler_problem_free(IOHprofiler_problem_t *problem);

void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters);

/**
 * @brief Returns the name of the problem.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the ID of the problem.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of variables i.e. the dimension of the problem.
 */
size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of objectives of the problem.
 */
size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of evaluations done on the problem.
 */
size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns 1 if the final target was hit, 0 otherwise.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the best observed value for the first objective.
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the target value for the first objective.
 */
double depreciated_IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with lower bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with upper bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the problem_index of the problem in its current suite.
 */
size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns an initial solution, i.e. a feasible variable setting, to the problem.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding random numbers
 */
/**@{*/

/**
 * @brief Creates and returns a new random number state using the given seed.
 */
IOHprofiler_random_state_t *IOHprofiler_random_new(uint32_t seed);

/**
 * @brief Frees all memory associated with the random state.
 */
void IOHprofiler_random_free(IOHprofiler_random_state_t *state);

/**
 * @brief Returns one uniform [0, 1) random value from the random number generator associated with the given
 * state.
 */
double IOHprofiler_random_uniform(IOHprofiler_random_state_t *state);

/**
 * @brief Generates an approximately normal random number.
 */
double IOHprofiler_random_normal(IOHprofiler_random_state_t *state);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods managing memory
 */
/**@{*/
/**
 * @brief Safe memory allocation that either succeeds or triggers a IOHprofiler_error.
 */
void *IOHprofiler_allocate_memory(const size_t size);

/**
 * @brief Safe memory allocation for a vector of doubles that either succeeds or triggers a IOHprofiler_error.
 */
double *IOHprofiler_allocate_vector(const size_t size);

/**
 * @brief Safe memory allocation for a vector of int that either succeeds or triggers a IOHprofiler_error.
 */
int *IOHprofiler_allocate_int_vector(const size_t size);

/**
 * @brief Frees the allocated memory.
 */
void IOHprofiler_free_memory(void *data);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler messages
 */
/**@{*/
/**
 * @brief Signals a fatal error.
 */
void IOHprofiler_error(const char *message, ...);

/**
 * @brief Warns about error conditions.
 */
void IOHprofiler_warning(const char *message, ...);

/**
 * @brief Outputs some information.
 */
void IOHprofiler_info(const char *message, ...);

/**
 * @brief Prints only the given message without any prefix and new line.
 *
 * A function similar to IOHprofiler_info but producing no additional text than
 * the given message.
 *
 * The output is only produced if IOHprofiler_log_level >= IOHprofiler_INFO.
 */
void IOHprofiler_info_partial(const char *message, ...);

/**
 * @brief Outputs detailed information usually used for debugging.
 */
void IOHprofiler_debug(const char *message, ...);

/**
 * @brief Sets the IOHprofiler log level to the given value and returns the previous value of the log level.
 */
const char *IOHprofiler_set_log_level(const char *level);
/**@}*/

/***********************************************************************************************************/

/**
 * @brief Constructs a IOHprofiler archive.
 */
IOHprofiler_archive_t *IOHprofiler_archive(const char *suite_name,
                                           const size_t function,
                                           const size_t dimension,
                                           const size_t instance);
/**
 * @brief Adds a solution with objectives (y1, y2) to the archive if none of the existing solutions in the
 * archive dominates it. In this case, returns 1, otherwise the archive is not updated and the method
 * returns 0.
 */

int IOHprofiler_archive_add_solution(IOHprofiler_archive_t *archive, const double y1, const double y2, const char *text);

/**
 * @brief Returns the number of (non-dominated) solutions in the archive (computed first, if needed).
 */
size_t IOHprofiler_archive_get_number_of_solutions(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the hypervolume of the archive (computed first, if needed).
 */
double IOHprofiler_archive_get_hypervolume(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the text of the next (non-dominated) solution in the archive and "" when there are no
 * solutions left. The first two solutions are always the extreme ones.
 */
const char *IOHprofiler_archive_get_next_solution_text(IOHprofiler_archive_t *archive);

/**
 * @brief Frees the archive.
 */
void IOHprofiler_archive_free(IOHprofiler_archive_t *archive);

/***********************************************************************************************************/

/**
 * @name Other useful methods
 */
/**@{*/
/**
 * @brief Removes the given directory and all its contents.
 */
int IOHprofiler_remove_directory(const char *path);

/**
 * @brief Formatted string duplication.
 */
char *IOHprofiler_strdupf(const char *str, ...);
/**@}*/

/***********************************************************************************************************/
typedef int (*int_to_int_func)(int);

struct WModel{
  size_t number_of_layers;
  int *layer1;
  int min1; int_to_int_func l_max1;
  int *layer2;
  int min2;int_to_int_func l_max2;
  int *layer3;
  int min3; int_to_int_func l_max3;
  int *layer4;
  int min4; int_to_int_func l_max4;
  int *counter;
};


#ifdef __cplusplus
}
#endif
#endif
#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/ruggedness.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_problem.c"
/**
 * @file IOHprofiler_problem.c
 * @brief Definitions of functions regarding IOHprofiler problems.
 */
#ifndef IOH_PROFILER_PROBLEM
#define IOH_PROFILER_PROBLEM

#include <float.h>
#line 10 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_internal.h"
/**
 * @file IOHprofiler_internal.h
 * @brief Definitions of internal IOHprofiler structures and typedefs.
 *
 * These are used throughout the IOHprofiler code base but should not be used by any external code.
 */

#ifndef __IOHprofiler_INTERNAL__
#define __IOHprofiler_INTERNAL__

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************************************/
/**
 * @brief The data free function type.
 *
 * This is a template for functions that free the contents of data (used to free the contents of data
 * fields in IOHprofiler_problem, IOHprofiler_suite and IOHprofiler_observer).
 */
typedef void (*IOHprofiler_data_free_function_t)(void *data);

/**
 * @brief The problem free function type.
 *
 * This is a template for functions that free the problem structure.
 */
typedef void (*IOHprofiler_problem_free_function_t)(IOHprofiler_problem_t *problem);

/**
 * @brief The initial solution function type.
 *
 * This is a template for functions that return an initial solution of the problem.
 */
typedef void (*IOHprofiler_initial_solution_function_t)(const IOHprofiler_problem_t *problem, int *x);

/**
 * @brief The evaluate function type.
 *
 * This is a template for functions that perform an evaluation of the problem (to evaluate the problem
 * function, the problems constraints etc.).
 */
typedef void (*IOHprofiler_evaluate_function_t)(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief The recommend solutions function type.
 *
 * This is a template for functions that log a recommended solution.
 */
typedef void (*IOHprofiler_recommend_function_t)(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief The allocate logger function type.
 *
 * This is a template for functions that allocate a logger (wrap a logger around the given problem and return
 * the wrapped problem).
 */
typedef IOHprofiler_problem_t *(*IOHprofiler_logger_allocate_function_t)(IOHprofiler_observer_t *observer,
                                                                         IOHprofiler_problem_t *problem);

/**
 * @brief The transformed IOHprofiler problem data type.
 *
 * This is a type of a generic structure for a transformed ("outer") IOHprofiler_problem. It makes possible the
 * wrapping of problems as layers of an onion. Initialized in the IOHprofiler_problem_transformed_allocate function,
 * it makes the current ("outer") transformed problem a "derived problem class", which inherits from the
 * "inner" problem, the "base class".
 *
 * From the perspective of the inner problem:
 * - data holds the meta-information to administer the inheritance
 * - data->data holds the additional fields of the derived class (the outer problem)
 * - data->inner_problem points to the inner problem (now we have a linked list)
 */
typedef struct {
    IOHprofiler_problem_t *inner_problem;                /**< @brief Pointer to the inner problem */
    void *data;                                          /**< @brief Pointer to data, which enables further
                                                  wrapping of the problem */
    IOHprofiler_data_free_function_t data_free_function; /**< @brief Function to free the contents of data */
} IOHprofiler_problem_transformed_data_t;

/**
 * @brief The free logger function type.
 *
 * This is a template for functions that free a logger.
 */
typedef void (*IOHprofiler_logger_free_function_t)(void *logger);

/**
 * @brief The stacked IOHprofiler problem data type.
 *
 * This is a type of a structure used when stacking two problems (especially useful for constructing
 * multi-objective problems).
 */
typedef struct {
    IOHprofiler_problem_t *problem1; /**< @brief Pointer to the first problem (objective) */
    IOHprofiler_problem_t *problem2; /**< @brief Pointer to the second problem (objective) */
} IOHprofiler_problem_stacked_data_t;

/**
 * @brief The option keys data type.
 *
 * This is a type of a structure used to contain a set of known option keys (used by suites and observers).
 */
typedef struct {
    size_t count; /**< @brief Number of option keys */
    char **keys;  /**< @brief Pointer to option keys */
} IOHprofiler_option_keys_t;

/***********************************************************************************************************/

/**
 * @brief The IOHprofiler problem structure.
 *
 * This is one of the main structures in IOHprofiler. It contains information about a problem to be optimized. The
 * problems can be wrapped around each other (similar to the onion layers) by means of the data field and
 * the IOHprofiler_problem_transformed_data_t structure creating some kind of "object inheritance". Even the logger
 * is considered as just another IOHprofiler_problem instance wrapped around the original problem.
 */
struct IOHprofiler_problem_s {
    IOHprofiler_initial_solution_function_t initial_solution;  /**< @brief  The function for creating an initial solution. */
    IOHprofiler_evaluate_function_t evaluate_function;         /**< @brief  The function for evaluating the problem. */
    IOHprofiler_recommend_function_t recommend_solution;       /**< @brief  The function for recommending a solution. */
    IOHprofiler_problem_free_function_t problem_free_function; /**< @brief  The function for freeing this problem. */

    size_t dimension; /**< @brief Number of variables expected before any transformation, used for logging files. */
    size_t number_of_variables;  /**< @brief Number of variables expected by the function, i.e.
                                       problem dimension */
    size_t number_of_objectives; /**< @brief Number of objectives. */
    size_t number_of_parameters; /**<  IOHprofiler @brief Number of parameters. */

    int *smallest_values_of_interest; /**< @brief The lower bounds of the ROI in the decision space. */
    int *largest_values_of_interest;  /**< @brief The upper bounds of the ROI in the decision space. */

    double *best_value;  /**< @brief Optimal (smallest) function value */
    double *nadir_value; /**< @brief The nadir point (defined when number_of_objectives > 1) */
    int *best_parameter; /**< @brief Optimal decision vector (defined only when unique) */
    double *parameters;  /** IOHprofiler @brief parameters setting */
    double *raw_fitness;

    char *problem_name; /**< @brief Problem name. */
    char *problem_id;   /**< @brief Problem ID (unique in the containing suite) */
    char *problem_type; /**< @brief Problem type */

    size_t evaluations; /**< @brief Number of evaluations performed on the problem. */

    /* Convenience fields for output generation */

    double final_target_delta[1];       /**< @brief Final target delta. */
    double best_observed_fvalue[1];     /**< @brief The best observed value so far. */
    size_t best_observed_evaluation[1]; /**< @brief The evaluation when the best value so far was achieved. */

    /* Fields depending on the containing benchmark suite */

    IOHprofiler_suite_t *suite; /**< @brief Pointer to the containing suite (NULL if not given) */
    size_t suite_dep_index;     /**< @brief Suite-depending problem index (starting from 0) */
    size_t suite_dep_function;  /**< @brief Suite-depending function */
    size_t suite_dep_instance;  /**< @brief Suite-depending instance */

    void *data; /**< @brief Pointer to a data instance @see IOHprofiler_problem_transformed_data_t */
};

/**
 * @brief The IOHprofiler observer structure.
 *
 * An observer observes the whole benchmark process. It is independent of suites and problems. Each time a
 * new problem of the suite is being observed, the observer initializes a new logger (wraps the observed
 * problem with the corresponding logger).
 */
struct IOHprofiler_observer_s {
    int is_active;         /**< @brief Whether the observer is active (the logger will log some output). */
    char *observer_name;   /**< @brief Name of the observer for identification purposes. */
    char *result_folder;   /**< @brief Name of the result folder. */
    char *algorithm_name;  /**< @brief Name of the algorithm to be used in logger output. */
    char *algorithm_info;  /**< @brief Additional information on the algorithm to be used in logger output. */
    char *parameters_name; /**< @brief Name of recorded parameters to be used in logger output. */
    size_t number_target_triggers;
    /**< @brief The number of targets between each 10**i and 10**(i+1). */
    double target_precision; /**< @brief The minimal precision used for targets. */
    size_t number_evaluation_triggers;
    /**< @brief The number of triggers between each 10**i and 10**(i+1) evaluation number. */
    char *base_evaluation_triggers;
    /**< @brief The "base evaluations" used to evaluations that trigger logging. */
    size_t number_interval_triggers;
    /**< @brief The size of interval between two triggers. */
    char *complete_triggers; /**< @brief The symbol for recording all evaluation. */

    int precision_x; /**< @brief Output precision for decision variables. */
    int precision_f; /**< @brief Output precision for function values. */
    void *data;      /**< @brief Void pointer that can be used to point to data specific to an observer. */

    IOHprofiler_data_free_function_t data_free_function;             /**< @brief  The function for freeing this observer. */
    IOHprofiler_logger_allocate_function_t logger_allocate_function; /**< @brief  The function for allocating the logger. */
    IOHprofiler_logger_free_function_t logger_free_function;         /**< @brief  The function for freeing the logger. */
};

/**
 * @brief The IOHprofiler suite structure.
 *
 * A suite is a collection of problems constructed by a Cartesian product of the suite's optimization
 * functions, dimensions and instances. The functions and dimensions are fixed for a suite with some name,
 * while the instances are defined dynamically. The suite can be filtered - only the chosen functions,
 * dimensions and instances will be taken into account when iterating through the suite.
 */
struct IOHprofiler_suite_s {
    char *suite_name; /**< @brief Name of the suite. */

    size_t number_of_dimensions; /**< @brief Number of dimensions contained in the suite. */
    size_t *dimensions;          /**< @brief The dimensions contained in the suite. */

    size_t number_of_functions; /**< @brief Number of functions contained in the suite. */
    size_t *functions;          /**< @brief The functions contained in the suite. */

    size_t number_of_instances; /**< @brief Number of instances contained in the suite. */
    char *default_instances;    /**< @brief The instances contained in the suite by default. */
    size_t *instances;          /**< @brief The instances contained in the suite. */

    IOHprofiler_problem_t *current_problem; /**< @brief Pointer to the currently tackled problem. */
    long current_dimension_idx;             /**< @brief The dimension index of the currently tackled problem. */
    long current_function_idx;              /**< @brief The function index of the currently tackled problem. */
    long current_instance_idx;              /**< @brief The instance index of the currently tackled problem. */

    void *data; /**< @brief Void pointer that can be used to point to data specific to a suite. */

    IOHprofiler_data_free_function_t data_free_function; /**< @brief The function for freeing this suite. */
};

#ifdef __cplusplus
}
#endif
#endif
#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_problem.c"

#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_utilities.c"
/**
 * @file IOHprofiler_utilities.c
 * @brief Definitions of miscellaneous functions used throughout the IOHprofiler framework.
 */
#ifndef IOH_PROFILER_UTILITIES
#define IOH_PROFILER_UTILITIES

#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_platform.h"
/**
 * @file IOHprofiler_platform.h
 * @brief Automatic platform-dependent configuration of the IOHprofiler framework.
 *
 * Some platforms and standard conforming compilers require extra defines or includes to provide some
 * functionality.
 *
 * Because most feature defines need to be set before the first system header is included and we do not
 * know when a system header is included for the first time in the amalgamation, all internal files
 * that need these definitions should include this file before any system headers.
 */

#ifndef __COCO_PLATFORM__
#define __COCO_PLATFORM__

#include <stddef.h>

/* Definitions of IOHprofiler_PATH_MAX, IOHprofiler_path_separator, HAVE_GFA and HAVE_STAT heavily used by functions in
 * IOHprofiler_utilities.c */
#if defined(_WIN32) || defined(_WIN64) || defined(__MINGW64__) || defined(__CYGWIN__)
#include <windows.h>
static const char *IOHprofiler_path_separator = "\\";
#define IOHprofiler_PATH_MAX MAX_PATH
#define HAVE_GFA 1
#elif defined(__gnu_linux__)
#include <linux/limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__APPLE__)
#include <sys/stat.h>
#include <sys/syslimits.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__FreeBSD__)
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif (defined(__sun) || defined(sun)) && (defined(__SVR4) || defined(__svr4__))
/* Solaris */
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#else
#error Unknown platform
#endif
#if !defined(IOHprofiler_PATH_MAX)
#error IOHprofiler_PATH_MAX undefined
#endif

/* Definitions needed for creating and removing directories */
/* Separately handle the special case of Microsoft Visual Studio 2008 with x86_64-w64-mingw32-gcc */
#if _MSC_VER
#include <direct.h>
#elif defined(__MINGW32__) || defined(__MINGW64__)
#include <dirent.h>
#else
#include <dirent.h>

#ifdef __cplusplus
extern "C" {
#endif

/* To silence the compiler (implicit-function-declaration warning). */
/** @cond */
int rmdir(const char *pathname);
int unlink(const char *file_name);
int mkdir(const char *pathname, mode_t mode);
/** @endcond */
#endif

/* Definition of the S_IRWXU constant needed to set file permissions */
#if defined(HAVE_GFA)
#define S_IRWXU 0700
#endif

/* To silence the Visual Studio compiler (C4996 warnings in the python build). */
#ifdef _MSC_VER
#pragma warning(disable : 4996)
#endif

#ifdef __cplusplus
}
#endif

#endif
#line 9 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_utilities.c"

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#line 18 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_utilities.c"
#line 19 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_utilities.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_string.c"
/**
 * @file IOHprofiler_string.c
 * @brief Definitions of functions that manipulate strings.
 */
#ifndef IOH_PROFILER_STRING
#define IOH_PROFILER_STRING

#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#line 13 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_string.c"

static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements);

/**
 * @brief Creates a duplicate copy of string and returns a pointer to it.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strdup(const char *string) {
    size_t len;
    char *duplicate;
    if (string == NULL)
        return NULL;
    len = strlen(string);
    duplicate = (char *)IOHprofiler_allocate_memory(len + 1);
    memcpy(duplicate, string, len + 1);
    return duplicate;
}

/**
 * @brief The length of the buffer used in the IOHprofiler_vstrdupf function.
 *
 * @note This should be handled differently!
 */
#define IOHprofiler_VSTRDUPF_BUFLEN 444

/**
 * @brief Formatted string duplication, with va_list arguments.
 */
static char *IOHprofiler_vstrdupf(const char *str, va_list args) {
    static char buf[IOHprofiler_VSTRDUPF_BUFLEN];
    long written;
    /* apparently args can only be used once, therefore
   * len = vsnprintf(NULL, 0, str, args) to find out the
   * length does not work. Therefore we use a buffer
   * which limits the max length. Longer strings should
   * never appear anyway, so this is rather a non-issue. */

#if 0
  written = vsnprintf(buf, IOHprofiler_VSTRDUPF_BUFLEN - 2, str, args);
  if (written < 0)
  IOHprofiler_error("IOHprofiler_vstrdupf(): vsnprintf failed on '%s'", str);
#else /* less safe alternative, if vsnprintf is not available */
    assert(strlen(str) < IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2);
    if (strlen(str) >= IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2)
        IOHprofiler_error("IOHprofiler_vstrdupf(): string is too long");
    written = vsprintf(buf, str, args);
    if (written < 0)
        IOHprofiler_error("IOHprofiler_vstrdupf(): vsprintf failed on '%s'", str);
#endif
    if (written > IOHprofiler_VSTRDUPF_BUFLEN - 3)
        IOHprofiler_error("IOHprofiler_vstrdupf(): A suspiciously long string is tried to being duplicated '%s'", buf);
    return IOHprofiler_strdup(buf);
}

#undef IOHprofiler_VSTRDUPF_BUFLEN

/**
 * Optional arguments are used like in sprintf.
 */
char *IOHprofiler_strdupf(const char *str, ...) {
    va_list args;
    char *s;

    va_start(args, str);
    s = IOHprofiler_vstrdupf(str, args);
    va_end(args);
    return s;
}

/**
 * @brief Returns a concatenate copy of string1 + string2.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strconcat(const char *s1, const char *s2) {
    size_t len1 = strlen(s1);
    size_t len2 = strlen(s2);
    char *s = (char *)IOHprofiler_allocate_memory(len1 + len2 + 1);

    memcpy(s, s1, len1);
    memcpy(&s[len1], s2, len2 + 1);
    return s;
}

/**
 * @brief Returns the first index where seq occurs in base and -1 if it doesn't.
 *
 * @note If there is an equivalent standard C function, this can/should be removed.
 */
static long IOHprofiler_strfind(const char *base, const char *seq) {
    const size_t strlen_seq = strlen(seq);
    const size_t last_first_idx = strlen(base) - strlen(seq);
    size_t i, j;

    if (strlen(base) < strlen(seq))
        return -1;

    for (i = 0; i <= last_first_idx; ++i) {
        if (base[i] == seq[0]) {
            for (j = 0; j < strlen_seq; ++j) {
                if (base[i + j] != seq[j])
                    break;
            }
            if (j == strlen_seq) {
                if (i > 1e9)
                    IOHprofiler_error("IOHprofiler_strfind(): strange values observed i=%lu, j=%lu, strlen(base)=%lu",
                                      (unsigned long)i, (unsigned long)j, (unsigned long)strlen(base));
                return (long)i;
            }
        }
    }
    return -1;
}

/**
 * @brief Splits a string based on the given delimiter.
 *
 * Returns a pointer to the resulting substrings with NULL as the last one.
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char **IOHprofiler_string_split(const char *string, const char delimiter) {
    char **result;
    char *str_copy, *ptr, *token;
    char str_delimiter[2];
    size_t i;
    size_t count = 1;

    str_copy = IOHprofiler_strdup(string);

    /* Counts the parts between delimiters */
    ptr = str_copy;
    while (*ptr != '\0') {
        if (*ptr == delimiter) {
            count++;
        }
        ptr++;
    }
    /* Makes room for an empty string that will be appended at the end */
    count++;

    result = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));

    /* Iterates through tokens
   * NOTE: strtok() ignores multiple delimiters, therefore the final number of detected substrings might be
   * lower than the count. This is OK. */
    i = 0;
    /* A char* delimiter needs to be used, otherwise strtok() can surprise */
    str_delimiter[0] = delimiter;
    str_delimiter[1] = '\0';
    token = strtok(str_copy, str_delimiter);
    while (token) {
        assert(i < count);
        *(result + i++) = IOHprofiler_strdup(token);
        token = strtok(NULL, str_delimiter);
    }
    *(result + i) = NULL;

    IOHprofiler_free_memory(str_copy);

    return result;
}

/**
 * @brief Creates and returns a string with removed characters between from and to.
 *
 * If you wish to remove characters from the beginning of the string, set from to "".
 * If you wish to remove characters until the end of the string, set to to "".
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_remove_from_string(const char *string, const char *from, const char *to) {
    char *result, *start, *stop;

    result = IOHprofiler_strdup(string);

    if (strcmp(from, "") == 0) {
        /* Remove from the start */
        start = result;
    } else
        start = strstr(result, from);

    if (strcmp(to, "") == 0) {
        /* Remove until the end */
        stop = result + strlen(result);
    } else
        stop = strstr(result, to);

    if ((start == NULL) || (stop == NULL) || (stop < start)) {
        IOHprofiler_error("IOHprofiler_remove_from_string(): failed to remove characters between %s and %s from string %s",
                          from, to, string);
        return NULL; /* Never reached */
    }

    memmove(start, stop, strlen(stop) + 1);

    return result;
}

/**
 * @brief Returns the numbers defined by the ranges.
 *
 * Reads ranges from a string of positive ranges separated by commas. For example: "-3,5-6,8-". Returns the
 * numbers that are defined by the ranges if min and max are used as their extremes. If the ranges with open
 * beginning/end are not allowed, use 0 as min/max. The returned string has an appended 0 to mark its end.
 * A maximum of max_count values is returned. If there is a problem with one of the ranges, the parsing stops
 * and the current result is returned. The memory of the returned object needs to be freed by the caller.
 */
static size_t *IOHprofiler_string_parse_ranges(const char *string,
                                               const size_t min,
                                               const size_t max,
                                               const char *name,
                                               const size_t max_count) {
    char *ptr, *dash = NULL;
    char **ranges, **numbers;
    size_t i, j, count;
    size_t num[2];

    size_t *result;
    size_t i_result = 0;

    char *str = IOHprofiler_strdup(string);

    /* Check for empty string */
    if ((str == NULL) || (strlen(str) == 0)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): cannot parse empty ranges");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    ptr = str;
    /* Check for disallowed characters */
    while (*ptr != '\0') {
        if ((*ptr != '-') && (*ptr != ',') && !isdigit((unsigned char)*ptr)) {
            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - cannot parse ranges with '%c'", str,
                                *ptr);
            IOHprofiler_free_memory(str);
            return NULL;
        } else
            ptr++;
    }
    /* Check for incorrect boundaries */
    if ((max > 0) && (min > max)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): incorrect boundaries");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    result = IOHprofiler_allocate_vector_size_t(max_count + 1);

    /* Split string to ranges w.r.t commas */
    ranges = IOHprofiler_string_split(str, ',');
    IOHprofiler_free_memory(str);
    if (ranges) {
        /* Go over the current range */
        for (i = 0; *(ranges + i); i++) {
            ptr = *(ranges + i);
            /* Count the number of '-' */
            count = 0;
            while (*ptr != '\0') {
                if (*ptr == '-') {
                    if (count == 0)
                        /* Remember the position of the first '-' */
                        dash = ptr;
                    count++;
                }
                ptr++;
            }
            /* Point again to the start of the range */
            ptr = *(ranges + i);

            /* Check for incorrect number of '-' */
            if (count > 1) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - too many '-'s", string);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            } else if (count == 0) {
                /* Range is in the format: n (no range) */
                num[0] = (size_t)strtol(ptr, NULL, 10);
                num[1] = num[0];
            } else {
                /* Range is in one of the following formats: n-m / -n / n- / - */

                /* Split current range to numbers w.r.t '-' */
                numbers = IOHprofiler_string_split(ptr, '-');
                j = 0;
                if (numbers) {
                    /* Read the numbers */
                    for (j = 0; *(numbers + j); j++) {
                        assert(j < 2);
                        num[j] = (size_t)strtol(*(numbers + j), NULL, 10);
                        IOHprofiler_free_memory(*(numbers + j));
                    }
                }
                IOHprofiler_free_memory(numbers);

                if (j == 0) {
                    /* Range is in the format - (open ends) */
                    if ((min == 0) || (max == 0)) {
                        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open ends; some ranges ignored", name);
                        /* Cleanup */
                        for (j = i; *(ranges + j); j++)
                            IOHprofiler_free_memory(*(ranges + j));
                        IOHprofiler_free_memory(ranges);
                        if (i_result == 0) {
                            IOHprofiler_free_memory(result);
                            return NULL;
                        }
                        result[i_result] = 0;
                        return result;
                    }
                    num[0] = min;
                    num[1] = max;
                } else if (j == 1) {
                    if (dash - *(ranges + i) == 0) {
                        /* Range is in the format -n */
                        if (min == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open beginning; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = num[0];
                        num[0] = min;
                    } else {
                        /* Range is in the format n- */
                        if (max == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open end; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = max;
                    }
                }
                /* if (j == 2), range is in the format n-m and there is nothing to do */
            }

            /* Make sure the boundaries are taken into account */
            if ((min > 0) && (num[0] < min)) {
                num[0] = min;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be >= %lu", name,
                                    (unsigned long)min);
              }
            if ((max > 0) && (num[1] > max)) {
                num[1] = max;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be <= %lu", name, (unsigned long) max);
            }
            if (num[0] > num[1]) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges not within boundaries; some ranges ignored", name);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            }

            /* Write in result */
            for (j = num[0]; j <= num[1]; j++) {
                if (i_result > max_count - 1)
                    break;
                result[i_result++] = j;
            }

            IOHprofiler_free_memory(*(ranges + i));
            *(ranges + i) = NULL;
        }
    }

    IOHprofiler_free_memory(ranges);

    if (i_result == 0) {
        IOHprofiler_free_memory(result);
        return NULL;
    }

    result[i_result] = 0;
    return result;
}

/**
 * @brief Trims the given string (removes any leading and trailing spaces).
 *
 * If the string contains any leading spaces, the contents are shifted so that if it was dynamically
 * allocated, it can be still freed on the returned pointer.
 */
static char *IOHprofiler_string_trim(char *string) {
    size_t len = 0;
    char *frontp = string;
    char *endp = NULL;

    if (string == NULL) {
        return NULL;
    }
    if (string[0] == '\0') {
        return string;
    }

    len = strlen(string);
    endp = string + len;

    /* Move the front and back pointers to address the first non-whitespace characters from each end. */
    while (isspace((unsigned char)*frontp)) {
        ++frontp;
    }
    if (endp != frontp) {
        while (isspace((unsigned char)*(--endp)) && endp != frontp) {
        }
    }

    if (string + len - 1 != endp)
        *(endp + 1) = '\0';
    else if (frontp != string && endp == frontp)
        *string = '\0';

    /* Shift the string. Note the reuse of endp to mean the front of the string buffer now. */
    endp = string;
    if (frontp != string) {
        while (*frontp) {
            *endp++ = *frontp++;
        }
        *endp = '\0';
    }

    return string;
}
#endif
#line 20 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_utilities.c"

/***********************************************************************************************************/

/**
 * @brief Initializes the logging level to IOHprofiler_INFO.
 */
static IOHprofiler_log_level_type_e IOHprofiler_log_level = IOHprofiler_INFO;

/**
 * @param log_level Denotes the level of information given to the user through the standard output and
 * error streams. Can take on the values:
 * - "error" (only error messages are output),
 * - "warning" (only error and warning messages are output),
 * - "info" (only error, warning and info messages are output) and
 * - "debug" (all messages are output).
 * - "" does not set a new value
 * The default value is info.
 *
 * @return The previous IOHprofiler_log_level value as an immutable string.
 */
const char *IOHprofiler_set_log_level(const char *log_level) {
    IOHprofiler_log_level_type_e previous_log_level = IOHprofiler_log_level;

    if (strcmp(log_level, "error") == 0)
        IOHprofiler_log_level = IOHprofiler_ERROR;
    else if (strcmp(log_level, "warning") == 0)
        IOHprofiler_log_level = IOHprofiler_WARNING;
    else if (strcmp(log_level, "info") == 0)
        IOHprofiler_log_level = IOHprofiler_INFO;
    else if (strcmp(log_level, "debug") == 0)
        IOHprofiler_log_level = IOHprofiler_DEBUG;
    else if (strcmp(log_level, "") == 0) {
        /* Do nothing */
    } else {
        IOHprofiler_warning("IOHprofiler_set_log_level(): unknown level %s", log_level);
    }

    if (previous_log_level == IOHprofiler_ERROR)
        return "error";
    else if (previous_log_level == IOHprofiler_WARNING)
        return "warning";
    else if (previous_log_level == IOHprofiler_INFO)
        return "info";
    else if (previous_log_level == IOHprofiler_DEBUG)
        return "debug";
    else {
        IOHprofiler_error("IOHprofiler_set_log_level(): unknown previous log level");
        return "";
    }
}

/***********************************************************************************************************/

/**
 * @name Methods regarding file, directory and path manipulations
 */
/**@{*/
/**
 * @brief Creates a platform-dependent path from the given strings.
 *
 * @note The last argument must be NULL.
 * @note The first parameter must be able to accommodate path_max_length characters and the length
 * of the joined path must not exceed path_max_length characters.
 * @note Should work cross-platform.
 *
 * Usage examples:
 * - IOHprofiler_join_path(base_path, 100, folder1, folder2, folder3, NULL) creates base_path/folder1/folder2/folder3
 * - IOHprofiler_join_path(base_path, 100, folder1, file_name, NULL) creates base_path/folder1/file_name
 * @param path The base path; it's also where the joined path is stored to.
 * @param path_max_length The maximum length of the path.
 * @param ... Additional strings, must end with NULL
 */
static void IOHprofiler_join_path(char *path, const size_t path_max_length, ...) {
    const size_t path_separator_length = strlen(IOHprofiler_path_separator);
    va_list args;
    char *path_component;
    size_t path_length = strlen(path);

    va_start(args, path_max_length);
    while (NULL != (path_component = va_arg(args, char *))) {
        size_t component_length = strlen(path_component);
        if (path_length + path_separator_length + component_length >= path_max_length) {
            IOHprofiler_error("IOHprofiler_join_path() failed because the ${path} is too short.");
            return; /* never reached */
        }
        /* Both should be safe because of the above check. */
        if (strlen(path) > 0)
            strncat(path, IOHprofiler_path_separator, path_max_length - strlen(path) - 1);
        strncat(path, path_component, path_max_length - strlen(path) - 1);
    }
    va_end(args);
}

/**
 * @brief Checks if the given directory exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a directory and 0 otherwise.
 */
static int IOHprofiler_directory_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Checks if the given file exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a file and 0 otherwise.
 */
static int IOHprofiler_file_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES) && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && !S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Calls the right mkdir() method (depending on the platform).
 *
 * @param path The directory path.
 *
 * @return 0 on successful completion, and -1 on error.
 */
static int IOHprofiler_mkdir(const char *path) {
#if _MSC_VER
    return _mkdir(path);
#elif defined(__MINGW32__) || defined(__MINGW64__)
    return mkdir(path);
#else
    return mkdir(path, S_IRWXU);
#endif
}

/**
 * @brief Creates a directory with full privileges for the user.
 *
 * @note Should work cross-platform.
 *
 * @param path The directory path.
 */
static void IOHprofiler_create_directory(const char *path) {
    char *tmp = NULL;
    char *p;
    size_t len = strlen(path);
    char path_sep = IOHprofiler_path_separator[0];

    /* Nothing to do if the path exists. */
    if (IOHprofiler_directory_exists(path))
        return;

    tmp = IOHprofiler_strdup(path);
    /* Remove possible trailing slash */
    if (tmp[len - 1] == path_sep)
        tmp[len - 1] = 0;
    for (p = tmp + 1; *p; p++) {
        if (*p == path_sep) {
            *p = 0;
            if (!IOHprofiler_directory_exists(tmp)) {
                if (0 != IOHprofiler_mkdir(tmp))
                    IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
            }
            *p = path_sep;
        }
    }
    if (0 != IOHprofiler_mkdir(tmp))
        IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
    IOHprofiler_free_memory(tmp);
    return;
}

/* Commented to silence the compiler (unused function warning) */
#if 0

#endif

/**
 * @brief Creates a unique directory from the given path.
 *
 * If the given path does not yet exit, it is left as is, otherwise it is changed(!) by appending a number
 * to it. If path already exists, path-01 will be tried. If this one exists as well, path-02 will be tried,
 * and so on. If path-99 exists as well, the function throws an error.
 */
static void IOHprofiler_create_unique_directory(char **path) {
    int counter = 1;
    char *new_path;

    /* Create the path if it does not yet exist */
    if (!IOHprofiler_directory_exists(*path)) {
        IOHprofiler_create_directory(*path);
        return;
    }

    while (counter < 999) {
        new_path = IOHprofiler_strdupf("%s-%03d", *path, counter);

        if (!IOHprofiler_directory_exists(new_path)) {
            IOHprofiler_free_memory(*path);
            *path = new_path;
            IOHprofiler_create_directory(*path);
            return;
        } else {
            counter++;
            IOHprofiler_free_memory(new_path);
        }
    }

    IOHprofiler_error("IOHprofiler_create_unique_path(): could not create a unique path with name %s", *path);
    return; /* Never reached */
}

/**
 * The method should work across different platforms/compilers.
 *
 * @path The path to the directory
 *
 * @return 0 on successful completion, and -1 on error.
 */
int IOHprofiler_remove_directory(const char *path) {
#if _MSC_VER
    WIN32_FIND_DATA find_data_file;
    HANDLE find_handle = NULL;
    char *buf;
    int r = -1;
    int r2 = -1;

    buf = IOHprofiler_strdupf("%s\\*.*", path);
    /* Nothing to do if the folder does not exist */
    if ((find_handle = FindFirstFile(buf, &find_data_file)) == INVALID_HANDLE_VALUE) {
        IOHprofiler_free_memory(buf);
        return 0;
    }
    IOHprofiler_free_memory(buf);

    do {
        r = 0;

        /* Skip the names "." and ".." as we don't want to recurse on them */
        if (strcmp(find_data_file.cFileName, ".") != 0 && strcmp(find_data_file.cFileName, "..") != 0) {
            /* Build the new path using the argument path the file/folder name we just found */
            buf = IOHprofiler_strdupf("%s\\%s", path, find_data_file.cFileName);

            if (find_data_file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                /* Buf is a directory, recurse on it */
                r2 = IOHprofiler_remove_directory(buf);
            } else {
                /* Buf is a file, delete it */
                /* Careful, DeleteFile returns 0 if it fails and nonzero otherwise! */
                r2 = -(DeleteFile(buf) == 0);
            }

            IOHprofiler_free_memory(buf);
        }

        r = r2;

    } while (FindNextFile(find_handle, &find_data_file)); /* Find the next file */

    FindClose(find_handle);

    if (!r) {
        /* Path is an empty directory, delete it */
        /* Careful, RemoveDirectory returns 0 if it fails and nonzero otherwise! */
        r = -(RemoveDirectory(path) == 0);
    }

    return r;
#else
    DIR *d = opendir(path);
    int r = -1;
    int r2 = -1;
    char *buf;

    /* Nothing to do if the folder does not exist */
    if (!IOHprofiler_directory_exists(path))
        return 0;

    if (d) {
        struct dirent *p;

        r = 0;

        while (!r && (p = readdir(d))) {
            /* Skip the names "." and ".." as we don't want to recurse on them */
            if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, "..")) {
                continue;
            }

            buf = IOHprofiler_strdupf("%s/%s", path, p->d_name);
            if (buf) {
                if (IOHprofiler_directory_exists(buf)) {
                    /* Buf is a directory, recurse on it */
                    r2 = IOHprofiler_remove_directory(buf);
                } else {
                    /* Buf is a file, delete it */
                    r2 = unlink(buf);
                }
            }
            IOHprofiler_free_memory(buf);

            r = r2;
        }

        closedir(d);
    }

    if (!r) {
        /* Path is an empty directory, delete it */
        r = rmdir(path);
    }

    return r;
#endif
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding memory allocations
 */
/**@{*/
double *IOHprofiler_allocate_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(double);
    return (double *)IOHprofiler_allocate_memory(block_size);
}

int *IOHprofiler_allocate_int_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(int);
    return (int *)IOHprofiler_allocate_memory(block_size);
}
/**
 * @brief Allocates memory for a vector and sets all its elements to value.
 */
static double *IOHprofiler_allocate_vector_with_value(const size_t number_of_elements, double value) {
    const size_t block_size = number_of_elements * sizeof(double);
    double *vector = (double *)IOHprofiler_allocate_memory(block_size);
    size_t i;

    for (i = 0; i < number_of_elements; i++)
        vector[i] = value;

    return vector;
}

/**
 * @brief Safe memory allocation for a vector with size_t elements that either succeeds or triggers a
 * IOHprofiler_error.
 */
static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(size_t);
    return (size_t *)IOHprofiler_allocate_memory(block_size);
}

static char *IOHprofiler_allocate_string(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(char);
    return (char *)IOHprofiler_allocate_memory(block_size);
}

static double *IOHprofiler_duplicate_vector(const double *src, const size_t number_of_elements) {
    size_t i;
    double *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}

static int *IOHprofiler_duplicate_int_vector(const int *src, const size_t number_of_elements) {
    size_t i;
    int *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_int_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding string options
 */
/**@{*/

/**
 * @brief Allocates an option keys structure holding the given number of option keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_allocate(const size_t count, const char **keys) {
    size_t i;
    IOHprofiler_option_keys_t *option_keys;

    if ((count == 0) || (keys == NULL))
        return NULL;

    option_keys = (IOHprofiler_option_keys_t *)IOHprofiler_allocate_memory(sizeof(*option_keys));

    option_keys->keys = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));
    for (i = 0; i < count; i++) {
        assert(keys[i]);
        option_keys->keys[i] = IOHprofiler_strdup(keys[i]);
    }
    option_keys->count = count;

    return option_keys;
}

/**
 * @brief Frees the given option keys structure.
 */
static void IOHprofiler_option_keys_free(IOHprofiler_option_keys_t *option_keys) {
    size_t i;

    if (option_keys) {
        for (i = 0; i < option_keys->count; i++) {
            IOHprofiler_free_memory(option_keys->keys[i]);
        }
        IOHprofiler_free_memory(option_keys->keys);
        IOHprofiler_free_memory(option_keys);
    }
}

/**
 * @brief Returns redundant option keys (the ones present in given_option_keys but not in known_option_keys).
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_get_redundant(const IOHprofiler_option_keys_t *known_option_keys,
                                                                        const IOHprofiler_option_keys_t *given_option_keys) {
    size_t i, j, count = 0;
    int found;
    char **redundant_keys;
    IOHprofiler_option_keys_t *redundant_option_keys;

    assert(known_option_keys != NULL);
    assert(given_option_keys != NULL);

    /* Find the redundant keys */
    redundant_keys = (char **)IOHprofiler_allocate_memory(given_option_keys->count * sizeof(char *));
    for (i = 0; i < given_option_keys->count; i++) {
        found = 0;
        for (j = 0; j < known_option_keys->count; j++) {
            if (strcmp(given_option_keys->keys[i], known_option_keys->keys[j]) == 0) {
                found = 1;
                break;
            }
        }
        if (!found) {
            redundant_keys[count++] = IOHprofiler_strdup(given_option_keys->keys[i]);
        }
    }
    redundant_option_keys = IOHprofiler_option_keys_allocate(count, (const char **)redundant_keys);

    /* Free memory */
    for (i = 0; i < count; i++) {
        IOHprofiler_free_memory(redundant_keys[i]);
    }
    IOHprofiler_free_memory(redundant_keys);

    return redundant_option_keys;
}

/**
 * @brief Adds additional option keys to the given basic option keys (changes the basic keys).
 */
static void IOHprofiler_option_keys_add(IOHprofiler_option_keys_t **basic_option_keys,
                                        const IOHprofiler_option_keys_t *additional_option_keys) {
    size_t i, j;
    size_t new_count;
    char **new_keys;
    IOHprofiler_option_keys_t *new_option_keys;

    assert(*basic_option_keys != NULL);
    if (additional_option_keys == NULL)
        return;

    /* Construct the union of both keys */
    new_count = (*basic_option_keys)->count + additional_option_keys->count;
    new_keys = (char **)IOHprofiler_allocate_memory(new_count * sizeof(char *));
    for (i = 0; i < (*basic_option_keys)->count; i++) {
        new_keys[i] = IOHprofiler_strdup((*basic_option_keys)->keys[i]);
    }
    for (j = 0; j < additional_option_keys->count; j++) {
        new_keys[(*basic_option_keys)->count + j] = IOHprofiler_strdup(additional_option_keys->keys[j]);
    }
    new_option_keys = IOHprofiler_option_keys_allocate(new_count, (const char **)new_keys);

    /* Free the old basic keys */
    IOHprofiler_option_keys_free(*basic_option_keys);
    *basic_option_keys = new_option_keys;
    for (i = 0; i < new_count; i++) {
        IOHprofiler_free_memory(new_keys[i]);
    }
    IOHprofiler_free_memory(new_keys);
}

/**
 * @brief Creates an instance of option keys from the given string of options containing keys and values
 * separated by colons.
 *
 * @note Relies heavily on the "key: value" format and might fail if the number of colons doesn't match the
 * number of keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys(const char *option_string) {
    size_t i;
    char **keys;
    IOHprofiler_option_keys_t *option_keys = NULL;
    char *string_to_parse, *key;

    /* Check for empty string */
    if ((option_string == NULL) || (strlen(option_string) == 0)) {
        return NULL;
    }

    /* Split the options w.r.t ':' */
    keys = IOHprofiler_string_split(option_string, ':');

    if (keys) {
        /* Keys now contain something like this: "values_of_previous_key this_key" except for the first, which
     * contains only the key and the last, which contains only the previous values */
        for (i = 0; *(keys + i); i++) {
            string_to_parse = IOHprofiler_strdup(*(keys + i));

            /* Remove any leading and trailing spaces */
            string_to_parse = IOHprofiler_string_trim(string_to_parse);

            /* Stop if this is the last substring (contains a value and no key) */
            if ((i > 0) && (*(keys + i + 1) == NULL)) {
                IOHprofiler_free_memory(string_to_parse);
                break;
            }

            /* Disregard everything before the last space */
            key = strrchr(string_to_parse, ' ');
            if ((key == NULL) || (i == 0)) {
                /* No spaces left (or this is the first key), everything is the key */
                key = string_to_parse;
            } else {
                /* Move to the start of the key (one char after the space) */
                key++;
            }

            /* Put the key in keys */
            IOHprofiler_free_memory(*(keys + i));
            *(keys + i) = IOHprofiler_strdup(key);
            IOHprofiler_free_memory(string_to_parse);
        }

        option_keys = IOHprofiler_option_keys_allocate(i, (const char **)keys);

        /* Free the keys */
        for (i = 0; *(keys + i); i++) {
            IOHprofiler_free_memory(*(keys + i));
        }
        IOHprofiler_free_memory(keys);
    }

    return option_keys;
}

/**
 * @brief Creates and returns a string containing the info_string and all keys from option_keys.
 *
 * Can be used to output information about the given option_keys.
 */
static char *IOHprofiler_option_keys_get_output_string(const IOHprofiler_option_keys_t *option_keys,
                                                       const char *info_string) {
    size_t i;
    char *string = NULL, *new_string;

    if ((option_keys != NULL) && (option_keys->count > 0)) {
        string = IOHprofiler_strdup(info_string);
        for (i = 0; i < option_keys->count; i++) {
            new_string = IOHprofiler_strdupf("%s %s\n", string, option_keys->keys[i]);
            IOHprofiler_free_memory(string);
            string = new_string;
        }
    }

    return string;
}

/**
 * @brief Parses options in the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - value needs to be a single string (no spaces allowed)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read(const char *options, const char *name, const char *format, void *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing whitespaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    return sscanf(&options[i2], format, pointer);
}

/**
 * @brief Reads an integer from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be an integer
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_int(const char *options, const char *name, int *pointer) {
    return IOHprofiler_options_read(options, name, " %i", pointer);
}

/**
 * @brief Reads a size_t from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a size_t
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_size_t(const char *options, const char *name, size_t *pointer) {
    return IOHprofiler_options_read(options, name, "%lu", pointer);
}

/**
 * @brief Reads a double value from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a double
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_double(const char *options, const char *name, double *pointer) {
    return IOHprofiler_options_read(options, name, "%lf", pointer);
}

/**
 * @brief Reads a string from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a string - either a single word or multiple words
 * in double quotes
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_string(const char *options, const char *name, char *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    if (options[i2] == '\"') {
        /* The value starts with a quote: read everything between two quotes into a string */
        return sscanf(&options[i2], "\"%[^\"]\"", pointer);
    } else
        return sscanf(&options[i2], "%s", pointer);
}

/**
 * @brief Reads (possibly delimited) values from options using the form "name1: value1,value2,value3 name2: value4",
 * i.e. reads all characters from the corresponding name up to the next whitespace or end of string.
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_values(const char *options, const char *name, char *pointer) {
    long i1, i2;
    int i;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    i = 0;
    while (!isspace((unsigned char)options[i2 + i]) && (options[i2 + i] != '\0')) {
        pointer[i] = options[i2 + i];
        i++;
    }
    pointer[i] = '\0';
    return i;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods implementing functions on double values not contained in C89 standard
 */
/**@{*/

/**
 * @brief Rounds the given double to the nearest integer.
 */
static double IOHprofiler_double_round(const double number) {
    return floor(number + 0.5);
}

/**
 * @brief Returns the maximum of a and b.
 */
static double IOHprofiler_double_max(const double a, const double b) {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Returns the minimum of a and b.
 */
static double IOHprofiler_double_min(const double a, const double b) {
    if (a <= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Performs a "safer" double to size_t conversion.
 */
static size_t IOHprofiler_double_to_size_t(const double number) {
    return (size_t)IOHprofiler_double_round(number);
}

/**
 * @brief  Returns 1 if |a - b| < precision and 0 otherwise.
 */
static int IOHprofiler_double_almost_equal(const double a, const double b, const double precision) {
    return (fabs(a - b) < precision);
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods handling NAN and INFINITY
 */
/**@{*/

/**
 * @brief Returns 1 if x is NAN and 0 otherwise.
 */
static int IOHprofiler_is_nan(const int x) {
    /*return (isnan(x) || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
*/
    return (0 || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
}

/**
 * @brief Returns 1 if the input vector of dimension dim contains any NAN values and 0 otherwise.
 */
static int IOHprofiler_vector_contains_nan(const int *x, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        if (IOHprofiler_is_nan(x[i]))
            return 1;
    }
    return 0;
}

/**
 * @brief Sets all dim values of y to NAN.
 */
static void IOHprofiler_vector_set_to_nan(double *y, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        y[i] = NAN;
    }
}

/**
 * @brief Returns 1 if x is INFINITY and 0 otherwise.
 */
static int IOHprofiler_is_inf(const int x) {
    if (IOHprofiler_is_nan(x))
        return 0;
    /*return (isinf(x) || (x <= -INFINITY) || (x >= INFINITY));*/
    return (0 || (x <= -INFINITY) || (x >= INFINITY));
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Miscellaneous methods
 */
/**@{*/

/**
 * @brief Returns the current time as a string.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_current_time_get_string(void) {
    time_t timer;
    char *time_string = IOHprofiler_allocate_string(30);
    struct tm *tm_info;
    time(&timer);
    tm_info = localtime(&timer);
    assert(tm_info != NULL);
    strftime(time_string, 30, "%d.%m.%y %H:%M:%S", tm_info);
    return time_string;
}

/**
 * @brief Returns the number of positive numbers pointed to by numbers (the count stops when the first
 * 0 is encountered of max_count numbers have been read).
 *
 * If there are more than max_count numbers, a IOHprofiler_error is raised. The name argument is used
 * only to provide more informative output in case of any problems.
 */
static size_t IOHprofiler_count_numbers(const size_t *numbers, const size_t max_count, const char *name) {
    size_t count = 0;
    while ((count < max_count) && (numbers[count] != 0)) {
        count++;
    }
    if (count == max_count) {
        IOHprofiler_error("IOHprofiler_count_numbers(): over %lu numbers in %s", (unsigned long)max_count, name);
        return 0; /* Never reached*/
    }

    return count;
}

/**@}*/

/***********************************************************************************************************/
#endif
#line 13 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_problem.c"

/**
 * Evaluates the problem function, increases the number of evaluations and updates the best observed value
 * and the best observed evaluation number.
 *
 * @note Both x and y must point to correctly sized allocated memory regions.
 *
 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 * @param y The objective vector that is the result of the evaluation (in single-objective problems only the
 * first vector item is being set). Currently multi-objective is not supported.
 * @param number_of_parameters The number of parameters need to be logged. Set as zero by default.
 * @param parameters The list of parameters. Set as NULL by default.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {

    assert(problem != NULL);
    assert(problem->evaluate_function != NULL);
    problem->evaluate_function(problem, x, y);
    problem->evaluations++; /* each derived class has its own counter, only the most outer will be visible */

    /* A little bit of bookkeeping */
    if (y[0] > problem->best_observed_fvalue[0]) {
        problem->best_observed_fvalue[0] = y[0];
        problem->best_observed_evaluation[0] = problem->evaluations;
    }
}

/**
 * Evaluates and logs the given solution (as the IOHprofiler_evaluate_function), but does not return the evaluated
 * value.
 *
 * @note None of the observers implements this function yet!
 * @note x must point to a correctly sized allocated memory region.

 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    assert(problem != NULL);
    if (problem->recommend_solution == NULL) {
        IOHprofiler_error("IOHprofiler_recommend_solutions(): No recommend solution function implemented for problem %s",
                          problem->problem_id);
    }
    problem->recommend_solution(problem, x);
}

/**
 * @brief Allocates a new IOHprofiler_problem_t for the given number of variables and number of objectives.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate(const size_t number_of_variables,
                                                           const size_t number_of_objectives) {
    IOHprofiler_problem_t *problem;
    problem = (IOHprofiler_problem_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    /* Initialize fields to sane/safe defaults */
    problem->initial_solution = NULL;
    problem->evaluate_function = NULL;
    problem->recommend_solution = NULL;
    problem->problem_free_function = NULL;
    problem->dimension = number_of_variables;
    problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = number_of_objectives;
    problem->number_of_parameters = 0;
    problem->parameters = NULL;
    problem->smallest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->largest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_parameter = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_value = IOHprofiler_allocate_vector(number_of_objectives);
    problem->raw_fitness = IOHprofiler_allocate_vector(number_of_objectives);
    if (number_of_objectives > 1)
        problem->nadir_value = IOHprofiler_allocate_vector(number_of_objectives);
    else
        problem->nadir_value = NULL;
    problem->problem_name = NULL;
    problem->problem_id = NULL;
    problem->problem_type = NULL;
    problem->evaluations = 0;
    problem->final_target_delta[0] = 1e-8; /* in case to be modified by the benchmark */
    problem->best_observed_fvalue[0] = DBL_MIN_EXP;
    problem->best_observed_evaluation[0] = 0;
    problem->suite = NULL; /* To be initialized in the IOHprofiler_suite_get_problem_from_indices() function */
    problem->suite_dep_index = 0;
    problem->suite_dep_function = 0;
    problem->suite_dep_instance = 0;
    problem->data = NULL;
    return problem;
}

/**
 * @brief Creates a duplicate of the 'other' problem for all fields except for data, which points to NULL.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_duplicate(const IOHprofiler_problem_t *other) {
    size_t i;
    IOHprofiler_problem_t *problem;
    problem = IOHprofiler_problem_allocate(other->number_of_variables, other->number_of_objectives);

    problem->dimension = other->dimension;
    problem->initial_solution = other->initial_solution;
    problem->evaluate_function = other->evaluate_function;
    problem->recommend_solution = other->recommend_solution;
    problem->problem_free_function = other->problem_free_function;

    for (i = 0; i < problem->number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = other->smallest_values_of_interest[i];
        problem->largest_values_of_interest[i] = other->largest_values_of_interest[i];
        if (other->best_parameter)
            problem->best_parameter[i] = other->best_parameter[i];
    }

    if (other->best_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->best_value[i] = other->best_value[i];
        }

    if (other->nadir_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->nadir_value[i] = other->nadir_value[i];
        }

    if (other->raw_fitness)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->raw_fitness[i] = other->raw_fitness[i];
        }

    problem->number_of_parameters = other->number_of_parameters;
    for (i = 0; i < problem->number_of_parameters; ++i) {
        problem->parameters[i] = other->parameters[i];
    }

    problem->problem_name = IOHprofiler_strdup(other->problem_name);
    problem->problem_id = IOHprofiler_strdup(other->problem_id);
    problem->problem_type = IOHprofiler_strdup(other->problem_type);

    problem->evaluations = other->evaluations;
    problem->final_target_delta[0] = other->final_target_delta[0];
    problem->best_observed_fvalue[0] = other->best_observed_fvalue[0];
    problem->best_observed_evaluation[0] = other->best_observed_evaluation[0];

    problem->suite = other->suite;
    problem->suite_dep_index = other->suite_dep_index;
    problem->suite_dep_function = other->suite_dep_function;
    problem->suite_dep_instance = other->suite_dep_instance;

    problem->data = NULL;

    return problem;
}

/**
 * @brief Allocates a problem using scalar values for smallest_value_of_interest, largest_value_of_interest
 * and best_parameter.
 * Note that the number of objectives is set as 1 by default.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate_from_scalars(const char *problem_name,
                                                                        IOHprofiler_evaluate_function_t evaluate_function,
                                                                        IOHprofiler_problem_free_function_t problem_free_function,
                                                                        const size_t number_of_variables,
                                                                        const int smallest_value_of_interest,
                                                                        const int largest_value_of_interest,
                                                                        const int best_parameter) {
    size_t i;

    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate(number_of_variables, 1);

    problem->problem_name = IOHprofiler_strdup(problem_name);
    /*problem->dimension = number_of_variables;
    */problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = 1;
    problem->evaluate_function = evaluate_function;
    problem->problem_free_function = problem_free_function;

    for (i = 0; i < number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = smallest_value_of_interest;
        problem->largest_values_of_interest[i] = largest_value_of_interest;
        problem->best_parameter[i] = best_parameter;
    }
    return problem;
}

void IOHprofiler_problem_free(IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (problem->problem_free_function != NULL) {
        problem->problem_free_function(problem);
    } else {
        /* Best guess at freeing all relevant structures */
        if (problem->smallest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->smallest_values_of_interest);
        if (problem->largest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->largest_values_of_interest);
        if (problem->best_parameter != NULL)
            IOHprofiler_free_memory(problem->best_parameter);
        if (problem->best_value != NULL)
            IOHprofiler_free_memory(problem->best_value);
        if (problem->raw_fitness != NULL)
            IOHprofiler_free_memory(problem->raw_fitness);
        if (problem->nadir_value != NULL)
            IOHprofiler_free_memory(problem->nadir_value);
        if (problem->problem_name != NULL)
            IOHprofiler_free_memory(problem->problem_name);
        if (problem->problem_id != NULL)
            IOHprofiler_free_memory(problem->problem_id);
        if (problem->problem_type != NULL)
            IOHprofiler_free_memory(problem->problem_type);
        if (problem->data != NULL)
            IOHprofiler_free_memory(problem->data);
        if (problem->parameters != NULL)
            IOHprofiler_free_memory(problem->parameters);
        problem->smallest_values_of_interest = NULL;
        problem->largest_values_of_interest = NULL;
        problem->best_parameter = NULL;
        problem->best_value = NULL;
        problem->raw_fitness = NULL;
        problem->nadir_value = NULL;
        problem->suite = NULL;
        problem->data = NULL;
        problem->parameters = NULL;
        IOHprofiler_free_memory(problem);
    }
}

/**
 * @brief Checks whether the given string is in the right format to be a problem_id.
 *
 * No non-alphanumeric characters besides '-', '_' and '.' are allowed.
 */
static int IOHprofiler_problem_id_is_fine(const char *id, ...) {
    va_list args;
    const int reject = 0;
    const int accept = 1;
    const char *cp;
    char *s;
    int result = accept;

    va_start(args, id);
    s = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    for (cp = s; *cp != '\0'; ++cp) {
        if (('A' <= *cp) && (*cp <= 'Z'))
            continue;
        if (('a' <= *cp) && (*cp <= 'z'))
            continue;
        if ((*cp == '_') || (*cp == '-'))
            continue;
        if (('0' <= *cp) && (*cp <= '9'))
            continue;
        result = reject;
    }
    IOHprofiler_free_memory(s);
    return result;
}

/**
 * @brief Sets the problem_parameters.
 *
 */
void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters) {
    size_t i;
    if (number_of_parameters != 0) {
        problem->number_of_parameters = number_of_parameters;
        if (problem->parameters != NULL) {
            IOHprofiler_free_memory(problem->parameters);
        }
        problem->parameters = IOHprofiler_allocate_vector(number_of_parameters);
        for (i = 0; i < problem->number_of_parameters; ++i) {
            problem->parameters[i] = parameters[i];
        }
    }
}

/**
 * @brief Sets the problem_id using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation and verifies that the problem_id is in the correct format.
 */
static void IOHprofiler_problem_set_id(IOHprofiler_problem_t *problem, const char *id, ...) {
    va_list args;

    va_start(args, id);
    if (problem->problem_id != NULL)
        IOHprofiler_free_memory(problem->problem_id);
    problem->problem_id = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    if (!IOHprofiler_problem_id_is_fine(problem->problem_id)) {
        IOHprofiler_error("Problem id should only contain standard chars, not like '%s'", problem->problem_id);
    }
}

/**
 * @brief Sets the problem_name using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_name(IOHprofiler_problem_t *problem, const char *name, ...) {
    va_list args;

    va_start(args, name);
    if (problem->problem_name != NULL)
        IOHprofiler_free_memory(problem->problem_name);
    problem->problem_name = IOHprofiler_vstrdupf(name, args);
    va_end(args);
}

/**
 * @brief Sets the problem_type using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_type(IOHprofiler_problem_t *problem, const char *type, ...) {
    va_list args;

    va_start(args, type);
    if (problem->problem_type != NULL)
        IOHprofiler_free_memory(problem->problem_type);
    problem->problem_type = IOHprofiler_vstrdupf(type, args);
    va_end(args);
}

size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->evaluations;
}

/**
 * @brief Returns 1 if the best parameter is not (close to) zero and 0 otherwise.
 */
static int IOHprofiler_problem_best_parameter_not_zero(const IOHprofiler_problem_t *problem) {
    size_t i = 0;
    int best_is_zero = 1;

    if (IOHprofiler_vector_contains_nan(problem->best_parameter, problem->number_of_variables))
        return 1;

    while (i < problem->number_of_variables && best_is_zero) {
        best_is_zero = IOHprofiler_double_almost_equal(problem->best_parameter[i], 0, 1e-9);
        i++;
    }

    return !best_is_zero;
}

/**
 * @note Can be used to prevent unnecessary burning of CPU time.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (IOHprofiler_problem_get_number_of_objectives(problem) != 1 ||
        IOHprofiler_problem_get_evaluations(problem) < 1)
        return 0;
    if (problem->best_value == NULL)
        return 0;
    return problem->best_observed_fvalue[0] >= problem->best_value[0] - problem->final_target_delta[0] ? 1 : 0;
}

/**
 * @note Tentative...
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->best_observed_fvalue[0];
}

/**
 * @note This function breaks the black-box property: the returned  value is not
 * meant to be used by the optimization algorithm.
 */
double IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->best_value != NULL);
    assert(problem->final_target_delta != NULL);
    return problem->best_value[0] + problem->final_target_delta[0];
}

/**
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_name != NULL);
    return problem->problem_name;
}

/**
 * The ID is guaranteed to contain only characters in the set [a-z0-9_-]. It should therefore be safe to use
 * it to construct filenames or other identifiers.
 *
 * Each problem ID should be unique within each benchmark suite.
 *
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_id != NULL);
    return problem->problem_id;
}

const char *IOHprofiler_problem_get_type(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_type != NULL);
    return problem->problem_type;
}

size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->dimension > 0);
    return problem->dimension;
}

size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->number_of_objectives > 0);
    return problem->number_of_objectives;
}
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->smallest_values_of_interest != NULL);
    return problem->smallest_values_of_interest;
}

const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->largest_values_of_interest != NULL);
    return problem->largest_values_of_interest;
}

/**
 * If a special method for setting an initial solution to the problem does not exist, the center of the
 * problem's region of interest is the initial solution.
 * @param problem The given IOHprofiler problem.
 * @param initial_solution The pointer to the initial solution being set by this method.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution) {
    assert(problem != NULL);
    if (problem->initial_solution != NULL) {
        problem->initial_solution(problem, initial_solution);
    } else {
        size_t i;
        assert(problem->smallest_values_of_interest != NULL);
        assert(problem->largest_values_of_interest != NULL);
        for (i = 0; i < problem->number_of_variables; ++i)
            initial_solution[i] = (int)(problem->smallest_values_of_interest[i] + 0.5 * (problem->largest_values_of_interest[i] - problem->smallest_values_of_interest[i]));
    }
}

static IOHprofiler_suite_t *IOHprofiler_problem_get_suite(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite;
}

static void IOHprofiler_problem_set_suite(IOHprofiler_problem_t *problem, IOHprofiler_suite_t *suite) {
    assert(problem != NULL);
    problem->suite = suite;
}

size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite_dep_index;
}

static size_t IOHprofiler_problem_get_suite_dep_function(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_function > 0);
    return problem->suite_dep_function;
}

static size_t IOHprofiler_problem_get_suite_dep_instance(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_instance > 0);
    return problem->suite_dep_instance;
}

/**
 * @brief Returns the data of the transformed problem.
 */
static void *IOHprofiler_problem_transformed_get_data(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->data != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->data;
}

/**
 * @brief Returns the inner problem of the transformed problem.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_get_inner_problem(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the inner problem.
 */
static void IOHprofiler_problem_transformed_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_evaluate_function(data->inner_problem, x, y);
}

/**
 * @brief Calls the IOHprofiler_recommend_solution function on the inner problem.
 */
static void IOHprofiler_problem_transformed_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_recommend_solution(data->inner_problem, x);
}

/**
 * @brief Frees only the data of the transformed problem leaving the inner problem intact.
 *
 * @note If there is no other pointer to the inner problem, access to it will be lost.
 */
static void IOHprofiler_problem_transformed_free_data(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;

    if (data->data != NULL) {
        if (data->data_free_function != NULL) {
            data->data_free_function(data->data);
            data->data_free_function = NULL;
        }
        IOHprofiler_free_memory(data->data);
        data->data = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}

/**
 * @brief Frees the transformed problem.
 */
static void IOHprofiler_problem_transformed_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);
    if (data->inner_problem != NULL) {
        IOHprofiler_problem_free(data->inner_problem);
        data->inner_problem = NULL;
    }
    IOHprofiler_problem_transformed_free_data(problem);
}

/**
 * @brief Allocates a transformed problem that wraps the inner_problem.
 *
 * By default all methods will dispatch to the inner_problem. A prefix is prepended to the problem name
 * in order to reflect the transformation somewhere.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_allocate(IOHprofiler_problem_t *inner_problem,
                                                                       void *user_data,
                                                                       IOHprofiler_data_free_function_t data_free_function,
                                                                       const char *name_prefix) {
    IOHprofiler_problem_transformed_data_t *problem;
    IOHprofiler_problem_t *inner_copy;
    char *old_name = IOHprofiler_strdup(inner_problem->problem_name);

    problem = (IOHprofiler_problem_transformed_data_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    problem->inner_problem = inner_problem;
    problem->data = user_data;
    problem->data_free_function = data_free_function;

    inner_copy = IOHprofiler_problem_duplicate(inner_problem);
    inner_copy->evaluate_function = IOHprofiler_problem_transformed_evaluate_function;
    inner_copy->recommend_solution = IOHprofiler_problem_transformed_recommend_solution;
    inner_copy->problem_free_function = IOHprofiler_problem_transformed_free;
    inner_copy->data = problem;

    IOHprofiler_problem_set_name(inner_copy, "%s(%s)", name_prefix, old_name);
    IOHprofiler_free_memory(old_name);

    return inner_copy;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the underlying problems.
 */
static void IOHprofiler_problem_stacked_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_stacked_data_t *data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    assert(
        IOHprofiler_problem_get_number_of_objectives(problem) == IOHprofiler_problem_get_number_of_objectives(data->problem1) + IOHprofiler_problem_get_number_of_objectives(data->problem2));

    IOHprofiler_evaluate_function(data->problem1, x, &y[0]);
    IOHprofiler_evaluate_function(data->problem2, x, &y[IOHprofiler_problem_get_number_of_objectives(data->problem1)]);
}

/**
 * @brief Frees the stacked problem.
 */
static void IOHprofiler_problem_stacked_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_stacked_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    if (data->problem1 != NULL) {
        IOHprofiler_problem_free(data->problem1);
        data->problem1 = NULL;
    }
    if (data->problem2 != NULL) {
        IOHprofiler_problem_free(data->problem2);
        data->problem2 = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}
#endif
#line 12 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/ruggedness.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../suite/WModel/WModel_struct.h"
#ifndef WMODEL_STRUCT
#define WMODEL_STRUCT

/**
 * @brief Data type for transform_vars_dummy.
 */
typedef struct {
  int *offset;
  int *reduncted_x;
  int *postion_match;
  IOHprofiler_problem_free_function_t old_free_problem;
} dummy_random_data_t;

/**
 * @brief Data type for transform_vars_epistasis.
 */
typedef struct {
  int *offset;
  int *epistasis_x;/*result of the epistasis transformation */
  IOHprofiler_problem_free_function_t old_free_problem;
} epistasis_data_t;

/**
 * @brief Data type for transform_vars_neutrality.
 */
typedef struct {
  int *offset;
  int *neutrality_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} neutrality_data_t;


typedef struct {
  double offset;
} ruggedness_data_t;

typedef struct {
  dummy_random_data_t *data1;
  neutrality_data_t *data2;
  epistasis_data_t *data3;
  ruggedness_data_t *data4;
  int * parameters;
  int number_of_layer;
  int old_dim;
} WModel_data_t;

#endif
#line 13 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/ruggedness.c"


int max_gamma(int q) {
    return (int)((q * (q - 1))>>1);
}

int * ruggedness_raw(int gamma, int q){
   int i,j,k,start,max;
   int upper;
   int t;
   int * r;
/*fprintf(stderr,"gamma : %d\n",gamma);
fprintf(stderr,"q : %d\n",q);*/
   r=IOHprofiler_allocate_int_vector(q+1);
   r[0]=0;
   max = max_gamma(q);
    if (gamma <= 0){
      start = 0;
    } else {
      start = q - 1 - (int) (0.5 + sqrt(0.25 + ((max - gamma)<<1)));
    }
/*
fprintf(stderr,"part1 : %d\n",((int)(0.25 + ((max - gamma)<<1))));
fprintf(stderr,"part2 : %f\n",(sqrt((int)(0.25 + ((max - gamma)<<1)))));
fprintf(stderr,"part3 : %d\n",(int)(0.5 + sqrt((int)(0.25 + ((max - gamma)<<1)))));*/
/*fprintf(stderr,"start %d\n",start);*/

/*for(i=0;i<q;i++){fprintf(stderr,"%d.",r[i]);}fprintf(stderr,"\n");*/
    k = 0;
    for (j = 1; j <= start; j++) {
      if ((j & 1) != 0){ r[j] = (q - k);}
      else{k=k+1; r[j] = k;}
    }
/*for(i=0;i<q;i++){fprintf(stderr,"%d.",r[i]);}fprintf(stderr,"\n");*/
    for (; j <= q; j++) {
      k=k+1;
      if((start & 1) != 0){r[j] = (q - k);}
      else{r[j]=k;}
    }
    upper = ((gamma - max) +(((q - start - 1) * (q - start)) >> 1));
    j--;
/*for(i=0;i<q;i++){fprintf(stderr,"%d.",r[i]);}fprintf(stderr,"\n");*/
/*fprintf(stderr,"upper %d\n",upper);*/
    for (i = 1; i <= upper; i++) {
      j=j-1;

      if(j>0){
      t = r[j];
      r[j] = r[q];
      r[q] = t;}
    }

/*fprintf(stderr,"r\n");
for(i=0;i<=q;i++){fprintf(stderr,"%d %d\n",i, r[i]);}*/
int * r2;
   r2=malloc(sizeof(int)*(q+1));
 for(i=0;i<=q;i++){r2[i]=q-r[q-i];}
 free(r);
/*fprintf(stderr,"r2\n");
for(i=0;i<=q;i++){fprintf(stderr,"%d %d\n",i, r2[i]);}*/
    return r2;
  }

int ruggedness_translate(int gamma, int q) {
    int j, k, max, g, lastUpper;

    if (gamma <= 0) {
      return 0;
    }
    g = gamma;
    max = max_gamma(q);
    lastUpper = ((q >> 1) * ((q + 1) >> 1));
    if (g <= lastUpper) {
      j = abs(((q + 2) * 0.5)-sqrt((((q * q) * 0.25) + 1) - g));

      k = ((g - ((q + 2) * j)) + (j * j) + q);
      return ((k + 1 + ((((q + 2) * j) - (j * j) - q - 1) << 1))- (j - 1));
    }

    j = abs((((q % 2) + 1) * 0.5)
        + sqrt((((1 - (q % 2)) * 0.25) + g) - 1 - lastUpper));

    k = g - (((j - (q % 2)) * (j - 1)) + 1 + lastUpper);

    return (max - k - ((2 * j * j) - j) - ((q % 2) * ((-2 * j) + 1)));
  }



double layer_compute_ruggedness(const double y, size_t dimension,int gamma){
  double result;
  int * r,i;
  r=ruggedness_raw(ruggedness_translate(gamma, dimension), dimension);
  result=r[ (int)y ];

/*for(i=0;i<dimension+1;i++){fprintf(stderr,"%d ",r[i]);}fprintf(stderr,"\n");

fprintf(stderr,"dim %d val %f, result %f\n",dimension,y,result);*/
  assert(result <= (double) dimension);
  IOHprofiler_free_memory(r);
  return result;
}

/**
 * @brief Evaluates the transformation.
 */
static void ruggedness_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y,int gamma) {
  ruggedness_data_t *data;
  size_t i;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }

  data = (ruggedness_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  IOHprofiler_evaluate_function(IOHprofiler_problem_transformed_get_inner_problem(problem), x, y);
  for (i = 0; i < problem->number_of_objectives; i++) {
      y[i] = layer_compute_ruggedness(y[i],problem->number_of_variables,gamma);
      problem->raw_fitness[i] = y[i];
      
  }
  assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_ruggedness(IOHprofiler_problem_t *inner_problem,const int *offset, double *y) {
  /*if(*offset==1){return inner_problem;}*/
  if(*offset>=0){return inner_problem;}
  IOHprofiler_problem_t *problem;
  ruggedness_data_t *data;
  size_t i;
  data = (ruggedness_data_t *) IOHprofiler_allocate_memory(sizeof(*data));

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, NULL, "ruggedness");
  problem->evaluate_function = ruggedness_evaluate;
  for (i = 0; i < problem->number_of_objectives; i++) {
      problem->best_value[i] = layer_compute_ruggedness(problem->best_value[i],problem->number_of_variables, &offset); 
  }
  return problem;
}
#endif
#line 14 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/dummy_random.c"
/**
 * @file transform_vars_dummy.c
 * @brief Implementation of dummyd all decision values by an offset.
 */
#ifndef DUMMY_RANDOM
#define DUMMY_RANDOM

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/dummy_random.c"
#line 12 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/dummy_random.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_random.c"
/**
 * @file IOHprofiler_random.c
 * @brief Definitions of functions regarding IOHprofiler random numbers.
 *
 * @note This file contains non-C89-standard types (such as uint32_t and uint64_t), which should
 * eventually be fixed.
 */
#ifndef IOH_PROFILER_RANDOM
#define IOH_PROFILER_RANDOM

#include <math.h>

#line 14 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/../profiler/IOHprofiler_random.c"

#define IOHprofiler_NORMAL_POLAR /* Use polar transformation method */

#define IOHprofiler_SHORT_LAG 273
#define IOHprofiler_LONG_LAG 607

/**
 * @brief A structure containing the state of the IOHprofiler random generator.
 */
struct IOHprofiler_random_state_s {
    double x[IOHprofiler_LONG_LAG];
    size_t index;
};

/**
 * @brief A lagged Fibonacci random number generator.
 *
 * This generator is nice because it is reasonably small and directly generates double values. The chosen
 * lags (607 and 273) lead to a generator with a period in excess of 2^607-1.
 */
static void IOHprofiler_random_generate(IOHprofiler_random_state_t *state) {
    size_t i;
    for (i = 0; i < IOHprofiler_SHORT_LAG; ++i) {
        double t = state->x[i] + state->x[i + (IOHprofiler_LONG_LAG - IOHprofiler_SHORT_LAG)];
        if (t >= 1.0)
            t -= 1.0;
        state->x[i] = t;
    }
    for (i = IOHprofiler_SHORT_LAG; i < IOHprofiler_LONG_LAG; ++i) {
        double t = state->x[i] + state->x[i - IOHprofiler_SHORT_LAG];
        if (t >= 1.0)
            t -= 1.0;
        state->x[i] = t;
    }
    state->index = 0;
}

IOHprofiler_random_state_t *IOHprofiler_random_new(uint32_t seed) {
    IOHprofiler_random_state_t *state = (IOHprofiler_random_state_t *)IOHprofiler_allocate_memory(sizeof(*state));
    size_t i;
    /* Expand seed to fill initial state array. */
    for (i = 0; i < IOHprofiler_LONG_LAG; ++i) {
        /* Uses uint64_t to silence the compiler ("shift count negative or too big, undefined behavior" warning) */
        state->x[i] = ((double)seed) / (double)(((uint64_t)1UL << 32) - 1);
        /* Advance seed based on simple RNG from TAOCP */
        seed = (uint32_t)1812433253UL * (seed ^ (seed >> 30)) + ((uint32_t)i + 1);
    }
    state->index = 0;
    return state;
}

void IOHprofiler_random_free(IOHprofiler_random_state_t *state) {
    IOHprofiler_free_memory(state);
}

double IOHprofiler_random_uniform(IOHprofiler_random_state_t *state) {
    /* If we have consumed all random numbers in our archive, it is time to run the actual generator for one
   * iteration to refill the state with 'LONG_LAG' new values. */
    if (state->index >= IOHprofiler_LONG_LAG)
        IOHprofiler_random_generate(state);
    return state->x[state->index++];
}

/**
 * Instead of using the (expensive) polar method, we may cheat and abuse the central limit theorem. The sum
 * of 12 uniform random values has mean 6, variance 1 and is approximately normal. Subtract 6 and you get
 * an approximately N(0, 1) random number.
 */
double IOHprofiler_random_normal(IOHprofiler_random_state_t *state) {
    double normal;
#ifdef IOHprofiler_NORMAL_POLAR
    const double u1 = IOHprofiler_random_uniform(state);
    const double u2 = IOHprofiler_random_uniform(state);
    normal = sqrt(-2 * log(u1)) * cos(2 * IOHprofiler_pi * u2);
#else
    int i;
    normal = 0.0;
    for (i = 0; i < 12; ++i) {
        normal += IOHprofiler_random_uniform(state);
    }
    normal -= 6.0;
#endif
    return normal;
}

/* Be hygienic (for amalgamation) and undef lags. */
#undef IOHprofiler_SHORT_LAG
#undef IOHprofiler_LONG_LAG
#endif
#line 13 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/dummy_random.c"
#line 14 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/dummy_random.c"




static void compute_dummy_random_match(int * postion_match, const int old_dimension, const int new_dimension){
  size_t i,j,l;
  int temp;
  double *randN = IOHprofiler_allocate_vector(1);
  int flag;
  int dummyins = 10000;
  IOHprofiler_random_state_t *random_generator=IOHprofiler_random_new(dummyins);
  int * flip;

  l = new_dimension;
  flip = IOHprofiler_allocate_int_vector(l);
  for(i = 0; i < l; ++i){
    while(1){
      flag = 0;
      temp = (int)(IOHprofiler_random_uniform(random_generator) * old_dimension);
      for(j = 0; j < i; ++j){
        if(temp == postion_match[j]){
          flag = 1;
          break;
        }
      }
      if(flag == 0){break;}
    }
    postion_match[i] = temp;
  }
  IOHprofiler_free_memory(flip);
  IOHprofiler_free_memory(randN);
  IOHprofiler_random_free(random_generator);
}

static void dummy_random_evaluate(IOHprofiler_problem_t *problem, int *x, double *y) {
  size_t i;
  dummy_random_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (dummy_random_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
/*fprintf(stderr,"inner problem name %s, dim %d\n",inner_problem->problem_name,inner_problem->number_of_variables);
fprintf(stderr,"len %d\n",problem->number_of_variables);*/
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->reduncted_x[i] = x[data->postion_match[i]];
/*fprintf(stderr,"%d ",x[data->postion_match[i]]);*/
  }
/*fprintf(stderr,"\n");*/
  IOHprofiler_evaluate_function(inner_problem, data->reduncted_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void dummy_random_free(void *thing) {
  dummy_random_data_t *data = (dummy_random_data_t *) thing;
  IOHprofiler_free_memory(data->reduncted_x);
  IOHprofiler_free_memory(data->postion_match);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_dummy_random(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int dummy_bounds) {
  if(*offset<2){return inner_problem;}
  dummy_random_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  size_t new_dimension;
  if (dummy_bounds)
    IOHprofiler_error("dummy_bounds not implemented.");
 
  
  new_dimension = offset[0];
  assert(new_dimension <= inner_problem->number_of_variables);
  data = (dummy_random_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, 1);
  data->reduncted_x = IOHprofiler_allocate_int_vector(new_dimension);
  data->postion_match = IOHprofiler_allocate_int_vector(new_dimension);
  compute_dummy_random_match(data->postion_match,inner_problem->number_of_variables,new_dimension);

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, dummy_random_free, "dummy_random");
  problem->number_of_variables = new_dimension;
  /*inner_problem->number_of_variables = problem->number_of_variables;*/

  while(inner_problem->data != NULL){
    inner_problem = IOHprofiler_problem_transformed_get_inner_problem(inner_problem);
    /*inner_problem->number_of_variables = problem->number_of_variables;*/
  }

  problem->evaluate_function = dummy_random_evaluate;
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = problem->best_parameter[data->postion_match[i]];
  }
  IOHprofiler_evaluate_function(inner_problem, problem->best_parameter, problem->best_value);
  return problem;
}
#endif
#line 15 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/epistasis.c"
/**
 * @file transform_vars_epistasis.c
 * @brief Implementation of epistasis all decision values by an offset.
 */
#ifndef EPISTASIS
#define EPISTASIS

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/epistasis.c"
#line 12 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/epistasis.c"

#line 14 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/epistasis.c"


void base_epistasis(const int * xIn, const int start, const int nu, int * xOut) {

    const int end = (start + nu) - 1;
    const int flip = xIn[start];
    int i,j;
    int result;
    int skip = start;
    for (i = end ; i >= start; --i) {
      result = flip;
      for (j = end; j > start; --j) {
        if (j != skip) {
          result ^= (xIn[j]);
        }
      }
      xOut[i] = result;
      if ((--skip) < start) {
        skip = end;
      }
    }
  }

void epistasis(const int * xIn, const int nu, int* xOut,int length) {
    const int end = length - nu;
    int i ;
    for (i=0; i <= end; i += nu) {
      base_epistasis(xIn, i, nu, xOut);
    }
    if (i < length) {
      base_epistasis(xIn, i, length - i, xOut);
    }
  }
static void layer_epistasis_compute(const int *x, int * epistasis_x,  int block_size, const size_t dimension){
epistasis(x,block_size,epistasis_x,dimension);
}




static void epistasis_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  epistasis_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (epistasis_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);

  layer_epistasis_compute(x, data->epistasis_x, data->offset[0], problem->number_of_variables);

  IOHprofiler_evaluate_function(inner_problem, data->epistasis_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void epistasis_free(void *thing) {
  epistasis_data_t *data = (epistasis_data_t *) thing;
  IOHprofiler_free_memory(data->epistasis_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_epistasis(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int epistasis_bounds) {
    
  if(*offset==0){return inner_problem;}
  epistasis_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  if (epistasis_bounds)
    IOHprofiler_error("epistasis_bounds not implemented.");

 
  data = (epistasis_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, 1);
  data->epistasis_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);

  
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, epistasis_free, "epistasis");
  problem->evaluate_function = epistasis_evaluate;
  /* Compute best parameter */
  /*Best parameter will not change with this transformation*/

  return problem;
}
#endif
#line 16 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/neutrality.c"
/**
 * @file transform_vars_neutrality.c
 * @brief Implementation of neutrality all decision values by an offset.
 */
#ifndef NEUTRALITY
#define NEUTRALITY

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/neutrality.c"
#line 12 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/neutrality.c"

#line 14 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../layer/neutrality.c"


static int layer_neutrality_compute_old(const int *x, const int index, const int block_size){
  size_t number_of_one, number_of_zero, i;
  number_of_zero = 0;
  number_of_one = 0;
  i = 0;
  while(i < block_size){
    if(x[index + i] == 0){
      number_of_zero++;
    }
    if(x[index + i] == 1){
      number_of_one++;
    }
    ++i;
  }
  return (number_of_zero >= number_of_one ? 0 : 1);
}
static void layer_neutrality_compute(const int *xIn, int *xOut, const int mu,int dim,int temp_dim){
  int thresholdFor1 = (mu >> 1) + (mu & 1);
  int i,j,ones,flush;
  int temp;
  i=0;j=0; ones=0; flush=mu;
  while((i<dim) && (j<temp_dim)){
    if (xIn[i]==1){
      ones+=1;
    }
    i+=1;
    if(i>=flush){
      flush+=mu;
      if (ones >= thresholdFor1){temp=1;}else{temp=0;}
      xOut[j]=temp;
      j+=1;
      ones=0;
    }
  }
}
/*
static void neutrality_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  neutrality_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (neutrality_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->neutrality_x[i] = layer_neutrality_compute(x, i*data->offset[0], data->offset[0]);
  }

  IOHprofiler_evaluate_function(inner_problem, data->neutrality_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}*/

/**
 * @brief Frees the data object.
 */
static void neutrality_free(void *thing) {
  neutrality_data_t *data = (neutrality_data_t *) thing;
  IOHprofiler_free_memory(data->neutrality_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
/*
static IOHprofiler_problem_t *transform_neutrality(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int neutrality_bounds) {
    
  if(*offset==0){return inner_problem;}
  neutrality_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  size_t new_dimension;
  if (neutrality_bounds)
    IOHprofiler_error("neutrality_bounds not implemented.");

  if(inner_problem->number_of_variables >= offset[0])
  {
    new_dimension = inner_problem->number_of_variables / offset[0];
  }
  else{
    return inner_problem;
  }
  
  assert(new_dimension > 0);
  data = (neutrality_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, inner_problem->number_of_variables);
  data->neutrality_x = IOHprofiler_allocate_int_vector(new_dimension);

  
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, neutrality_free, "neutrality");
  problem->number_of_variables = new_dimension;
  problem->evaluate_function = neutrality_evaluate;
  while(inner_problem->data != NULL){
    inner_problem = IOHprofiler_problem_transformed_get_inner_problem(inner_problem);
    inner_problem->number_of_variables = problem->number_of_variables;
  }
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = layer_neutrality_compute(inner_problem->best_parameter, i*data->offset[0], data->offset[0]);
  }
  problem->evaluate_function(problem, problem->best_parameter, problem->best_value);
  return problem;
}*/
#endif
#line 17 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"

/*Load basic transformation of problems (scale/shift/xor/sigma*/
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_obj_scale.c"
/**
 * @file transform_obj_scale.c
 * @brief Implementation of scaleing the objective value by the given offset.
 */
#ifndef TRANSFORM_OBJ_SCALE
#define TRANSFORM_OBJ_SCALE

#include <assert.h>

#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler.h"
/**
 * @file IOHprofiler.h
 * @brief All public IOHprofiler functions and variables are defined in this file.
 *
 * It is the authoritative reference, if any function deviates from the documented behavior it is considered
 * a bug. See the function definitions for their detailed descriptions.
 */

#ifndef __IOHprofiler_H__
#define __IOHprofiler_H__

#include <stddef.h>

/* Definitions of some 32 and 64-bit types (used by the random number generator) */
#ifdef _MSC_VER
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

/* Include definition for NAN among other things */
#include <float.h>
#include <math.h>
#ifndef NAN
/** @brief Definition of NAN to be used only if undefined by the included headers */
#define NAN 8.8888e88
#endif
#ifndef isnan
/** @brief Definition of isnan to be used only if undefined by the included headers */
#define isnan(x) (0)
#endif
#ifndef INFINITY
/** @brief Definition of INFINITY to be used only if undefined by the included headers */
#define INFINITY 1e22
/* why not using 1e99? */
#endif
#ifndef isinf
/** @brief Definition of isinf to be used only if undefined by the included headers */
#define isinf(x) (0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief IOHprofiler's version.
 *
 * Automatically updated by do.py.
 */
/**@{*/
static const char IOHprofiler_version[32] = "";
/**@}*/

/***********************************************************************************************************/
/**
 * @brief IOHprofiler's own pi constant. Simplifies the case, when the value of pi changes.
 */
/**@{*/
static const double IOHprofiler_pi = 3.14159265358979323846;
/**@}*/

/***********************************************************************************************************/

/** @brief Logging level type. */
typedef enum {
    IOHprofiler_ERROR,   /**< @brief only error messages are output */
    IOHprofiler_WARNING, /**< @brief error and warning messages are output */
    IOHprofiler_INFO,    /**< @brief error, warning and info messages are output */
    IOHprofiler_DEBUG    /**< @brief error, warning, info and debug messages are output */
} IOHprofiler_log_level_type_e;

/***********************************************************************************************************/

/** @brief Structure containing a IOHprofiler problem. */
struct IOHprofiler_problem_s;

/**
 * @brief The IOHprofiler problem type.
 *
 * See IOHprofiler_problem_s for more information on its fields. */
typedef struct IOHprofiler_problem_s IOHprofiler_problem_t;

/** @brief Structure containing a IOHprofiler suite. */
struct IOHprofiler_suite_s;

/**
 * @brief The IOHprofiler suite type.
 *
 * See IOHprofiler_suite_s for more information on its fields. */
typedef struct IOHprofiler_suite_s IOHprofiler_suite_t;

/** @brief Structure containing a IOHprofiler observer. */
struct IOHprofiler_observer_s;

/**
 * @brief The IOHprofiler observer type.
 *
 * See IOHprofiler_observer_s for more information on its fields. */
typedef struct IOHprofiler_observer_s IOHprofiler_observer_t;

/** @brief Structure containing a IOHprofiler archive. */
struct IOHprofiler_archive_s;

/**
 * @brief The IOHprofiler archive type.
 *
 * See IOHprofiler_archive_s for more information on its fields. */
typedef struct IOHprofiler_archive_s IOHprofiler_archive_t;

/** @brief Structure containing a IOHprofiler random state. */
struct IOHprofiler_random_state_s;

/**
 * @brief The IOHprofiler random state type.
 *
 * See IOHprofiler_random_state_s for more information on its fields. */
typedef struct IOHprofiler_random_state_s IOHprofiler_random_state_t;

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler suite
 */
/**@{*/

/**
 * @brief Constructs a IOHprofiler suite.
 */
IOHprofiler_suite_t *IOHprofiler_suite(const char *suite_name, const char *suite_instance, const char *suite_options,int number, char** layer_param,char * temp_dim);

/**
 * @brief Frees the given suite.
 */
void IOHprofiler_suite_free(IOHprofiler_suite_t *suite);

/**
 * @brief Returns the next (observed) problem of the suite or NULL if there is no next problem left.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_next_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 *
 * @returns The current problem of the suite.
 */
IOHprofiler_problem_t *IOHprofiler_suite_reset_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 * @brief Returns the problem of the suite defined by problem_index.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_problem(IOHprofiler_suite_t *suite, const size_t problem_index);

/**
 * @brief Returns the number of problems in the given suite.
 */
size_t IOHprofiler_suite_get_number_of_problems(const IOHprofiler_suite_t *suite);

/**
 * @brief Returns the function number in the suite in position function_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_function_from_function_index(const IOHprofiler_suite_t *suite, const size_t function_idx);

/**
 * @brief Returns the dimension number in the suite in position dimension_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_dimension_from_dimension_index(const IOHprofiler_suite_t *suite, const size_t dimension_idx);

/**
 * @brief Returns the instance number in the suite in position instance_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_instance_from_instance_index(const IOHprofiler_suite_t *suite, const size_t instance_idx);
/**@}*/

/**
 * @name Encoding/decoding problem index
 *
 * General schema for encoding/decoding a problem index. Note that the index depends on the number of
 * instances a suite is defined with (it should be called a suite-instance-depending index...).
 * Also, while functions, instances and dimensions start from 1, function_idx, instance_idx and dimension_idx
 * as well as suite_dep_index start from 0!
 *
 * Showing an example with 2 dimensions (2, 3), 5 instances (6, 7, 8, 9, 10) and 2 functions (1, 2):
 *
   \verbatim
   index | instance | function | dimension
   ------+----------+----------+-----------
       0 |        6 |        1 |         2
       1 |        7 |        1 |         2
       2 |        8 |        1 |         2
       3 |        9 |        1 |         2
       4 |       10 |        1 |         2
       5 |        6 |        2 |         2
       6 |        7 |        2 |         2
       7 |        8 |        2 |         2
       8 |        9 |        2 |         2
       9 |       10 |        2 |         2
      10 |        6 |        1 |         3
      11 |        7 |        1 |         3
      12 |        8 |        1 |         3
      13 |        9 |        1 |         3
      14 |       10 |        1 |         3
      15 |        6 |        2 |         2
      16 |        7 |        2 |         3
      17 |        8 |        2 |         3
      18 |        9 |        2 |         3
      19 |       10 |        2 |         3

   index | instance_idx | function_idx | dimension_idx
   ------+--------------+--------------+---------------
       0 |            0 |            0 |             0
       1 |            1 |            0 |             0
       2 |            2 |            0 |             0
       3 |            3 |            0 |             0
       4 |            4 |            0 |             0
       5 |            0 |            1 |             0
       6 |            1 |            1 |             0
       7 |            2 |            1 |             0
       8 |            3 |            1 |             0
       9 |            4 |            1 |             0
      10 |            0 |            0 |             1
      11 |            1 |            0 |             1
      12 |            2 |            0 |             1
      13 |            3 |            0 |             1
      14 |            4 |            0 |             1
      15 |            0 |            1 |             1
      16 |            1 |            1 |             1
      17 |            2 |            1 |             1
      18 |            3 |            1 |             1
      19 |            4 |            1 |             1
   \endverbatim
 */
/**@{*/
/**
 * @brief Computes the index of the problem in the suite that corresponds to the given function, dimension
 * and instance indices.
 */
size_t IOHprofiler_suite_encode_problem_index(const IOHprofiler_suite_t *suite,
                                              const size_t function_idx,
                                              const size_t dimension_idx,
                                              const size_t instance_idx);

/**
 * @brief Computes the function, dimension and instance indexes of the problem with problem_index in the
 * given suite.
 */
void IOHprofiler_suite_decode_problem_index(const IOHprofiler_suite_t *suite,
                                            const size_t problem_index,
                                            size_t *function_idx,
                                            size_t *dimension_idx,
                                            size_t *instance_idx);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler observer
 */
/**@{*/
/**
 * @brief Constructs a IOHprofiler observer.
 */
IOHprofiler_observer_t *IOHprofiler_observer(const char *observer_name, const char *options);

/**
 * @brief Frees the given observer.
 */
void IOHprofiler_observer_free(IOHprofiler_observer_t *observer);

/**
 * @brief Adds an observer to the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_add_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**
 * @brief Removes an observer from the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_remove_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler problem
 */
/**@{*/
/**
 * @brief Evaluates the problem function in point x and save the result in y.
  logger_** functions use number_of_parameters and parameters to log extra informations of algorithms' adaptive parameters.
  If there is no need to log parameters, set number_of_parameters and parameters as 0 and NULL respectively.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Evaluates the problem constraints in point x and save the result in y.
 */
void IOHprofiler_evaluate_constraint(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Recommends a solution as the current best guesses to the problem.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief Frees the given problem.
 */
void IOHprofiler_problem_free(IOHprofiler_problem_t *problem);

void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters);

/**
 * @brief Returns the name of the problem.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the ID of the problem.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of variables i.e. the dimension of the problem.
 */
size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of objectives of the problem.
 */
size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of evaluations done on the problem.
 */
size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns 1 if the final target was hit, 0 otherwise.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the best observed value for the first objective.
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the target value for the first objective.
 */
double depreciated_IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with lower bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with upper bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the problem_index of the problem in its current suite.
 */
size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns an initial solution, i.e. a feasible variable setting, to the problem.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding random numbers
 */
/**@{*/

/**
 * @brief Creates and returns a new random number state using the given seed.
 */
IOHprofiler_random_state_t *IOHprofiler_random_new(uint32_t seed);

/**
 * @brief Frees all memory associated with the random state.
 */
void IOHprofiler_random_free(IOHprofiler_random_state_t *state);

/**
 * @brief Returns one uniform [0, 1) random value from the random number generator associated with the given
 * state.
 */
double IOHprofiler_random_uniform(IOHprofiler_random_state_t *state);

/**
 * @brief Generates an approximately normal random number.
 */
double IOHprofiler_random_normal(IOHprofiler_random_state_t *state);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods managing memory
 */
/**@{*/
/**
 * @brief Safe memory allocation that either succeeds or triggers a IOHprofiler_error.
 */
void *IOHprofiler_allocate_memory(const size_t size);

/**
 * @brief Safe memory allocation for a vector of doubles that either succeeds or triggers a IOHprofiler_error.
 */
double *IOHprofiler_allocate_vector(const size_t size);

/**
 * @brief Safe memory allocation for a vector of int that either succeeds or triggers a IOHprofiler_error.
 */
int *IOHprofiler_allocate_int_vector(const size_t size);

/**
 * @brief Frees the allocated memory.
 */
void IOHprofiler_free_memory(void *data);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler messages
 */
/**@{*/
/**
 * @brief Signals a fatal error.
 */
void IOHprofiler_error(const char *message, ...);

/**
 * @brief Warns about error conditions.
 */
void IOHprofiler_warning(const char *message, ...);

/**
 * @brief Outputs some information.
 */
void IOHprofiler_info(const char *message, ...);

/**
 * @brief Prints only the given message without any prefix and new line.
 *
 * A function similar to IOHprofiler_info but producing no additional text than
 * the given message.
 *
 * The output is only produced if IOHprofiler_log_level >= IOHprofiler_INFO.
 */
void IOHprofiler_info_partial(const char *message, ...);

/**
 * @brief Outputs detailed information usually used for debugging.
 */
void IOHprofiler_debug(const char *message, ...);

/**
 * @brief Sets the IOHprofiler log level to the given value and returns the previous value of the log level.
 */
const char *IOHprofiler_set_log_level(const char *level);
/**@}*/

/***********************************************************************************************************/

/**
 * @brief Constructs a IOHprofiler archive.
 */
IOHprofiler_archive_t *IOHprofiler_archive(const char *suite_name,
                                           const size_t function,
                                           const size_t dimension,
                                           const size_t instance);
/**
 * @brief Adds a solution with objectives (y1, y2) to the archive if none of the existing solutions in the
 * archive dominates it. In this case, returns 1, otherwise the archive is not updated and the method
 * returns 0.
 */

int IOHprofiler_archive_add_solution(IOHprofiler_archive_t *archive, const double y1, const double y2, const char *text);

/**
 * @brief Returns the number of (non-dominated) solutions in the archive (computed first, if needed).
 */
size_t IOHprofiler_archive_get_number_of_solutions(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the hypervolume of the archive (computed first, if needed).
 */
double IOHprofiler_archive_get_hypervolume(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the text of the next (non-dominated) solution in the archive and "" when there are no
 * solutions left. The first two solutions are always the extreme ones.
 */
const char *IOHprofiler_archive_get_next_solution_text(IOHprofiler_archive_t *archive);

/**
 * @brief Frees the archive.
 */
void IOHprofiler_archive_free(IOHprofiler_archive_t *archive);

/***********************************************************************************************************/

/**
 * @name Other useful methods
 */
/**@{*/
/**
 * @brief Removes the given directory and all its contents.
 */
int IOHprofiler_remove_directory(const char *path);

/**
 * @brief Formatted string duplication.
 */
char *IOHprofiler_strdupf(const char *str, ...);
/**@}*/

/***********************************************************************************************************/
typedef int (*int_to_int_func)(int);

struct WModel{
  size_t number_of_layers;
  int *layer1;
  int min1; int_to_int_func l_max1;
  int *layer2;
  int min2;int_to_int_func l_max2;
  int *layer3;
  int min3; int_to_int_func l_max3;
  int *layer4;
  int min4; int_to_int_func l_max4;
  int *counter;
};


#ifdef __cplusplus
}
#endif
#endif
#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_obj_scale.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_problem.c"
/**
 * @file IOHprofiler_problem.c
 * @brief Definitions of functions regarding IOHprofiler problems.
 */
#ifndef IOH_PROFILER_PROBLEM
#define IOH_PROFILER_PROBLEM

#include <float.h>
#line 10 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_internal.h"
/**
 * @file IOHprofiler_internal.h
 * @brief Definitions of internal IOHprofiler structures and typedefs.
 *
 * These are used throughout the IOHprofiler code base but should not be used by any external code.
 */

#ifndef __IOHprofiler_INTERNAL__
#define __IOHprofiler_INTERNAL__

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************************************/
/**
 * @brief The data free function type.
 *
 * This is a template for functions that free the contents of data (used to free the contents of data
 * fields in IOHprofiler_problem, IOHprofiler_suite and IOHprofiler_observer).
 */
typedef void (*IOHprofiler_data_free_function_t)(void *data);

/**
 * @brief The problem free function type.
 *
 * This is a template for functions that free the problem structure.
 */
typedef void (*IOHprofiler_problem_free_function_t)(IOHprofiler_problem_t *problem);

/**
 * @brief The initial solution function type.
 *
 * This is a template for functions that return an initial solution of the problem.
 */
typedef void (*IOHprofiler_initial_solution_function_t)(const IOHprofiler_problem_t *problem, int *x);

/**
 * @brief The evaluate function type.
 *
 * This is a template for functions that perform an evaluation of the problem (to evaluate the problem
 * function, the problems constraints etc.).
 */
typedef void (*IOHprofiler_evaluate_function_t)(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief The recommend solutions function type.
 *
 * This is a template for functions that log a recommended solution.
 */
typedef void (*IOHprofiler_recommend_function_t)(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief The allocate logger function type.
 *
 * This is a template for functions that allocate a logger (wrap a logger around the given problem and return
 * the wrapped problem).
 */
typedef IOHprofiler_problem_t *(*IOHprofiler_logger_allocate_function_t)(IOHprofiler_observer_t *observer,
                                                                         IOHprofiler_problem_t *problem);

/**
 * @brief The transformed IOHprofiler problem data type.
 *
 * This is a type of a generic structure for a transformed ("outer") IOHprofiler_problem. It makes possible the
 * wrapping of problems as layers of an onion. Initialized in the IOHprofiler_problem_transformed_allocate function,
 * it makes the current ("outer") transformed problem a "derived problem class", which inherits from the
 * "inner" problem, the "base class".
 *
 * From the perspective of the inner problem:
 * - data holds the meta-information to administer the inheritance
 * - data->data holds the additional fields of the derived class (the outer problem)
 * - data->inner_problem points to the inner problem (now we have a linked list)
 */
typedef struct {
    IOHprofiler_problem_t *inner_problem;                /**< @brief Pointer to the inner problem */
    void *data;                                          /**< @brief Pointer to data, which enables further
                                                  wrapping of the problem */
    IOHprofiler_data_free_function_t data_free_function; /**< @brief Function to free the contents of data */
} IOHprofiler_problem_transformed_data_t;

/**
 * @brief The free logger function type.
 *
 * This is a template for functions that free a logger.
 */
typedef void (*IOHprofiler_logger_free_function_t)(void *logger);

/**
 * @brief The stacked IOHprofiler problem data type.
 *
 * This is a type of a structure used when stacking two problems (especially useful for constructing
 * multi-objective problems).
 */
typedef struct {
    IOHprofiler_problem_t *problem1; /**< @brief Pointer to the first problem (objective) */
    IOHprofiler_problem_t *problem2; /**< @brief Pointer to the second problem (objective) */
} IOHprofiler_problem_stacked_data_t;

/**
 * @brief The option keys data type.
 *
 * This is a type of a structure used to contain a set of known option keys (used by suites and observers).
 */
typedef struct {
    size_t count; /**< @brief Number of option keys */
    char **keys;  /**< @brief Pointer to option keys */
} IOHprofiler_option_keys_t;

/***********************************************************************************************************/

/**
 * @brief The IOHprofiler problem structure.
 *
 * This is one of the main structures in IOHprofiler. It contains information about a problem to be optimized. The
 * problems can be wrapped around each other (similar to the onion layers) by means of the data field and
 * the IOHprofiler_problem_transformed_data_t structure creating some kind of "object inheritance". Even the logger
 * is considered as just another IOHprofiler_problem instance wrapped around the original problem.
 */
struct IOHprofiler_problem_s {
    IOHprofiler_initial_solution_function_t initial_solution;  /**< @brief  The function for creating an initial solution. */
    IOHprofiler_evaluate_function_t evaluate_function;         /**< @brief  The function for evaluating the problem. */
    IOHprofiler_recommend_function_t recommend_solution;       /**< @brief  The function for recommending a solution. */
    IOHprofiler_problem_free_function_t problem_free_function; /**< @brief  The function for freeing this problem. */

    size_t dimension; /**< @brief Number of variables expected before any transformation, used for logging files. */
    size_t number_of_variables;  /**< @brief Number of variables expected by the function, i.e.
                                       problem dimension */
    size_t number_of_objectives; /**< @brief Number of objectives. */
    size_t number_of_parameters; /**<  IOHprofiler @brief Number of parameters. */

    int *smallest_values_of_interest; /**< @brief The lower bounds of the ROI in the decision space. */
    int *largest_values_of_interest;  /**< @brief The upper bounds of the ROI in the decision space. */

    double *best_value;  /**< @brief Optimal (smallest) function value */
    double *nadir_value; /**< @brief The nadir point (defined when number_of_objectives > 1) */
    int *best_parameter; /**< @brief Optimal decision vector (defined only when unique) */
    double *parameters;  /** IOHprofiler @brief parameters setting */
    double *raw_fitness;

    char *problem_name; /**< @brief Problem name. */
    char *problem_id;   /**< @brief Problem ID (unique in the containing suite) */
    char *problem_type; /**< @brief Problem type */

    size_t evaluations; /**< @brief Number of evaluations performed on the problem. */

    /* Convenience fields for output generation */

    double final_target_delta[1];       /**< @brief Final target delta. */
    double best_observed_fvalue[1];     /**< @brief The best observed value so far. */
    size_t best_observed_evaluation[1]; /**< @brief The evaluation when the best value so far was achieved. */

    /* Fields depending on the containing benchmark suite */

    IOHprofiler_suite_t *suite; /**< @brief Pointer to the containing suite (NULL if not given) */
    size_t suite_dep_index;     /**< @brief Suite-depending problem index (starting from 0) */
    size_t suite_dep_function;  /**< @brief Suite-depending function */
    size_t suite_dep_instance;  /**< @brief Suite-depending instance */

    void *data; /**< @brief Pointer to a data instance @see IOHprofiler_problem_transformed_data_t */
};

/**
 * @brief The IOHprofiler observer structure.
 *
 * An observer observes the whole benchmark process. It is independent of suites and problems. Each time a
 * new problem of the suite is being observed, the observer initializes a new logger (wraps the observed
 * problem with the corresponding logger).
 */
struct IOHprofiler_observer_s {
    int is_active;         /**< @brief Whether the observer is active (the logger will log some output). */
    char *observer_name;   /**< @brief Name of the observer for identification purposes. */
    char *result_folder;   /**< @brief Name of the result folder. */
    char *algorithm_name;  /**< @brief Name of the algorithm to be used in logger output. */
    char *algorithm_info;  /**< @brief Additional information on the algorithm to be used in logger output. */
    char *parameters_name; /**< @brief Name of recorded parameters to be used in logger output. */
    size_t number_target_triggers;
    /**< @brief The number of targets between each 10**i and 10**(i+1). */
    double target_precision; /**< @brief The minimal precision used for targets. */
    size_t number_evaluation_triggers;
    /**< @brief The number of triggers between each 10**i and 10**(i+1) evaluation number. */
    char *base_evaluation_triggers;
    /**< @brief The "base evaluations" used to evaluations that trigger logging. */
    size_t number_interval_triggers;
    /**< @brief The size of interval between two triggers. */
    char *complete_triggers; /**< @brief The symbol for recording all evaluation. */

    int precision_x; /**< @brief Output precision for decision variables. */
    int precision_f; /**< @brief Output precision for function values. */
    void *data;      /**< @brief Void pointer that can be used to point to data specific to an observer. */

    IOHprofiler_data_free_function_t data_free_function;             /**< @brief  The function for freeing this observer. */
    IOHprofiler_logger_allocate_function_t logger_allocate_function; /**< @brief  The function for allocating the logger. */
    IOHprofiler_logger_free_function_t logger_free_function;         /**< @brief  The function for freeing the logger. */
};

/**
 * @brief The IOHprofiler suite structure.
 *
 * A suite is a collection of problems constructed by a Cartesian product of the suite's optimization
 * functions, dimensions and instances. The functions and dimensions are fixed for a suite with some name,
 * while the instances are defined dynamically. The suite can be filtered - only the chosen functions,
 * dimensions and instances will be taken into account when iterating through the suite.
 */
struct IOHprofiler_suite_s {
    char *suite_name; /**< @brief Name of the suite. */

    size_t number_of_dimensions; /**< @brief Number of dimensions contained in the suite. */
    size_t *dimensions;          /**< @brief The dimensions contained in the suite. */

    size_t number_of_functions; /**< @brief Number of functions contained in the suite. */
    size_t *functions;          /**< @brief The functions contained in the suite. */

    size_t number_of_instances; /**< @brief Number of instances contained in the suite. */
    char *default_instances;    /**< @brief The instances contained in the suite by default. */
    size_t *instances;          /**< @brief The instances contained in the suite. */

    IOHprofiler_problem_t *current_problem; /**< @brief Pointer to the currently tackled problem. */
    long current_dimension_idx;             /**< @brief The dimension index of the currently tackled problem. */
    long current_function_idx;              /**< @brief The function index of the currently tackled problem. */
    long current_instance_idx;              /**< @brief The instance index of the currently tackled problem. */

    void *data; /**< @brief Void pointer that can be used to point to data specific to a suite. */

    IOHprofiler_data_free_function_t data_free_function; /**< @brief The function for freeing this suite. */
};

#ifdef __cplusplus
}
#endif
#endif
#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_problem.c"

#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_utilities.c"
/**
 * @file IOHprofiler_utilities.c
 * @brief Definitions of miscellaneous functions used throughout the IOHprofiler framework.
 */
#ifndef IOH_PROFILER_UTILITIES
#define IOH_PROFILER_UTILITIES

#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_platform.h"
/**
 * @file IOHprofiler_platform.h
 * @brief Automatic platform-dependent configuration of the IOHprofiler framework.
 *
 * Some platforms and standard conforming compilers require extra defines or includes to provide some
 * functionality.
 *
 * Because most feature defines need to be set before the first system header is included and we do not
 * know when a system header is included for the first time in the amalgamation, all internal files
 * that need these definitions should include this file before any system headers.
 */

#ifndef __COCO_PLATFORM__
#define __COCO_PLATFORM__

#include <stddef.h>

/* Definitions of IOHprofiler_PATH_MAX, IOHprofiler_path_separator, HAVE_GFA and HAVE_STAT heavily used by functions in
 * IOHprofiler_utilities.c */
#if defined(_WIN32) || defined(_WIN64) || defined(__MINGW64__) || defined(__CYGWIN__)
#include <windows.h>
static const char *IOHprofiler_path_separator = "\\";
#define IOHprofiler_PATH_MAX MAX_PATH
#define HAVE_GFA 1
#elif defined(__gnu_linux__)
#include <linux/limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__APPLE__)
#include <sys/stat.h>
#include <sys/syslimits.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__FreeBSD__)
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif (defined(__sun) || defined(sun)) && (defined(__SVR4) || defined(__svr4__))
/* Solaris */
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#else
#error Unknown platform
#endif
#if !defined(IOHprofiler_PATH_MAX)
#error IOHprofiler_PATH_MAX undefined
#endif

/* Definitions needed for creating and removing directories */
/* Separately handle the special case of Microsoft Visual Studio 2008 with x86_64-w64-mingw32-gcc */
#if _MSC_VER
#include <direct.h>
#elif defined(__MINGW32__) || defined(__MINGW64__)
#include <dirent.h>
#else
#include <dirent.h>

#ifdef __cplusplus
extern "C" {
#endif

/* To silence the compiler (implicit-function-declaration warning). */
/** @cond */
int rmdir(const char *pathname);
int unlink(const char *file_name);
int mkdir(const char *pathname, mode_t mode);
/** @endcond */
#endif

/* Definition of the S_IRWXU constant needed to set file permissions */
#if defined(HAVE_GFA)
#define S_IRWXU 0700
#endif

/* To silence the Visual Studio compiler (C4996 warnings in the python build). */
#ifdef _MSC_VER
#pragma warning(disable : 4996)
#endif

#ifdef __cplusplus
}
#endif

#endif
#line 9 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_utilities.c"

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#line 18 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_utilities.c"
#line 19 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_utilities.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_string.c"
/**
 * @file IOHprofiler_string.c
 * @brief Definitions of functions that manipulate strings.
 */
#ifndef IOH_PROFILER_STRING
#define IOH_PROFILER_STRING

#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#line 13 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_string.c"

static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements);

/**
 * @brief Creates a duplicate copy of string and returns a pointer to it.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strdup(const char *string) {
    size_t len;
    char *duplicate;
    if (string == NULL)
        return NULL;
    len = strlen(string);
    duplicate = (char *)IOHprofiler_allocate_memory(len + 1);
    memcpy(duplicate, string, len + 1);
    return duplicate;
}

/**
 * @brief The length of the buffer used in the IOHprofiler_vstrdupf function.
 *
 * @note This should be handled differently!
 */
#define IOHprofiler_VSTRDUPF_BUFLEN 444

/**
 * @brief Formatted string duplication, with va_list arguments.
 */
static char *IOHprofiler_vstrdupf(const char *str, va_list args) {
    static char buf[IOHprofiler_VSTRDUPF_BUFLEN];
    long written;
    /* apparently args can only be used once, therefore
   * len = vsnprintf(NULL, 0, str, args) to find out the
   * length does not work. Therefore we use a buffer
   * which limits the max length. Longer strings should
   * never appear anyway, so this is rather a non-issue. */

#if 0
  written = vsnprintf(buf, IOHprofiler_VSTRDUPF_BUFLEN - 2, str, args);
  if (written < 0)
  IOHprofiler_error("IOHprofiler_vstrdupf(): vsnprintf failed on '%s'", str);
#else /* less safe alternative, if vsnprintf is not available */
    assert(strlen(str) < IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2);
    if (strlen(str) >= IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2)
        IOHprofiler_error("IOHprofiler_vstrdupf(): string is too long");
    written = vsprintf(buf, str, args);
    if (written < 0)
        IOHprofiler_error("IOHprofiler_vstrdupf(): vsprintf failed on '%s'", str);
#endif
    if (written > IOHprofiler_VSTRDUPF_BUFLEN - 3)
        IOHprofiler_error("IOHprofiler_vstrdupf(): A suspiciously long string is tried to being duplicated '%s'", buf);
    return IOHprofiler_strdup(buf);
}

#undef IOHprofiler_VSTRDUPF_BUFLEN

/**
 * Optional arguments are used like in sprintf.
 */
char *IOHprofiler_strdupf(const char *str, ...) {
    va_list args;
    char *s;

    va_start(args, str);
    s = IOHprofiler_vstrdupf(str, args);
    va_end(args);
    return s;
}

/**
 * @brief Returns a concatenate copy of string1 + string2.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strconcat(const char *s1, const char *s2) {
    size_t len1 = strlen(s1);
    size_t len2 = strlen(s2);
    char *s = (char *)IOHprofiler_allocate_memory(len1 + len2 + 1);

    memcpy(s, s1, len1);
    memcpy(&s[len1], s2, len2 + 1);
    return s;
}

/**
 * @brief Returns the first index where seq occurs in base and -1 if it doesn't.
 *
 * @note If there is an equivalent standard C function, this can/should be removed.
 */
static long IOHprofiler_strfind(const char *base, const char *seq) {
    const size_t strlen_seq = strlen(seq);
    const size_t last_first_idx = strlen(base) - strlen(seq);
    size_t i, j;

    if (strlen(base) < strlen(seq))
        return -1;

    for (i = 0; i <= last_first_idx; ++i) {
        if (base[i] == seq[0]) {
            for (j = 0; j < strlen_seq; ++j) {
                if (base[i + j] != seq[j])
                    break;
            }
            if (j == strlen_seq) {
                if (i > 1e9)
                    IOHprofiler_error("IOHprofiler_strfind(): strange values observed i=%lu, j=%lu, strlen(base)=%lu",
                                      (unsigned long)i, (unsigned long)j, (unsigned long)strlen(base));
                return (long)i;
            }
        }
    }
    return -1;
}

/**
 * @brief Splits a string based on the given delimiter.
 *
 * Returns a pointer to the resulting substrings with NULL as the last one.
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char **IOHprofiler_string_split(const char *string, const char delimiter) {
    char **result;
    char *str_copy, *ptr, *token;
    char str_delimiter[2];
    size_t i;
    size_t count = 1;

    str_copy = IOHprofiler_strdup(string);

    /* Counts the parts between delimiters */
    ptr = str_copy;
    while (*ptr != '\0') {
        if (*ptr == delimiter) {
            count++;
        }
        ptr++;
    }
    /* Makes room for an empty string that will be appended at the end */
    count++;

    result = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));

    /* Iterates through tokens
   * NOTE: strtok() ignores multiple delimiters, therefore the final number of detected substrings might be
   * lower than the count. This is OK. */
    i = 0;
    /* A char* delimiter needs to be used, otherwise strtok() can surprise */
    str_delimiter[0] = delimiter;
    str_delimiter[1] = '\0';
    token = strtok(str_copy, str_delimiter);
    while (token) {
        assert(i < count);
        *(result + i++) = IOHprofiler_strdup(token);
        token = strtok(NULL, str_delimiter);
    }
    *(result + i) = NULL;

    IOHprofiler_free_memory(str_copy);

    return result;
}

/**
 * @brief Creates and returns a string with removed characters between from and to.
 *
 * If you wish to remove characters from the beginning of the string, set from to "".
 * If you wish to remove characters until the end of the string, set to to "".
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_remove_from_string(const char *string, const char *from, const char *to) {
    char *result, *start, *stop;

    result = IOHprofiler_strdup(string);

    if (strcmp(from, "") == 0) {
        /* Remove from the start */
        start = result;
    } else
        start = strstr(result, from);

    if (strcmp(to, "") == 0) {
        /* Remove until the end */
        stop = result + strlen(result);
    } else
        stop = strstr(result, to);

    if ((start == NULL) || (stop == NULL) || (stop < start)) {
        IOHprofiler_error("IOHprofiler_remove_from_string(): failed to remove characters between %s and %s from string %s",
                          from, to, string);
        return NULL; /* Never reached */
    }

    memmove(start, stop, strlen(stop) + 1);

    return result;
}

/**
 * @brief Returns the numbers defined by the ranges.
 *
 * Reads ranges from a string of positive ranges separated by commas. For example: "-3,5-6,8-". Returns the
 * numbers that are defined by the ranges if min and max are used as their extremes. If the ranges with open
 * beginning/end are not allowed, use 0 as min/max. The returned string has an appended 0 to mark its end.
 * A maximum of max_count values is returned. If there is a problem with one of the ranges, the parsing stops
 * and the current result is returned. The memory of the returned object needs to be freed by the caller.
 */
static size_t *IOHprofiler_string_parse_ranges(const char *string,
                                               const size_t min,
                                               const size_t max,
                                               const char *name,
                                               const size_t max_count) {
    char *ptr, *dash = NULL;
    char **ranges, **numbers;
    size_t i, j, count;
    size_t num[2];

    size_t *result;
    size_t i_result = 0;

    char *str = IOHprofiler_strdup(string);

    /* Check for empty string */
    if ((str == NULL) || (strlen(str) == 0)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): cannot parse empty ranges");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    ptr = str;
    /* Check for disallowed characters */
    while (*ptr != '\0') {
        if ((*ptr != '-') && (*ptr != ',') && !isdigit((unsigned char)*ptr)) {
            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - cannot parse ranges with '%c'", str,
                                *ptr);
            IOHprofiler_free_memory(str);
            return NULL;
        } else
            ptr++;
    }
    /* Check for incorrect boundaries */
    if ((max > 0) && (min > max)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): incorrect boundaries");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    result = IOHprofiler_allocate_vector_size_t(max_count + 1);

    /* Split string to ranges w.r.t commas */
    ranges = IOHprofiler_string_split(str, ',');
    IOHprofiler_free_memory(str);
    if (ranges) {
        /* Go over the current range */
        for (i = 0; *(ranges + i); i++) {
            ptr = *(ranges + i);
            /* Count the number of '-' */
            count = 0;
            while (*ptr != '\0') {
                if (*ptr == '-') {
                    if (count == 0)
                        /* Remember the position of the first '-' */
                        dash = ptr;
                    count++;
                }
                ptr++;
            }
            /* Point again to the start of the range */
            ptr = *(ranges + i);

            /* Check for incorrect number of '-' */
            if (count > 1) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - too many '-'s", string);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            } else if (count == 0) {
                /* Range is in the format: n (no range) */
                num[0] = (size_t)strtol(ptr, NULL, 10);
                num[1] = num[0];
            } else {
                /* Range is in one of the following formats: n-m / -n / n- / - */

                /* Split current range to numbers w.r.t '-' */
                numbers = IOHprofiler_string_split(ptr, '-');
                j = 0;
                if (numbers) {
                    /* Read the numbers */
                    for (j = 0; *(numbers + j); j++) {
                        assert(j < 2);
                        num[j] = (size_t)strtol(*(numbers + j), NULL, 10);
                        IOHprofiler_free_memory(*(numbers + j));
                    }
                }
                IOHprofiler_free_memory(numbers);

                if (j == 0) {
                    /* Range is in the format - (open ends) */
                    if ((min == 0) || (max == 0)) {
                        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open ends; some ranges ignored", name);
                        /* Cleanup */
                        for (j = i; *(ranges + j); j++)
                            IOHprofiler_free_memory(*(ranges + j));
                        IOHprofiler_free_memory(ranges);
                        if (i_result == 0) {
                            IOHprofiler_free_memory(result);
                            return NULL;
                        }
                        result[i_result] = 0;
                        return result;
                    }
                    num[0] = min;
                    num[1] = max;
                } else if (j == 1) {
                    if (dash - *(ranges + i) == 0) {
                        /* Range is in the format -n */
                        if (min == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open beginning; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = num[0];
                        num[0] = min;
                    } else {
                        /* Range is in the format n- */
                        if (max == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open end; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = max;
                    }
                }
                /* if (j == 2), range is in the format n-m and there is nothing to do */
            }

            /* Make sure the boundaries are taken into account */
            if ((min > 0) && (num[0] < min)) {
                num[0] = min;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be >= %lu", name,
                                    (unsigned long)min);
              }
            if ((max > 0) && (num[1] > max)) {
                num[1] = max;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be <= %lu", name, (unsigned long) max);
            }
            if (num[0] > num[1]) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges not within boundaries; some ranges ignored", name);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            }

            /* Write in result */
            for (j = num[0]; j <= num[1]; j++) {
                if (i_result > max_count - 1)
                    break;
                result[i_result++] = j;
            }

            IOHprofiler_free_memory(*(ranges + i));
            *(ranges + i) = NULL;
        }
    }

    IOHprofiler_free_memory(ranges);

    if (i_result == 0) {
        IOHprofiler_free_memory(result);
        return NULL;
    }

    result[i_result] = 0;
    return result;
}

/**
 * @brief Trims the given string (removes any leading and trailing spaces).
 *
 * If the string contains any leading spaces, the contents are shifted so that if it was dynamically
 * allocated, it can be still freed on the returned pointer.
 */
static char *IOHprofiler_string_trim(char *string) {
    size_t len = 0;
    char *frontp = string;
    char *endp = NULL;

    if (string == NULL) {
        return NULL;
    }
    if (string[0] == '\0') {
        return string;
    }

    len = strlen(string);
    endp = string + len;

    /* Move the front and back pointers to address the first non-whitespace characters from each end. */
    while (isspace((unsigned char)*frontp)) {
        ++frontp;
    }
    if (endp != frontp) {
        while (isspace((unsigned char)*(--endp)) && endp != frontp) {
        }
    }

    if (string + len - 1 != endp)
        *(endp + 1) = '\0';
    else if (frontp != string && endp == frontp)
        *string = '\0';

    /* Shift the string. Note the reuse of endp to mean the front of the string buffer now. */
    endp = string;
    if (frontp != string) {
        while (*frontp) {
            *endp++ = *frontp++;
        }
        *endp = '\0';
    }

    return string;
}
#endif
#line 20 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_utilities.c"

/***********************************************************************************************************/

/**
 * @brief Initializes the logging level to IOHprofiler_INFO.
 */
static IOHprofiler_log_level_type_e IOHprofiler_log_level = IOHprofiler_INFO;

/**
 * @param log_level Denotes the level of information given to the user through the standard output and
 * error streams. Can take on the values:
 * - "error" (only error messages are output),
 * - "warning" (only error and warning messages are output),
 * - "info" (only error, warning and info messages are output) and
 * - "debug" (all messages are output).
 * - "" does not set a new value
 * The default value is info.
 *
 * @return The previous IOHprofiler_log_level value as an immutable string.
 */
const char *IOHprofiler_set_log_level(const char *log_level) {
    IOHprofiler_log_level_type_e previous_log_level = IOHprofiler_log_level;

    if (strcmp(log_level, "error") == 0)
        IOHprofiler_log_level = IOHprofiler_ERROR;
    else if (strcmp(log_level, "warning") == 0)
        IOHprofiler_log_level = IOHprofiler_WARNING;
    else if (strcmp(log_level, "info") == 0)
        IOHprofiler_log_level = IOHprofiler_INFO;
    else if (strcmp(log_level, "debug") == 0)
        IOHprofiler_log_level = IOHprofiler_DEBUG;
    else if (strcmp(log_level, "") == 0) {
        /* Do nothing */
    } else {
        IOHprofiler_warning("IOHprofiler_set_log_level(): unknown level %s", log_level);
    }

    if (previous_log_level == IOHprofiler_ERROR)
        return "error";
    else if (previous_log_level == IOHprofiler_WARNING)
        return "warning";
    else if (previous_log_level == IOHprofiler_INFO)
        return "info";
    else if (previous_log_level == IOHprofiler_DEBUG)
        return "debug";
    else {
        IOHprofiler_error("IOHprofiler_set_log_level(): unknown previous log level");
        return "";
    }
}

/***********************************************************************************************************/

/**
 * @name Methods regarding file, directory and path manipulations
 */
/**@{*/
/**
 * @brief Creates a platform-dependent path from the given strings.
 *
 * @note The last argument must be NULL.
 * @note The first parameter must be able to accommodate path_max_length characters and the length
 * of the joined path must not exceed path_max_length characters.
 * @note Should work cross-platform.
 *
 * Usage examples:
 * - IOHprofiler_join_path(base_path, 100, folder1, folder2, folder3, NULL) creates base_path/folder1/folder2/folder3
 * - IOHprofiler_join_path(base_path, 100, folder1, file_name, NULL) creates base_path/folder1/file_name
 * @param path The base path; it's also where the joined path is stored to.
 * @param path_max_length The maximum length of the path.
 * @param ... Additional strings, must end with NULL
 */
static void IOHprofiler_join_path(char *path, const size_t path_max_length, ...) {
    const size_t path_separator_length = strlen(IOHprofiler_path_separator);
    va_list args;
    char *path_component;
    size_t path_length = strlen(path);

    va_start(args, path_max_length);
    while (NULL != (path_component = va_arg(args, char *))) {
        size_t component_length = strlen(path_component);
        if (path_length + path_separator_length + component_length >= path_max_length) {
            IOHprofiler_error("IOHprofiler_join_path() failed because the ${path} is too short.");
            return; /* never reached */
        }
        /* Both should be safe because of the above check. */
        if (strlen(path) > 0)
            strncat(path, IOHprofiler_path_separator, path_max_length - strlen(path) - 1);
        strncat(path, path_component, path_max_length - strlen(path) - 1);
    }
    va_end(args);
}

/**
 * @brief Checks if the given directory exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a directory and 0 otherwise.
 */
static int IOHprofiler_directory_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Checks if the given file exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a file and 0 otherwise.
 */
static int IOHprofiler_file_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES) && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && !S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Calls the right mkdir() method (depending on the platform).
 *
 * @param path The directory path.
 *
 * @return 0 on successful completion, and -1 on error.
 */
static int IOHprofiler_mkdir(const char *path) {
#if _MSC_VER
    return _mkdir(path);
#elif defined(__MINGW32__) || defined(__MINGW64__)
    return mkdir(path);
#else
    return mkdir(path, S_IRWXU);
#endif
}

/**
 * @brief Creates a directory with full privileges for the user.
 *
 * @note Should work cross-platform.
 *
 * @param path The directory path.
 */
static void IOHprofiler_create_directory(const char *path) {
    char *tmp = NULL;
    char *p;
    size_t len = strlen(path);
    char path_sep = IOHprofiler_path_separator[0];

    /* Nothing to do if the path exists. */
    if (IOHprofiler_directory_exists(path))
        return;

    tmp = IOHprofiler_strdup(path);
    /* Remove possible trailing slash */
    if (tmp[len - 1] == path_sep)
        tmp[len - 1] = 0;
    for (p = tmp + 1; *p; p++) {
        if (*p == path_sep) {
            *p = 0;
            if (!IOHprofiler_directory_exists(tmp)) {
                if (0 != IOHprofiler_mkdir(tmp))
                    IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
            }
            *p = path_sep;
        }
    }
    if (0 != IOHprofiler_mkdir(tmp))
        IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
    IOHprofiler_free_memory(tmp);
    return;
}

/* Commented to silence the compiler (unused function warning) */
#if 0

#endif

/**
 * @brief Creates a unique directory from the given path.
 *
 * If the given path does not yet exit, it is left as is, otherwise it is changed(!) by appending a number
 * to it. If path already exists, path-01 will be tried. If this one exists as well, path-02 will be tried,
 * and so on. If path-99 exists as well, the function throws an error.
 */
static void IOHprofiler_create_unique_directory(char **path) {
    int counter = 1;
    char *new_path;

    /* Create the path if it does not yet exist */
    if (!IOHprofiler_directory_exists(*path)) {
        IOHprofiler_create_directory(*path);
        return;
    }

    while (counter < 999) {
        new_path = IOHprofiler_strdupf("%s-%03d", *path, counter);

        if (!IOHprofiler_directory_exists(new_path)) {
            IOHprofiler_free_memory(*path);
            *path = new_path;
            IOHprofiler_create_directory(*path);
            return;
        } else {
            counter++;
            IOHprofiler_free_memory(new_path);
        }
    }

    IOHprofiler_error("IOHprofiler_create_unique_path(): could not create a unique path with name %s", *path);
    return; /* Never reached */
}

/**
 * The method should work across different platforms/compilers.
 *
 * @path The path to the directory
 *
 * @return 0 on successful completion, and -1 on error.
 */
int IOHprofiler_remove_directory(const char *path) {
#if _MSC_VER
    WIN32_FIND_DATA find_data_file;
    HANDLE find_handle = NULL;
    char *buf;
    int r = -1;
    int r2 = -1;

    buf = IOHprofiler_strdupf("%s\\*.*", path);
    /* Nothing to do if the folder does not exist */
    if ((find_handle = FindFirstFile(buf, &find_data_file)) == INVALID_HANDLE_VALUE) {
        IOHprofiler_free_memory(buf);
        return 0;
    }
    IOHprofiler_free_memory(buf);

    do {
        r = 0;

        /* Skip the names "." and ".." as we don't want to recurse on them */
        if (strcmp(find_data_file.cFileName, ".") != 0 && strcmp(find_data_file.cFileName, "..") != 0) {
            /* Build the new path using the argument path the file/folder name we just found */
            buf = IOHprofiler_strdupf("%s\\%s", path, find_data_file.cFileName);

            if (find_data_file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                /* Buf is a directory, recurse on it */
                r2 = IOHprofiler_remove_directory(buf);
            } else {
                /* Buf is a file, delete it */
                /* Careful, DeleteFile returns 0 if it fails and nonzero otherwise! */
                r2 = -(DeleteFile(buf) == 0);
            }

            IOHprofiler_free_memory(buf);
        }

        r = r2;

    } while (FindNextFile(find_handle, &find_data_file)); /* Find the next file */

    FindClose(find_handle);

    if (!r) {
        /* Path is an empty directory, delete it */
        /* Careful, RemoveDirectory returns 0 if it fails and nonzero otherwise! */
        r = -(RemoveDirectory(path) == 0);
    }

    return r;
#else
    DIR *d = opendir(path);
    int r = -1;
    int r2 = -1;
    char *buf;

    /* Nothing to do if the folder does not exist */
    if (!IOHprofiler_directory_exists(path))
        return 0;

    if (d) {
        struct dirent *p;

        r = 0;

        while (!r && (p = readdir(d))) {
            /* Skip the names "." and ".." as we don't want to recurse on them */
            if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, "..")) {
                continue;
            }

            buf = IOHprofiler_strdupf("%s/%s", path, p->d_name);
            if (buf) {
                if (IOHprofiler_directory_exists(buf)) {
                    /* Buf is a directory, recurse on it */
                    r2 = IOHprofiler_remove_directory(buf);
                } else {
                    /* Buf is a file, delete it */
                    r2 = unlink(buf);
                }
            }
            IOHprofiler_free_memory(buf);

            r = r2;
        }

        closedir(d);
    }

    if (!r) {
        /* Path is an empty directory, delete it */
        r = rmdir(path);
    }

    return r;
#endif
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding memory allocations
 */
/**@{*/
double *IOHprofiler_allocate_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(double);
    return (double *)IOHprofiler_allocate_memory(block_size);
}

int *IOHprofiler_allocate_int_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(int);
    return (int *)IOHprofiler_allocate_memory(block_size);
}
/**
 * @brief Allocates memory for a vector and sets all its elements to value.
 */
static double *IOHprofiler_allocate_vector_with_value(const size_t number_of_elements, double value) {
    const size_t block_size = number_of_elements * sizeof(double);
    double *vector = (double *)IOHprofiler_allocate_memory(block_size);
    size_t i;

    for (i = 0; i < number_of_elements; i++)
        vector[i] = value;

    return vector;
}

/**
 * @brief Safe memory allocation for a vector with size_t elements that either succeeds or triggers a
 * IOHprofiler_error.
 */
static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(size_t);
    return (size_t *)IOHprofiler_allocate_memory(block_size);
}

static char *IOHprofiler_allocate_string(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(char);
    return (char *)IOHprofiler_allocate_memory(block_size);
}

static double *IOHprofiler_duplicate_vector(const double *src, const size_t number_of_elements) {
    size_t i;
    double *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}

static int *IOHprofiler_duplicate_int_vector(const int *src, const size_t number_of_elements) {
    size_t i;
    int *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_int_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding string options
 */
/**@{*/

/**
 * @brief Allocates an option keys structure holding the given number of option keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_allocate(const size_t count, const char **keys) {
    size_t i;
    IOHprofiler_option_keys_t *option_keys;

    if ((count == 0) || (keys == NULL))
        return NULL;

    option_keys = (IOHprofiler_option_keys_t *)IOHprofiler_allocate_memory(sizeof(*option_keys));

    option_keys->keys = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));
    for (i = 0; i < count; i++) {
        assert(keys[i]);
        option_keys->keys[i] = IOHprofiler_strdup(keys[i]);
    }
    option_keys->count = count;

    return option_keys;
}

/**
 * @brief Frees the given option keys structure.
 */
static void IOHprofiler_option_keys_free(IOHprofiler_option_keys_t *option_keys) {
    size_t i;

    if (option_keys) {
        for (i = 0; i < option_keys->count; i++) {
            IOHprofiler_free_memory(option_keys->keys[i]);
        }
        IOHprofiler_free_memory(option_keys->keys);
        IOHprofiler_free_memory(option_keys);
    }
}

/**
 * @brief Returns redundant option keys (the ones present in given_option_keys but not in known_option_keys).
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_get_redundant(const IOHprofiler_option_keys_t *known_option_keys,
                                                                        const IOHprofiler_option_keys_t *given_option_keys) {
    size_t i, j, count = 0;
    int found;
    char **redundant_keys;
    IOHprofiler_option_keys_t *redundant_option_keys;

    assert(known_option_keys != NULL);
    assert(given_option_keys != NULL);

    /* Find the redundant keys */
    redundant_keys = (char **)IOHprofiler_allocate_memory(given_option_keys->count * sizeof(char *));
    for (i = 0; i < given_option_keys->count; i++) {
        found = 0;
        for (j = 0; j < known_option_keys->count; j++) {
            if (strcmp(given_option_keys->keys[i], known_option_keys->keys[j]) == 0) {
                found = 1;
                break;
            }
        }
        if (!found) {
            redundant_keys[count++] = IOHprofiler_strdup(given_option_keys->keys[i]);
        }
    }
    redundant_option_keys = IOHprofiler_option_keys_allocate(count, (const char **)redundant_keys);

    /* Free memory */
    for (i = 0; i < count; i++) {
        IOHprofiler_free_memory(redundant_keys[i]);
    }
    IOHprofiler_free_memory(redundant_keys);

    return redundant_option_keys;
}

/**
 * @brief Adds additional option keys to the given basic option keys (changes the basic keys).
 */
static void IOHprofiler_option_keys_add(IOHprofiler_option_keys_t **basic_option_keys,
                                        const IOHprofiler_option_keys_t *additional_option_keys) {
    size_t i, j;
    size_t new_count;
    char **new_keys;
    IOHprofiler_option_keys_t *new_option_keys;

    assert(*basic_option_keys != NULL);
    if (additional_option_keys == NULL)
        return;

    /* Construct the union of both keys */
    new_count = (*basic_option_keys)->count + additional_option_keys->count;
    new_keys = (char **)IOHprofiler_allocate_memory(new_count * sizeof(char *));
    for (i = 0; i < (*basic_option_keys)->count; i++) {
        new_keys[i] = IOHprofiler_strdup((*basic_option_keys)->keys[i]);
    }
    for (j = 0; j < additional_option_keys->count; j++) {
        new_keys[(*basic_option_keys)->count + j] = IOHprofiler_strdup(additional_option_keys->keys[j]);
    }
    new_option_keys = IOHprofiler_option_keys_allocate(new_count, (const char **)new_keys);

    /* Free the old basic keys */
    IOHprofiler_option_keys_free(*basic_option_keys);
    *basic_option_keys = new_option_keys;
    for (i = 0; i < new_count; i++) {
        IOHprofiler_free_memory(new_keys[i]);
    }
    IOHprofiler_free_memory(new_keys);
}

/**
 * @brief Creates an instance of option keys from the given string of options containing keys and values
 * separated by colons.
 *
 * @note Relies heavily on the "key: value" format and might fail if the number of colons doesn't match the
 * number of keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys(const char *option_string) {
    size_t i;
    char **keys;
    IOHprofiler_option_keys_t *option_keys = NULL;
    char *string_to_parse, *key;

    /* Check for empty string */
    if ((option_string == NULL) || (strlen(option_string) == 0)) {
        return NULL;
    }

    /* Split the options w.r.t ':' */
    keys = IOHprofiler_string_split(option_string, ':');

    if (keys) {
        /* Keys now contain something like this: "values_of_previous_key this_key" except for the first, which
     * contains only the key and the last, which contains only the previous values */
        for (i = 0; *(keys + i); i++) {
            string_to_parse = IOHprofiler_strdup(*(keys + i));

            /* Remove any leading and trailing spaces */
            string_to_parse = IOHprofiler_string_trim(string_to_parse);

            /* Stop if this is the last substring (contains a value and no key) */
            if ((i > 0) && (*(keys + i + 1) == NULL)) {
                IOHprofiler_free_memory(string_to_parse);
                break;
            }

            /* Disregard everything before the last space */
            key = strrchr(string_to_parse, ' ');
            if ((key == NULL) || (i == 0)) {
                /* No spaces left (or this is the first key), everything is the key */
                key = string_to_parse;
            } else {
                /* Move to the start of the key (one char after the space) */
                key++;
            }

            /* Put the key in keys */
            IOHprofiler_free_memory(*(keys + i));
            *(keys + i) = IOHprofiler_strdup(key);
            IOHprofiler_free_memory(string_to_parse);
        }

        option_keys = IOHprofiler_option_keys_allocate(i, (const char **)keys);

        /* Free the keys */
        for (i = 0; *(keys + i); i++) {
            IOHprofiler_free_memory(*(keys + i));
        }
        IOHprofiler_free_memory(keys);
    }

    return option_keys;
}

/**
 * @brief Creates and returns a string containing the info_string and all keys from option_keys.
 *
 * Can be used to output information about the given option_keys.
 */
static char *IOHprofiler_option_keys_get_output_string(const IOHprofiler_option_keys_t *option_keys,
                                                       const char *info_string) {
    size_t i;
    char *string = NULL, *new_string;

    if ((option_keys != NULL) && (option_keys->count > 0)) {
        string = IOHprofiler_strdup(info_string);
        for (i = 0; i < option_keys->count; i++) {
            new_string = IOHprofiler_strdupf("%s %s\n", string, option_keys->keys[i]);
            IOHprofiler_free_memory(string);
            string = new_string;
        }
    }

    return string;
}

/**
 * @brief Parses options in the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - value needs to be a single string (no spaces allowed)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read(const char *options, const char *name, const char *format, void *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing whitespaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    return sscanf(&options[i2], format, pointer);
}

/**
 * @brief Reads an integer from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be an integer
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_int(const char *options, const char *name, int *pointer) {
    return IOHprofiler_options_read(options, name, " %i", pointer);
}

/**
 * @brief Reads a size_t from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a size_t
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_size_t(const char *options, const char *name, size_t *pointer) {
    return IOHprofiler_options_read(options, name, "%lu", pointer);
}

/**
 * @brief Reads a double value from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a double
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_double(const char *options, const char *name, double *pointer) {
    return IOHprofiler_options_read(options, name, "%lf", pointer);
}

/**
 * @brief Reads a string from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a string - either a single word or multiple words
 * in double quotes
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_string(const char *options, const char *name, char *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    if (options[i2] == '\"') {
        /* The value starts with a quote: read everything between two quotes into a string */
        return sscanf(&options[i2], "\"%[^\"]\"", pointer);
    } else
        return sscanf(&options[i2], "%s", pointer);
}

/**
 * @brief Reads (possibly delimited) values from options using the form "name1: value1,value2,value3 name2: value4",
 * i.e. reads all characters from the corresponding name up to the next whitespace or end of string.
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_values(const char *options, const char *name, char *pointer) {
    long i1, i2;
    int i;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    i = 0;
    while (!isspace((unsigned char)options[i2 + i]) && (options[i2 + i] != '\0')) {
        pointer[i] = options[i2 + i];
        i++;
    }
    pointer[i] = '\0';
    return i;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods implementing functions on double values not contained in C89 standard
 */
/**@{*/

/**
 * @brief Rounds the given double to the nearest integer.
 */
static double IOHprofiler_double_round(const double number) {
    return floor(number + 0.5);
}

/**
 * @brief Returns the maximum of a and b.
 */
static double IOHprofiler_double_max(const double a, const double b) {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Returns the minimum of a and b.
 */
static double IOHprofiler_double_min(const double a, const double b) {
    if (a <= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Performs a "safer" double to size_t conversion.
 */
static size_t IOHprofiler_double_to_size_t(const double number) {
    return (size_t)IOHprofiler_double_round(number);
}

/**
 * @brief  Returns 1 if |a - b| < precision and 0 otherwise.
 */
static int IOHprofiler_double_almost_equal(const double a, const double b, const double precision) {
    return (fabs(a - b) < precision);
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods handling NAN and INFINITY
 */
/**@{*/

/**
 * @brief Returns 1 if x is NAN and 0 otherwise.
 */
static int IOHprofiler_is_nan(const int x) {
    /*return (isnan(x) || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
*/
    return (0 || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
}

/**
 * @brief Returns 1 if the input vector of dimension dim contains any NAN values and 0 otherwise.
 */
static int IOHprofiler_vector_contains_nan(const int *x, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        if (IOHprofiler_is_nan(x[i]))
            return 1;
    }
    return 0;
}

/**
 * @brief Sets all dim values of y to NAN.
 */
static void IOHprofiler_vector_set_to_nan(double *y, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        y[i] = NAN;
    }
}

/**
 * @brief Returns 1 if x is INFINITY and 0 otherwise.
 */
static int IOHprofiler_is_inf(const int x) {
    if (IOHprofiler_is_nan(x))
        return 0;
    /*return (isinf(x) || (x <= -INFINITY) || (x >= INFINITY));*/
    return (0 || (x <= -INFINITY) || (x >= INFINITY));
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Miscellaneous methods
 */
/**@{*/

/**
 * @brief Returns the current time as a string.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_current_time_get_string(void) {
    time_t timer;
    char *time_string = IOHprofiler_allocate_string(30);
    struct tm *tm_info;
    time(&timer);
    tm_info = localtime(&timer);
    assert(tm_info != NULL);
    strftime(time_string, 30, "%d.%m.%y %H:%M:%S", tm_info);
    return time_string;
}

/**
 * @brief Returns the number of positive numbers pointed to by numbers (the count stops when the first
 * 0 is encountered of max_count numbers have been read).
 *
 * If there are more than max_count numbers, a IOHprofiler_error is raised. The name argument is used
 * only to provide more informative output in case of any problems.
 */
static size_t IOHprofiler_count_numbers(const size_t *numbers, const size_t max_count, const char *name) {
    size_t count = 0;
    while ((count < max_count) && (numbers[count] != 0)) {
        count++;
    }
    if (count == max_count) {
        IOHprofiler_error("IOHprofiler_count_numbers(): over %lu numbers in %s", (unsigned long)max_count, name);
        return 0; /* Never reached*/
    }

    return count;
}

/**@}*/

/***********************************************************************************************************/
#endif
#line 13 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/../profiler/IOHprofiler_problem.c"

/**
 * Evaluates the problem function, increases the number of evaluations and updates the best observed value
 * and the best observed evaluation number.
 *
 * @note Both x and y must point to correctly sized allocated memory regions.
 *
 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 * @param y The objective vector that is the result of the evaluation (in single-objective problems only the
 * first vector item is being set). Currently multi-objective is not supported.
 * @param number_of_parameters The number of parameters need to be logged. Set as zero by default.
 * @param parameters The list of parameters. Set as NULL by default.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {

    assert(problem != NULL);
    assert(problem->evaluate_function != NULL);
    problem->evaluate_function(problem, x, y);
    problem->evaluations++; /* each derived class has its own counter, only the most outer will be visible */

    /* A little bit of bookkeeping */
    if (y[0] > problem->best_observed_fvalue[0]) {
        problem->best_observed_fvalue[0] = y[0];
        problem->best_observed_evaluation[0] = problem->evaluations;
    }
}

/**
 * Evaluates and logs the given solution (as the IOHprofiler_evaluate_function), but does not return the evaluated
 * value.
 *
 * @note None of the observers implements this function yet!
 * @note x must point to a correctly sized allocated memory region.

 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    assert(problem != NULL);
    if (problem->recommend_solution == NULL) {
        IOHprofiler_error("IOHprofiler_recommend_solutions(): No recommend solution function implemented for problem %s",
                          problem->problem_id);
    }
    problem->recommend_solution(problem, x);
}

/**
 * @brief Allocates a new IOHprofiler_problem_t for the given number of variables and number of objectives.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate(const size_t number_of_variables,
                                                           const size_t number_of_objectives) {
    IOHprofiler_problem_t *problem;
    problem = (IOHprofiler_problem_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    /* Initialize fields to sane/safe defaults */
    problem->initial_solution = NULL;
    problem->evaluate_function = NULL;
    problem->recommend_solution = NULL;
    problem->problem_free_function = NULL;
    problem->dimension = number_of_variables;
    problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = number_of_objectives;
    problem->number_of_parameters = 0;
    problem->parameters = NULL;
    problem->smallest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->largest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_parameter = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_value = IOHprofiler_allocate_vector(number_of_objectives);
    problem->raw_fitness = IOHprofiler_allocate_vector(number_of_objectives);
    if (number_of_objectives > 1)
        problem->nadir_value = IOHprofiler_allocate_vector(number_of_objectives);
    else
        problem->nadir_value = NULL;
    problem->problem_name = NULL;
    problem->problem_id = NULL;
    problem->problem_type = NULL;
    problem->evaluations = 0;
    problem->final_target_delta[0] = 1e-8; /* in case to be modified by the benchmark */
    problem->best_observed_fvalue[0] = DBL_MIN_EXP;
    problem->best_observed_evaluation[0] = 0;
    problem->suite = NULL; /* To be initialized in the IOHprofiler_suite_get_problem_from_indices() function */
    problem->suite_dep_index = 0;
    problem->suite_dep_function = 0;
    problem->suite_dep_instance = 0;
    problem->data = NULL;
    return problem;
}

/**
 * @brief Creates a duplicate of the 'other' problem for all fields except for data, which points to NULL.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_duplicate(const IOHprofiler_problem_t *other) {
    size_t i;
    IOHprofiler_problem_t *problem;
    problem = IOHprofiler_problem_allocate(other->number_of_variables, other->number_of_objectives);

    problem->dimension = other->dimension;
    problem->initial_solution = other->initial_solution;
    problem->evaluate_function = other->evaluate_function;
    problem->recommend_solution = other->recommend_solution;
    problem->problem_free_function = other->problem_free_function;

    for (i = 0; i < problem->number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = other->smallest_values_of_interest[i];
        problem->largest_values_of_interest[i] = other->largest_values_of_interest[i];
        if (other->best_parameter)
            problem->best_parameter[i] = other->best_parameter[i];
    }

    if (other->best_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->best_value[i] = other->best_value[i];
        }

    if (other->nadir_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->nadir_value[i] = other->nadir_value[i];
        }

    if (other->raw_fitness)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->raw_fitness[i] = other->raw_fitness[i];
        }

    problem->number_of_parameters = other->number_of_parameters;
    for (i = 0; i < problem->number_of_parameters; ++i) {
        problem->parameters[i] = other->parameters[i];
    }

    problem->problem_name = IOHprofiler_strdup(other->problem_name);
    problem->problem_id = IOHprofiler_strdup(other->problem_id);
    problem->problem_type = IOHprofiler_strdup(other->problem_type);

    problem->evaluations = other->evaluations;
    problem->final_target_delta[0] = other->final_target_delta[0];
    problem->best_observed_fvalue[0] = other->best_observed_fvalue[0];
    problem->best_observed_evaluation[0] = other->best_observed_evaluation[0];

    problem->suite = other->suite;
    problem->suite_dep_index = other->suite_dep_index;
    problem->suite_dep_function = other->suite_dep_function;
    problem->suite_dep_instance = other->suite_dep_instance;

    problem->data = NULL;

    return problem;
}

/**
 * @brief Allocates a problem using scalar values for smallest_value_of_interest, largest_value_of_interest
 * and best_parameter.
 * Note that the number of objectives is set as 1 by default.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate_from_scalars(const char *problem_name,
                                                                        IOHprofiler_evaluate_function_t evaluate_function,
                                                                        IOHprofiler_problem_free_function_t problem_free_function,
                                                                        const size_t number_of_variables,
                                                                        const int smallest_value_of_interest,
                                                                        const int largest_value_of_interest,
                                                                        const int best_parameter) {
    size_t i;

    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate(number_of_variables, 1);

    problem->problem_name = IOHprofiler_strdup(problem_name);
    /*problem->dimension = number_of_variables;
    */problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = 1;
    problem->evaluate_function = evaluate_function;
    problem->problem_free_function = problem_free_function;

    for (i = 0; i < number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = smallest_value_of_interest;
        problem->largest_values_of_interest[i] = largest_value_of_interest;
        problem->best_parameter[i] = best_parameter;
    }
    return problem;
}

void IOHprofiler_problem_free(IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (problem->problem_free_function != NULL) {
        problem->problem_free_function(problem);
    } else {
        /* Best guess at freeing all relevant structures */
        if (problem->smallest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->smallest_values_of_interest);
        if (problem->largest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->largest_values_of_interest);
        if (problem->best_parameter != NULL)
            IOHprofiler_free_memory(problem->best_parameter);
        if (problem->best_value != NULL)
            IOHprofiler_free_memory(problem->best_value);
        if (problem->raw_fitness != NULL)
            IOHprofiler_free_memory(problem->raw_fitness);
        if (problem->nadir_value != NULL)
            IOHprofiler_free_memory(problem->nadir_value);
        if (problem->problem_name != NULL)
            IOHprofiler_free_memory(problem->problem_name);
        if (problem->problem_id != NULL)
            IOHprofiler_free_memory(problem->problem_id);
        if (problem->problem_type != NULL)
            IOHprofiler_free_memory(problem->problem_type);
        if (problem->data != NULL)
            IOHprofiler_free_memory(problem->data);
        if (problem->parameters != NULL)
            IOHprofiler_free_memory(problem->parameters);
        problem->smallest_values_of_interest = NULL;
        problem->largest_values_of_interest = NULL;
        problem->best_parameter = NULL;
        problem->best_value = NULL;
        problem->raw_fitness = NULL;
        problem->nadir_value = NULL;
        problem->suite = NULL;
        problem->data = NULL;
        problem->parameters = NULL;
        IOHprofiler_free_memory(problem);
    }
}

/**
 * @brief Checks whether the given string is in the right format to be a problem_id.
 *
 * No non-alphanumeric characters besides '-', '_' and '.' are allowed.
 */
static int IOHprofiler_problem_id_is_fine(const char *id, ...) {
    va_list args;
    const int reject = 0;
    const int accept = 1;
    const char *cp;
    char *s;
    int result = accept;

    va_start(args, id);
    s = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    for (cp = s; *cp != '\0'; ++cp) {
        if (('A' <= *cp) && (*cp <= 'Z'))
            continue;
        if (('a' <= *cp) && (*cp <= 'z'))
            continue;
        if ((*cp == '_') || (*cp == '-'))
            continue;
        if (('0' <= *cp) && (*cp <= '9'))
            continue;
        result = reject;
    }
    IOHprofiler_free_memory(s);
    return result;
}

/**
 * @brief Sets the problem_parameters.
 *
 */
void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters) {
    size_t i;
    if (number_of_parameters != 0) {
        problem->number_of_parameters = number_of_parameters;
        if (problem->parameters != NULL) {
            IOHprofiler_free_memory(problem->parameters);
        }
        problem->parameters = IOHprofiler_allocate_vector(number_of_parameters);
        for (i = 0; i < problem->number_of_parameters; ++i) {
            problem->parameters[i] = parameters[i];
        }
    }
}

/**
 * @brief Sets the problem_id using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation and verifies that the problem_id is in the correct format.
 */
static void IOHprofiler_problem_set_id(IOHprofiler_problem_t *problem, const char *id, ...) {
    va_list args;

    va_start(args, id);
    if (problem->problem_id != NULL)
        IOHprofiler_free_memory(problem->problem_id);
    problem->problem_id = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    if (!IOHprofiler_problem_id_is_fine(problem->problem_id)) {
        IOHprofiler_error("Problem id should only contain standard chars, not like '%s'", problem->problem_id);
    }
}

/**
 * @brief Sets the problem_name using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_name(IOHprofiler_problem_t *problem, const char *name, ...) {
    va_list args;

    va_start(args, name);
    if (problem->problem_name != NULL)
        IOHprofiler_free_memory(problem->problem_name);
    problem->problem_name = IOHprofiler_vstrdupf(name, args);
    va_end(args);
}

/**
 * @brief Sets the problem_type using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_type(IOHprofiler_problem_t *problem, const char *type, ...) {
    va_list args;

    va_start(args, type);
    if (problem->problem_type != NULL)
        IOHprofiler_free_memory(problem->problem_type);
    problem->problem_type = IOHprofiler_vstrdupf(type, args);
    va_end(args);
}

size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->evaluations;
}

/**
 * @brief Returns 1 if the best parameter is not (close to) zero and 0 otherwise.
 */
static int IOHprofiler_problem_best_parameter_not_zero(const IOHprofiler_problem_t *problem) {
    size_t i = 0;
    int best_is_zero = 1;

    if (IOHprofiler_vector_contains_nan(problem->best_parameter, problem->number_of_variables))
        return 1;

    while (i < problem->number_of_variables && best_is_zero) {
        best_is_zero = IOHprofiler_double_almost_equal(problem->best_parameter[i], 0, 1e-9);
        i++;
    }

    return !best_is_zero;
}

/**
 * @note Can be used to prevent unnecessary burning of CPU time.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (IOHprofiler_problem_get_number_of_objectives(problem) != 1 ||
        IOHprofiler_problem_get_evaluations(problem) < 1)
        return 0;
    if (problem->best_value == NULL)
        return 0;
    return problem->best_observed_fvalue[0] >= problem->best_value[0] - problem->final_target_delta[0] ? 1 : 0;
}

/**
 * @note Tentative...
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->best_observed_fvalue[0];
}

/**
 * @note This function breaks the black-box property: the returned  value is not
 * meant to be used by the optimization algorithm.
 */
double IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->best_value != NULL);
    assert(problem->final_target_delta != NULL);
    return problem->best_value[0] + problem->final_target_delta[0];
}

/**
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_name != NULL);
    return problem->problem_name;
}

/**
 * The ID is guaranteed to contain only characters in the set [a-z0-9_-]. It should therefore be safe to use
 * it to construct filenames or other identifiers.
 *
 * Each problem ID should be unique within each benchmark suite.
 *
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_id != NULL);
    return problem->problem_id;
}

const char *IOHprofiler_problem_get_type(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_type != NULL);
    return problem->problem_type;
}

size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->dimension > 0);
    return problem->dimension;
}

size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->number_of_objectives > 0);
    return problem->number_of_objectives;
}
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->smallest_values_of_interest != NULL);
    return problem->smallest_values_of_interest;
}

const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->largest_values_of_interest != NULL);
    return problem->largest_values_of_interest;
}

/**
 * If a special method for setting an initial solution to the problem does not exist, the center of the
 * problem's region of interest is the initial solution.
 * @param problem The given IOHprofiler problem.
 * @param initial_solution The pointer to the initial solution being set by this method.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution) {
    assert(problem != NULL);
    if (problem->initial_solution != NULL) {
        problem->initial_solution(problem, initial_solution);
    } else {
        size_t i;
        assert(problem->smallest_values_of_interest != NULL);
        assert(problem->largest_values_of_interest != NULL);
        for (i = 0; i < problem->number_of_variables; ++i)
            initial_solution[i] = (int)(problem->smallest_values_of_interest[i] + 0.5 * (problem->largest_values_of_interest[i] - problem->smallest_values_of_interest[i]));
    }
}

static IOHprofiler_suite_t *IOHprofiler_problem_get_suite(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite;
}

static void IOHprofiler_problem_set_suite(IOHprofiler_problem_t *problem, IOHprofiler_suite_t *suite) {
    assert(problem != NULL);
    problem->suite = suite;
}

size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite_dep_index;
}

static size_t IOHprofiler_problem_get_suite_dep_function(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_function > 0);
    return problem->suite_dep_function;
}

static size_t IOHprofiler_problem_get_suite_dep_instance(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_instance > 0);
    return problem->suite_dep_instance;
}

/**
 * @brief Returns the data of the transformed problem.
 */
static void *IOHprofiler_problem_transformed_get_data(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->data != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->data;
}

/**
 * @brief Returns the inner problem of the transformed problem.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_get_inner_problem(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the inner problem.
 */
static void IOHprofiler_problem_transformed_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_evaluate_function(data->inner_problem, x, y);
}

/**
 * @brief Calls the IOHprofiler_recommend_solution function on the inner problem.
 */
static void IOHprofiler_problem_transformed_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_recommend_solution(data->inner_problem, x);
}

/**
 * @brief Frees only the data of the transformed problem leaving the inner problem intact.
 *
 * @note If there is no other pointer to the inner problem, access to it will be lost.
 */
static void IOHprofiler_problem_transformed_free_data(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;

    if (data->data != NULL) {
        if (data->data_free_function != NULL) {
            data->data_free_function(data->data);
            data->data_free_function = NULL;
        }
        IOHprofiler_free_memory(data->data);
        data->data = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}

/**
 * @brief Frees the transformed problem.
 */
static void IOHprofiler_problem_transformed_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);
    if (data->inner_problem != NULL) {
        IOHprofiler_problem_free(data->inner_problem);
        data->inner_problem = NULL;
    }
    IOHprofiler_problem_transformed_free_data(problem);
}

/**
 * @brief Allocates a transformed problem that wraps the inner_problem.
 *
 * By default all methods will dispatch to the inner_problem. A prefix is prepended to the problem name
 * in order to reflect the transformation somewhere.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_allocate(IOHprofiler_problem_t *inner_problem,
                                                                       void *user_data,
                                                                       IOHprofiler_data_free_function_t data_free_function,
                                                                       const char *name_prefix) {
    IOHprofiler_problem_transformed_data_t *problem;
    IOHprofiler_problem_t *inner_copy;
    char *old_name = IOHprofiler_strdup(inner_problem->problem_name);

    problem = (IOHprofiler_problem_transformed_data_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    problem->inner_problem = inner_problem;
    problem->data = user_data;
    problem->data_free_function = data_free_function;

    inner_copy = IOHprofiler_problem_duplicate(inner_problem);
    inner_copy->evaluate_function = IOHprofiler_problem_transformed_evaluate_function;
    inner_copy->recommend_solution = IOHprofiler_problem_transformed_recommend_solution;
    inner_copy->problem_free_function = IOHprofiler_problem_transformed_free;
    inner_copy->data = problem;

    IOHprofiler_problem_set_name(inner_copy, "%s(%s)", name_prefix, old_name);
    IOHprofiler_free_memory(old_name);

    return inner_copy;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the underlying problems.
 */
static void IOHprofiler_problem_stacked_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_stacked_data_t *data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    assert(
        IOHprofiler_problem_get_number_of_objectives(problem) == IOHprofiler_problem_get_number_of_objectives(data->problem1) + IOHprofiler_problem_get_number_of_objectives(data->problem2));

    IOHprofiler_evaluate_function(data->problem1, x, &y[0]);
    IOHprofiler_evaluate_function(data->problem2, x, &y[IOHprofiler_problem_get_number_of_objectives(data->problem1)]);
}

/**
 * @brief Frees the stacked problem.
 */
static void IOHprofiler_problem_stacked_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_stacked_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    if (data->problem1 != NULL) {
        IOHprofiler_problem_free(data->problem1);
        data->problem1 = NULL;
    }
    if (data->problem2 != NULL) {
        IOHprofiler_problem_free(data->problem2);
        data->problem2 = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}
#endif
#line 12 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_obj_scale.c"

/**
 * @brief Data type for transform_obj_scale.
 */
typedef struct {
  double offset;
} transform_obj_scale_data_t;

/**
 * @brief Evaluates the transformation.
 */
static void transform_obj_scale_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  transform_obj_scale_data_t *data;
  size_t i;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }
  data = (transform_obj_scale_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  IOHprofiler_evaluate_function(IOHprofiler_problem_transformed_get_inner_problem(problem), x, y);
  
  for (i = 0; i < problem->number_of_objectives; i++) {
      y[i] = y[i] * data->offset;
      problem->raw_fitness[i] = IOHprofiler_problem_transformed_get_inner_problem(problem)->raw_fitness[i];
  }
  assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_obj_scale(IOHprofiler_problem_t *inner_problem, const double offset) {
  IOHprofiler_problem_t *problem;
  transform_obj_scale_data_t *data;
  size_t i;
  data = (transform_obj_scale_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = offset;

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, NULL, "transform_obj_scale");
  problem->evaluate_function = transform_obj_scale_evaluate;
  for (i = 0; i < problem->number_of_objectives; i++) {
      problem->best_value[0] = problem->best_value[0] * offset;
  }
  return problem;
}
#endif
#line 20 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_obj_shift.c"
/**
 * @file transform_obj_shift.c
 * @brief Implementation of shifting the objective value by the given offset.
 */
#ifndef TRANSFORM_OBJ_SHIFT
#define TRANSFORM_OBJ_SHIFT

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_obj_shift.c"
#line 12 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_obj_shift.c"

/**
 * @brief Data type for transform_obj_shift.
 */
typedef struct {
  double offset;
} transform_obj_shift_data_t;

/**
 * @brief Evaluates the transformation.
 */
static void transform_obj_shift_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  transform_obj_shift_data_t *data;
  size_t i;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }

  data = (transform_obj_shift_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  IOHprofiler_evaluate_function(IOHprofiler_problem_transformed_get_inner_problem(problem), x, y);
  
  for (i = 0; i < problem->number_of_objectives; i++) {
      y[i] += data->offset;
      problem->raw_fitness[i] = IOHprofiler_problem_transformed_get_inner_problem(problem)->raw_fitness[i];
  }

  assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_obj_shift(IOHprofiler_problem_t *inner_problem, const double offset) {
  IOHprofiler_problem_t *problem;
  transform_obj_shift_data_t *data;
  size_t i;
  data = (transform_obj_shift_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = offset;

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, NULL, "transform_obj_shift");
  problem->evaluate_function = transform_obj_shift_evaluate;
  for (i = 0; i < problem->number_of_objectives; i++) {
      problem->best_value[0] += offset;
  }
  return problem;
}
#endif
#line 21 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_vars_shift.c"
/**
 * @file transform_vars_shift.c
 * @brief Implementation of shifting all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_SHIFT
#define TRANSFORM_VARS_SHIFT

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_vars_shift.c"
#line 12 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_vars_shift.c"

/**
 * @brief Data type for transform_vars_shift.
 */
typedef struct {
  int *offset;
  int *shifted_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_shift_data_t;

/**
 * @brief Evaluates the transformation.
 */
static void transform_vars_shift_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_shift_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }

  data = (transform_vars_shift_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  

  for (i = 0; i < problem->number_of_variables; ++i) {
    data->shifted_x[i] = x[i] + data->offset[i];
  }
  inner_problem->number_of_variables = problem->number_of_variables;
  IOHprofiler_evaluate_function(inner_problem, data->shifted_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0] <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_shift_free(void *thing) {
  transform_vars_shift_data_t *data = (transform_vars_shift_data_t *) thing;
  IOHprofiler_free_memory(data->shifted_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_shift(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int shift_bounds) {
  transform_vars_shift_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  if (shift_bounds)
    IOHprofiler_error("shift_bounds not implemented.");


  data = (transform_vars_shift_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, inner_problem->number_of_variables);
  data->shifted_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);


  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_shift_free, "transform_vars_shift");
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  problem->evaluate_function = transform_vars_shift_evaluate;
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] += data->offset[i];
  }
  return problem;
}
#endif
#line 22 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_vars_sigma.c"
/**
 * @file transform_vars_sigma.c
 * @brief Implementation of sigmad all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_SIGMA
#define TRANSFORM_VARS_SIGMA

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_vars_sigma.c"
#line 12 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_vars_sigma.c"

/**
 * @brief Data type for transform_vars_sigma.
 */
typedef struct {
  int *offset;
  int *sigma_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_sigma_data_t;

/**
 * @brief Evaluates the transformation.
 */
static int sigma_compute(const int *x, const int pos){
  return x[pos];
}

static void transform_vars_sigma_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_sigma_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }
  data = (transform_vars_sigma_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->sigma_x[i] = sigma_compute(x,data->offset[i]);
  }

  IOHprofiler_evaluate_function(inner_problem, data->sigma_x, y);
  problem->raw_fitness[0] = y[0];
  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_sigma_free(void *thing) {
  transform_vars_sigma_data_t *data = (transform_vars_sigma_data_t *) thing;
  IOHprofiler_free_memory(data->sigma_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_sigma(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int sigma_bounds) {
    
  transform_vars_sigma_data_t *data;
  IOHprofiler_problem_t *problem;
  int * temp_best;
  size_t i;
  if (sigma_bounds)
    IOHprofiler_error("sigma_bounds not implemented.");

  data = (transform_vars_sigma_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, inner_problem->number_of_variables);
  data->sigma_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);
  temp_best = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_sigma_free, "transform_vars_sigma");
  problem->evaluate_function = transform_vars_sigma_evaluate;
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      temp_best[i] = sigma_compute(problem->best_parameter,data->offset[i]);
  }
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = temp_best[i];
  }
  IOHprofiler_free_memory(temp_best);
  return problem;
}
#endif
#line 23 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_vars_xor.c"
/**
 * @file transform_vars_xor.c
 * @brief Implementation of xor all decision values by an offset.
 */
#ifndef TRANSFORM_VARS_XOR
#define TRANSFORM_VARS_XOR

#include <assert.h>

#line 11 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_vars_xor.c"
#line 12 "code-experiments/src/profiler/../suite/WModel/../../objective_function/../transform/transform_vars_xor.c"

/**
 * @brief Data type for transform_vars_xor.
 */
typedef struct {
  int *offset;
  int *xor_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} transform_vars_xor_data_t;

/**
 * @brief Evaluates the transformation.
 */
static int xor_compute(const int x1, const int x2){
    return (int) x1 != x2;
}

static void transform_vars_xor_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  transform_vars_xor_data_t *data;
  IOHprofiler_problem_t *inner_problem;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
  	IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
  	return;
  }

  data = (transform_vars_xor_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  for (i = 0; i < problem->number_of_variables; ++i) {
    data->xor_x[i] = xor_compute(x[i],data->offset[i]);
  }
  inner_problem->number_of_variables = problem->number_of_variables;
  IOHprofiler_evaluate_function(inner_problem, data->xor_x, y);
  problem->raw_fitness[0] = y[0];

  assert(y[0]  <= problem->best_value[0]);
}

/**
 * @brief Frees the data object.
 */
static void transform_vars_xor_free(void *thing) {
  transform_vars_xor_data_t *data = (transform_vars_xor_data_t *) thing;
  IOHprofiler_free_memory(data->xor_x);
  IOHprofiler_free_memory(data->offset);
}

/**
 * @brief Creates the transformation.
 */
static IOHprofiler_problem_t *transform_vars_xor(IOHprofiler_problem_t *inner_problem,
                                            const int *offset,
                                            const int xor_bounds) {
    
  transform_vars_xor_data_t *data;
  IOHprofiler_problem_t *problem;
  size_t i;
  if (xor_bounds)
    IOHprofiler_error("xor_bounds not implemented.");

  data = (transform_vars_xor_data_t *) IOHprofiler_allocate_memory(sizeof(*data));
  data->offset = IOHprofiler_duplicate_int_vector(offset, inner_problem->number_of_variables);
  data->xor_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);

  problem = IOHprofiler_problem_transformed_allocate(inner_problem, data, transform_vars_xor_free, "transform_vars_xor");
  problem->evaluate_function = transform_vars_xor_evaluate;
  /* Compute best parameter */
  for (i = 0; i < problem->number_of_variables; i++) {
      problem->best_parameter[i] = xor_compute(problem->best_parameter[i],data->offset[i]);
  }
  return problem;
}
#endif
#line 24 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"

/*Load all raw problems*/
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/raw_functions/one_max.c"
/**
 * @Onemax function
 */

/**
 * @file f_one_max.c
 * @brief Implementation of the one_max function and problem.
 */

#ifndef ONE_MAX
#define ONE_MAX

#include <assert.h>
#include <stdio.h>
#line 1 "code-experiments/src/profiler/../suite/WModel/../../objective_function/raw_functions/../../profiler/IOHprofiler.h"
/**
 * @file IOHprofiler.h
 * @brief All public IOHprofiler functions and variables are defined in this file.
 *
 * It is the authoritative reference, if any function deviates from the documented behavior it is considered
 * a bug. See the function definitions for their detailed descriptions.
 */

#ifndef __IOHprofiler_H__
#define __IOHprofiler_H__

#include <stddef.h>

/* Definitions of some 32 and 64-bit types (used by the random number generator) */
#ifdef _MSC_VER
typedef __int32 int32_t;
typedef unsigned __int32 uint32_t;
typedef __int64 int64_t;
typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif

/* Include definition for NAN among other things */
#include <float.h>
#include <math.h>
#ifndef NAN
/** @brief Definition of NAN to be used only if undefined by the included headers */
#define NAN 8.8888e88
#endif
#ifndef isnan
/** @brief Definition of isnan to be used only if undefined by the included headers */
#define isnan(x) (0)
#endif
#ifndef INFINITY
/** @brief Definition of INFINITY to be used only if undefined by the included headers */
#define INFINITY 1e22
/* why not using 1e99? */
#endif
#ifndef isinf
/** @brief Definition of isinf to be used only if undefined by the included headers */
#define isinf(x) (0)
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief IOHprofiler's version.
 *
 * Automatically updated by do.py.
 */
/**@{*/
static const char IOHprofiler_version[32] = "";
/**@}*/

/***********************************************************************************************************/
/**
 * @brief IOHprofiler's own pi constant. Simplifies the case, when the value of pi changes.
 */
/**@{*/
static const double IOHprofiler_pi = 3.14159265358979323846;
/**@}*/

/***********************************************************************************************************/

/** @brief Logging level type. */
typedef enum {
    IOHprofiler_ERROR,   /**< @brief only error messages are output */
    IOHprofiler_WARNING, /**< @brief error and warning messages are output */
    IOHprofiler_INFO,    /**< @brief error, warning and info messages are output */
    IOHprofiler_DEBUG    /**< @brief error, warning, info and debug messages are output */
} IOHprofiler_log_level_type_e;

/***********************************************************************************************************/

/** @brief Structure containing a IOHprofiler problem. */
struct IOHprofiler_problem_s;

/**
 * @brief The IOHprofiler problem type.
 *
 * See IOHprofiler_problem_s for more information on its fields. */
typedef struct IOHprofiler_problem_s IOHprofiler_problem_t;

/** @brief Structure containing a IOHprofiler suite. */
struct IOHprofiler_suite_s;

/**
 * @brief The IOHprofiler suite type.
 *
 * See IOHprofiler_suite_s for more information on its fields. */
typedef struct IOHprofiler_suite_s IOHprofiler_suite_t;

/** @brief Structure containing a IOHprofiler observer. */
struct IOHprofiler_observer_s;

/**
 * @brief The IOHprofiler observer type.
 *
 * See IOHprofiler_observer_s for more information on its fields. */
typedef struct IOHprofiler_observer_s IOHprofiler_observer_t;

/** @brief Structure containing a IOHprofiler archive. */
struct IOHprofiler_archive_s;

/**
 * @brief The IOHprofiler archive type.
 *
 * See IOHprofiler_archive_s for more information on its fields. */
typedef struct IOHprofiler_archive_s IOHprofiler_archive_t;

/** @brief Structure containing a IOHprofiler random state. */
struct IOHprofiler_random_state_s;

/**
 * @brief The IOHprofiler random state type.
 *
 * See IOHprofiler_random_state_s for more information on its fields. */
typedef struct IOHprofiler_random_state_s IOHprofiler_random_state_t;

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler suite
 */
/**@{*/

/**
 * @brief Constructs a IOHprofiler suite.
 */
IOHprofiler_suite_t *IOHprofiler_suite(const char *suite_name, const char *suite_instance, const char *suite_options,int number, char** layer_param,char * temp_dim);

/**
 * @brief Frees the given suite.
 */
void IOHprofiler_suite_free(IOHprofiler_suite_t *suite);

/**
 * @brief Returns the next (observed) problem of the suite or NULL if there is no next problem left.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_next_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 *
 * @returns The current problem of the suite.
 */
IOHprofiler_problem_t *IOHprofiler_suite_reset_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer);

/**
 * @brief Returns the problem of the suite defined by problem_index.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_problem(IOHprofiler_suite_t *suite, const size_t problem_index);

/**
 * @brief Returns the number of problems in the given suite.
 */
size_t IOHprofiler_suite_get_number_of_problems(const IOHprofiler_suite_t *suite);

/**
 * @brief Returns the function number in the suite in position function_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_function_from_function_index(const IOHprofiler_suite_t *suite, const size_t function_idx);

/**
 * @brief Returns the dimension number in the suite in position dimension_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_dimension_from_dimension_index(const IOHprofiler_suite_t *suite, const size_t dimension_idx);

/**
 * @brief Returns the instance number in the suite in position instance_idx (counting from 0).
 */
size_t IOHprofiler_suite_get_instance_from_instance_index(const IOHprofiler_suite_t *suite, const size_t instance_idx);
/**@}*/

/**
 * @name Encoding/decoding problem index
 *
 * General schema for encoding/decoding a problem index. Note that the index depends on the number of
 * instances a suite is defined with (it should be called a suite-instance-depending index...).
 * Also, while functions, instances and dimensions start from 1, function_idx, instance_idx and dimension_idx
 * as well as suite_dep_index start from 0!
 *
 * Showing an example with 2 dimensions (2, 3), 5 instances (6, 7, 8, 9, 10) and 2 functions (1, 2):
 *
   \verbatim
   index | instance | function | dimension
   ------+----------+----------+-----------
       0 |        6 |        1 |         2
       1 |        7 |        1 |         2
       2 |        8 |        1 |         2
       3 |        9 |        1 |         2
       4 |       10 |        1 |         2
       5 |        6 |        2 |         2
       6 |        7 |        2 |         2
       7 |        8 |        2 |         2
       8 |        9 |        2 |         2
       9 |       10 |        2 |         2
      10 |        6 |        1 |         3
      11 |        7 |        1 |         3
      12 |        8 |        1 |         3
      13 |        9 |        1 |         3
      14 |       10 |        1 |         3
      15 |        6 |        2 |         2
      16 |        7 |        2 |         3
      17 |        8 |        2 |         3
      18 |        9 |        2 |         3
      19 |       10 |        2 |         3

   index | instance_idx | function_idx | dimension_idx
   ------+--------------+--------------+---------------
       0 |            0 |            0 |             0
       1 |            1 |            0 |             0
       2 |            2 |            0 |             0
       3 |            3 |            0 |             0
       4 |            4 |            0 |             0
       5 |            0 |            1 |             0
       6 |            1 |            1 |             0
       7 |            2 |            1 |             0
       8 |            3 |            1 |             0
       9 |            4 |            1 |             0
      10 |            0 |            0 |             1
      11 |            1 |            0 |             1
      12 |            2 |            0 |             1
      13 |            3 |            0 |             1
      14 |            4 |            0 |             1
      15 |            0 |            1 |             1
      16 |            1 |            1 |             1
      17 |            2 |            1 |             1
      18 |            3 |            1 |             1
      19 |            4 |            1 |             1
   \endverbatim
 */
/**@{*/
/**
 * @brief Computes the index of the problem in the suite that corresponds to the given function, dimension
 * and instance indices.
 */
size_t IOHprofiler_suite_encode_problem_index(const IOHprofiler_suite_t *suite,
                                              const size_t function_idx,
                                              const size_t dimension_idx,
                                              const size_t instance_idx);

/**
 * @brief Computes the function, dimension and instance indexes of the problem with problem_index in the
 * given suite.
 */
void IOHprofiler_suite_decode_problem_index(const IOHprofiler_suite_t *suite,
                                            const size_t problem_index,
                                            size_t *function_idx,
                                            size_t *dimension_idx,
                                            size_t *instance_idx);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler observer
 */
/**@{*/
/**
 * @brief Constructs a IOHprofiler observer.
 */
IOHprofiler_observer_t *IOHprofiler_observer(const char *observer_name, const char *options);

/**
 * @brief Frees the given observer.
 */
void IOHprofiler_observer_free(IOHprofiler_observer_t *observer);

/**
 * @brief Adds an observer to the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_add_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**
 * @brief Removes an observer from the given problem.
 */
IOHprofiler_problem_t *IOHprofiler_problem_remove_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer);

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler problem
 */
/**@{*/
/**
 * @brief Evaluates the problem function in point x and save the result in y.
  logger_** functions use number_of_parameters and parameters to log extra informations of algorithms' adaptive parameters.
  If there is no need to log parameters, set number_of_parameters and parameters as 0 and NULL respectively.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Evaluates the problem constraints in point x and save the result in y.
 */
void IOHprofiler_evaluate_constraint(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief Recommends a solution as the current best guesses to the problem.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief Frees the given problem.
 */
void IOHprofiler_problem_free(IOHprofiler_problem_t *problem);

void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters);

/**
 * @brief Returns the name of the problem.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the ID of the problem.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of variables i.e. the dimension of the problem.
 */
size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of objectives of the problem.
 */
size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the number of evaluations done on the problem.
 */
size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns 1 if the final target was hit, 0 otherwise.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the best observed value for the first objective.
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the target value for the first objective.
 */
double depreciated_IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with lower bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns a vector of size 'dimension' with upper bounds of the region of interest in
 * the decision space.
 */
const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns the problem_index of the problem in its current suite.
 */
size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem);

/**
 * @brief Returns an initial solution, i.e. a feasible variable setting, to the problem.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding random numbers
 */
/**@{*/

/**
 * @brief Creates and returns a new random number state using the given seed.
 */
IOHprofiler_random_state_t *IOHprofiler_random_new(uint32_t seed);

/**
 * @brief Frees all memory associated with the random state.
 */
void IOHprofiler_random_free(IOHprofiler_random_state_t *state);

/**
 * @brief Returns one uniform [0, 1) random value from the random number generator associated with the given
 * state.
 */
double IOHprofiler_random_uniform(IOHprofiler_random_state_t *state);

/**
 * @brief Generates an approximately normal random number.
 */
double IOHprofiler_random_normal(IOHprofiler_random_state_t *state);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods managing memory
 */
/**@{*/
/**
 * @brief Safe memory allocation that either succeeds or triggers a IOHprofiler_error.
 */
void *IOHprofiler_allocate_memory(const size_t size);

/**
 * @brief Safe memory allocation for a vector of doubles that either succeeds or triggers a IOHprofiler_error.
 */
double *IOHprofiler_allocate_vector(const size_t size);

/**
 * @brief Safe memory allocation for a vector of int that either succeeds or triggers a IOHprofiler_error.
 */
int *IOHprofiler_allocate_int_vector(const size_t size);

/**
 * @brief Frees the allocated memory.
 */
void IOHprofiler_free_memory(void *data);
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding IOHprofiler messages
 */
/**@{*/
/**
 * @brief Signals a fatal error.
 */
void IOHprofiler_error(const char *message, ...);

/**
 * @brief Warns about error conditions.
 */
void IOHprofiler_warning(const char *message, ...);

/**
 * @brief Outputs some information.
 */
void IOHprofiler_info(const char *message, ...);

/**
 * @brief Prints only the given message without any prefix and new line.
 *
 * A function similar to IOHprofiler_info but producing no additional text than
 * the given message.
 *
 * The output is only produced if IOHprofiler_log_level >= IOHprofiler_INFO.
 */
void IOHprofiler_info_partial(const char *message, ...);

/**
 * @brief Outputs detailed information usually used for debugging.
 */
void IOHprofiler_debug(const char *message, ...);

/**
 * @brief Sets the IOHprofiler log level to the given value and returns the previous value of the log level.
 */
const char *IOHprofiler_set_log_level(const char *level);
/**@}*/

/***********************************************************************************************************/

/**
 * @brief Constructs a IOHprofiler archive.
 */
IOHprofiler_archive_t *IOHprofiler_archive(const char *suite_name,
                                           const size_t function,
                                           const size_t dimension,
                                           const size_t instance);
/**
 * @brief Adds a solution with objectives (y1, y2) to the archive if none of the existing solutions in the
 * archive dominates it. In this case, returns 1, otherwise the archive is not updated and the method
 * returns 0.
 */

int IOHprofiler_archive_add_solution(IOHprofiler_archive_t *archive, const double y1, const double y2, const char *text);

/**
 * @brief Returns the number of (non-dominated) solutions in the archive (computed first, if needed).
 */
size_t IOHprofiler_archive_get_number_of_solutions(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the hypervolume of the archive (computed first, if needed).
 */
double IOHprofiler_archive_get_hypervolume(IOHprofiler_archive_t *archive);

/**
 * @brief Returns the text of the next (non-dominated) solution in the archive and "" when there are no
 * solutions left. The first two solutions are always the extreme ones.
 */
const char *IOHprofiler_archive_get_next_solution_text(IOHprofiler_archive_t *archive);

/**
 * @brief Frees the archive.
 */
void IOHprofiler_archive_free(IOHprofiler_archive_t *archive);

/***********************************************************************************************************/

/**
 * @name Other useful methods
 */
/**@{*/
/**
 * @brief Removes the given directory and all its contents.
 */
int IOHprofiler_remove_directory(const char *path);

/**
 * @brief Formatted string duplication.
 */
char *IOHprofiler_strdupf(const char *str, ...);
/**@}*/

/***********************************************************************************************************/
typedef int (*int_to_int_func)(int);

struct WModel{
  size_t number_of_layers;
  int *layer1;
  int min1; int_to_int_func l_max1;
  int *layer2;
  int min2;int_to_int_func l_max2;
  int *layer3;
  int min3; int_to_int_func l_max3;
  int *layer4;
  int min4; int_to_int_func l_max4;
  int *counter;
};


#ifdef __cplusplus
}
#endif
#endif
#line 16 "code-experiments/src/profiler/../suite/WModel/../../objective_function/raw_functions/one_max.c"

static double one_max_raw(const int *x, const size_t number_of_variables) {
    size_t i = 0;
    int result;

    if (IOHprofiler_vector_contains_nan(x, number_of_variables))
        return NAN;
    result = 0;
    for (i = 0; i < number_of_variables; ++i) {
        result += x[i];
    }

    return (double) result;
}

#endif
#line 27 "code-experiments/src/profiler/../suite/WModel/../../objective_function/modular_problem.c"

enum IOHProblem {one_max=1};
enum WModel_layer {Dummy=0,Neutrality=1, Epistasis=2,Ruggedness=3};
static int id_problem=1;


static double f_raw(const int *x, const size_t number_of_variables){
  double res;
  if (id_problem==1){
    res=(double) one_max_raw(x, number_of_variables);
    return res;
  }
  else {return (double) 0;}
}

/**
 * @brief Uses the raw function to evaluate the IOHprofiler problem.
 */
static void f_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
    assert(problem->number_of_objectives == 1);
    y[0] = f_raw(x, problem->number_of_variables);
/*    if(y[0] > problem->best_value[0]){
     int i;
     for(i=0;i<problem->number_of_variables;i++){fprintf(stderr,"%d ",x[i]);}
      fprintf(stderr,"nb_var:%d best :%lf get :%lf\n",problem->number_of_variables,problem->best_value[0],y[0]);
    }*/
    assert(y[0] <= problem->best_value[0]);
}
static void inner_problem_free_function(IOHprofiler_problem_t *inner_problem){
  if(inner_problem->data !=NULL){
    IOHprofiler_free_memory(inner_problem->data);
    IOHprofiler_free_memory(inner_problem);
  }
}
static IOHprofiler_problem_t *raw_problem_allocate(const size_t number_of_variables,int * parameters,int number_of_layer) {
    char*name;
    name=get_name_problem2(id_problem,parameters);
    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate_from_scalars(name,
                                                                               f_evaluate, NULL, number_of_variables, 0, 1, 1);
    IOHprofiler_problem_set_id(problem, "%s_d%02lu", name, number_of_variables);
/*    problem->data=IOHprofiler_duplicate_int_vector(parameters,number_of_layer);*/
    free(name);
    /* Compute best solution */
    f_evaluate(problem, problem->best_parameter, problem->best_value);

    return problem;
}


static void global_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  size_t i;
  WModel_data_t *data;
  IOHprofiler_problem_t *inner_problem;
  int temp_dim,new_dim;
  int * tempX;

  if (IOHprofiler_vector_contains_nan(x, IOHprofiler_problem_get_dimension(problem))) {
    IOHprofiler_vector_set_to_nan(y, IOHprofiler_problem_get_number_of_objectives(problem));
    return;
  }
  data = (WModel_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
  temp_dim=data->old_dim;

  tempX=IOHprofiler_duplicate_int_vector(x,temp_dim);

/*for(i=0;i<temp_dim;i++){fprintf(stderr,"%d ",tempX[i]);}fprintf(stderr,"\n");*/
  if(data->parameters[Dummy]>0){
    temp_dim = temp_dim- (int)(data->parameters[Dummy]);
    for (i = 0; i < temp_dim; ++i) {
      data->data1->reduncted_x[i] = tempX[data->data1->postion_match[i]];
    }
    IOHprofiler_free_memory(tempX);
    tempX=IOHprofiler_duplicate_int_vector(data->data1->reduncted_x,temp_dim);
/*for(i=0;i<temp_dim;i++){fprintf(stderr,"%d ",tempX[i]);}fprintf(stderr,"\n");*/
  }if(data->parameters[Neutrality]>1){
    new_dim = temp_dim/ (data->parameters[Neutrality]);
/*    for (i = 0; i < temp_dim; ++i) {
      data->data2->neutrality_x[i] = layer_neutrality_compute(tempX,i*(data->data2->offset[0]), data->data2->offset[0]);
    }*/
    layer_neutrality_compute(tempX, data->data2->neutrality_x, data->data2->offset[0],temp_dim,new_dim);
    temp_dim=new_dim;
    IOHprofiler_free_memory(tempX);
    tempX=IOHprofiler_duplicate_int_vector(data->data2->neutrality_x,temp_dim);
/*for(i=0;i<temp_dim;i++){fprintf(stderr,"%d ",tempX[i]);}fprintf(stderr,"\n");*/
  }if(data->parameters[Epistasis]>1){
    layer_epistasis_compute(tempX, data->data3->epistasis_x, data->data3->offset[0], temp_dim);
    IOHprofiler_free_memory(tempX);
    tempX=IOHprofiler_duplicate_int_vector(data->data3->epistasis_x,temp_dim);
/*for(i=0;i<temp_dim;i++){fprintf(stderr,"%d ",tempX[i]);}fprintf(stderr,"\n");*/
  }
  /*f_evaluate(inner_problem, tempX, y);*/
  IOHprofiler_evaluate_function(inner_problem, tempX, y);

  if(data->parameters[Ruggedness]>0){
    y[0] = layer_compute_ruggedness(y[0],temp_dim,data->parameters[Ruggedness]);
  }
  /*for(i=0;i<10;i++){fprintf(stderr,"%d ",x[i]);}fprintf(stderr,"   -> %f\n",y[0]);*/
  assert(y[0] <= problem->best_value[0]);
  IOHprofiler_free_memory(tempX);
  problem->raw_fitness[0] = y[0];

}

static void global_free(void *thing) {
  WModel_data_t *data = (WModel_data_t *) thing;
  IOHprofiler_free_memory(data->parameters);
  if(data->data1!=NULL){dummy_random_free(data->data1);IOHprofiler_free_memory(data->data1);}
  if(data->data2!=NULL){neutrality_free(data->data2);IOHprofiler_free_memory(data->data2);}
  if(data->data3!=NULL){epistasis_free(data->data3);IOHprofiler_free_memory(data->data3);}
  if(data->data4!=NULL){IOHprofiler_free_memory(data->data4);}
}

static IOHprofiler_problem_t *global_transform(IOHprofiler_problem_t *inner_problem, const int *parameters,int old_dim,int number_of_layer) {
  size_t new_dim,temp_dim;
  int i;
  IOHprofiler_problem_t *problem;
  WModel_data_t *Data;
  dummy_random_data_t *data1;
  neutrality_data_t *data2;
  epistasis_data_t *data3;
  ruggedness_data_t *data4;

  Data = (WModel_data_t *) IOHprofiler_allocate_memory(sizeof(*Data));
  Data->parameters=IOHprofiler_duplicate_int_vector(parameters,number_of_layer);
  Data->number_of_layer=number_of_layer;
  Data->old_dim=old_dim;
  new_dim=old_dim;
  Data->data1=NULL;
  Data->data2=NULL;
  Data->data3=NULL;
  Data->data4=NULL;

  if(*(parameters+Dummy)>0){
    temp_dim = new_dim- *(parameters+Dummy);
    assert(temp_dim > 0);
    data1 = (dummy_random_data_t *) IOHprofiler_allocate_memory(sizeof(*data1));
    data1->offset = IOHprofiler_duplicate_int_vector((parameters+Dummy), 1);
    data1->reduncted_x = IOHprofiler_allocate_int_vector(temp_dim);
    data1->postion_match = IOHprofiler_allocate_int_vector(temp_dim);
    compute_dummy_random_match(data1->postion_match,new_dim,temp_dim);
    Data->data1=data1;
    new_dim=temp_dim;

  }if(*(parameters+Neutrality)>1){
    temp_dim = new_dim/ *(parameters+Neutrality);
    assert(temp_dim > 0);
    data2 = (neutrality_data_t *) IOHprofiler_allocate_memory(sizeof(*data2));
    data2->offset = IOHprofiler_duplicate_int_vector(parameters+Neutrality, 1);
    data2->neutrality_x = IOHprofiler_allocate_int_vector(temp_dim);
    Data->data2=data2;
    new_dim=temp_dim;

  }if(*(parameters+Epistasis)>1){
    data3 = (epistasis_data_t *) IOHprofiler_allocate_memory(sizeof(*data3));
    data3->offset = IOHprofiler_duplicate_int_vector(parameters+Epistasis, 1);
    data3->epistasis_x = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);
    Data->data3=data3;

  }if(*(parameters+Ruggedness)!=0){
    data4 = (ruggedness_data_t *) IOHprofiler_allocate_memory(sizeof(*data4));
    Data->data4=data4;
  }

  problem = IOHprofiler_problem_transformed_allocate(inner_problem,(void *) Data, global_free, "WModel");

  problem->number_of_variables = new_dim;
  inner_problem->number_of_variables = problem->number_of_variables;
  problem->evaluate_function = global_evaluate;

/*fprintf(stderr,"para %d %d %d %d \n",*(parameters+Dummy),*(parameters+Neutrality),*(parameters+Epistasis),*(parameters+Ruggedness));*/
  f_evaluate(inner_problem,inner_problem->best_parameter, (problem->best_value));
  inner_problem->best_observed_fvalue[0]=DBL_MIN_EXP;
  inner_problem->best_observed_evaluation[0] = 0;
/*  fprintf(stderr,"best %f\n",*(problem->best_value));*/
  return problem;
}
/**
 * @brief Creates the IOHprofiler one_max_neutrality problem.
 */
static IOHprofiler_problem_t *f_IOHprofiler_problem_allocate(const size_t function,
                                                                     const size_t dimension,
                                                                     const size_t instance,
                                                                     const long rseed,
                                                                     const char *problem_id_template,
                                                                     const char *problem_name_template,int * parameters,int number_of_layer) {

    size_t *z, *sigma;
    int temp,t,*new_dim;
    size_t i;
    double a;
    double b;
    double *xins;
    IOHprofiler_problem_t *problem,*inner_problem;
    inner_problem = raw_problem_allocate(dimension,parameters,number_of_layer);
/*fprintf(stderr,"%d  ",parameters[1]);
fprintf(stderr,"%d  ",parameters[2]);
fprintf(stderr,"%d  \n",parameters[3]);*/
    problem = global_transform(inner_problem,parameters,dimension,number_of_layer);
    /*
    if(instance == 1){
       
    }
    else if(instance > 1 && instance <= 50){
        z = IOHprofiler_allocate_int_vector(problem->number_of_variables+1);

        IOHprofiler_compute_xopt(z,rseed,problem->number_of_variables);
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function,instance);
        assert(a <= 5.0 && a >= 0.2);
        problem = transform_vars_xor(problem,z,0);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);
        IOHprofiler_free_memory(z);
    }
    else if(instance > 50 && instance <= 100)
    {
        sigma = IOHprofiler_allocate_int_vector(problem->number_of_variables+1);
        xins = IOHprofiler_allocate_vector(problem->number_of_variables+1);
        
        IOHprofiler_compute_xopt_double(xins,rseed,problem->number_of_variables);
        for(i = 0; i < problem->number_of_variables; i++){
            sigma[i] = (int)i;
        }
        for(i = 0; i < new_dim; i++){
            t = (int)(xins[i] * (double)problem->number_of_variables);
            assert(t >= 0 && t < problem->number_of_variables);
            temp = sigma[0];
            sigma[0] = sigma[t];
            sigma[t] = temp; 
        }
        a = IOHprofiler_compute_fopt(function,instance + 100);
        a = fabs(a) / 1000 * 4.8 + 0.2;
        b = IOHprofiler_compute_fopt(function, instance);
        assert(a <= 5.0 && a >= 0.2);

        problem = transform_vars_sigma(problem,sigma, 0);
        problem = transform_obj_scale(problem,a);
        problem = transform_obj_shift(problem,b);

        IOHprofiler_free_memory(sigma);
        IOHprofiler_free_memory(xins);
    }*/
    IOHprofiler_problem_set_id(problem, problem_id_template, function, instance, dimension);
    IOHprofiler_problem_set_name(problem, problem_name_template, function, instance, dimension);
    IOHprofiler_problem_set_type(problem, "pseudo-Boolean");
    IOHprofiler_free_memory(problem_id_template);
    IOHprofiler_free_memory(parameters);


    return problem;
}
#endif
#line 10 "code-experiments/src/profiler/../suite/WModel/suite_WModel.c"

#line 1 "code-experiments/src/profiler/../suite/WModel/utils.c"
#ifndef UTILS
#define UTILS

#define MAX_PARAMETER 1000
#define MAX_CHAR 5
#line 1 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_string.c"
/**
 * @file IOHprofiler_string.c
 * @brief Definitions of functions that manipulate strings.
 */
#ifndef IOH_PROFILER_STRING
#define IOH_PROFILER_STRING

#include <stddef.h>
#include <stdlib.h>
#include <string.h>

#line 13 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_string.c"

static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements);

/**
 * @brief Creates a duplicate copy of string and returns a pointer to it.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strdup(const char *string) {
    size_t len;
    char *duplicate;
    if (string == NULL)
        return NULL;
    len = strlen(string);
    duplicate = (char *)IOHprofiler_allocate_memory(len + 1);
    memcpy(duplicate, string, len + 1);
    return duplicate;
}

/**
 * @brief The length of the buffer used in the IOHprofiler_vstrdupf function.
 *
 * @note This should be handled differently!
 */
#define IOHprofiler_VSTRDUPF_BUFLEN 444

/**
 * @brief Formatted string duplication, with va_list arguments.
 */
static char *IOHprofiler_vstrdupf(const char *str, va_list args) {
    static char buf[IOHprofiler_VSTRDUPF_BUFLEN];
    long written;
    /* apparently args can only be used once, therefore
   * len = vsnprintf(NULL, 0, str, args) to find out the
   * length does not work. Therefore we use a buffer
   * which limits the max length. Longer strings should
   * never appear anyway, so this is rather a non-issue. */

#if 0
  written = vsnprintf(buf, IOHprofiler_VSTRDUPF_BUFLEN - 2, str, args);
  if (written < 0)
  IOHprofiler_error("IOHprofiler_vstrdupf(): vsnprintf failed on '%s'", str);
#else /* less safe alternative, if vsnprintf is not available */
    assert(strlen(str) < IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2);
    if (strlen(str) >= IOHprofiler_VSTRDUPF_BUFLEN / 2 - 2)
        IOHprofiler_error("IOHprofiler_vstrdupf(): string is too long");
    written = vsprintf(buf, str, args);
    if (written < 0)
        IOHprofiler_error("IOHprofiler_vstrdupf(): vsprintf failed on '%s'", str);
#endif
    if (written > IOHprofiler_VSTRDUPF_BUFLEN - 3)
        IOHprofiler_error("IOHprofiler_vstrdupf(): A suspiciously long string is tried to being duplicated '%s'", buf);
    return IOHprofiler_strdup(buf);
}

#undef IOHprofiler_VSTRDUPF_BUFLEN

/**
 * Optional arguments are used like in sprintf.
 */
char *IOHprofiler_strdupf(const char *str, ...) {
    va_list args;
    char *s;

    va_start(args, str);
    s = IOHprofiler_vstrdupf(str, args);
    va_end(args);
    return s;
}

/**
 * @brief Returns a concatenate copy of string1 + string2.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_strconcat(const char *s1, const char *s2) {
    size_t len1 = strlen(s1);
    size_t len2 = strlen(s2);
    char *s = (char *)IOHprofiler_allocate_memory(len1 + len2 + 1);

    memcpy(s, s1, len1);
    memcpy(&s[len1], s2, len2 + 1);
    return s;
}

/**
 * @brief Returns the first index where seq occurs in base and -1 if it doesn't.
 *
 * @note If there is an equivalent standard C function, this can/should be removed.
 */
static long IOHprofiler_strfind(const char *base, const char *seq) {
    const size_t strlen_seq = strlen(seq);
    const size_t last_first_idx = strlen(base) - strlen(seq);
    size_t i, j;

    if (strlen(base) < strlen(seq))
        return -1;

    for (i = 0; i <= last_first_idx; ++i) {
        if (base[i] == seq[0]) {
            for (j = 0; j < strlen_seq; ++j) {
                if (base[i + j] != seq[j])
                    break;
            }
            if (j == strlen_seq) {
                if (i > 1e9)
                    IOHprofiler_error("IOHprofiler_strfind(): strange values observed i=%lu, j=%lu, strlen(base)=%lu",
                                      (unsigned long)i, (unsigned long)j, (unsigned long)strlen(base));
                return (long)i;
            }
        }
    }
    return -1;
}

/**
 * @brief Splits a string based on the given delimiter.
 *
 * Returns a pointer to the resulting substrings with NULL as the last one.
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char **IOHprofiler_string_split(const char *string, const char delimiter) {
    char **result;
    char *str_copy, *ptr, *token;
    char str_delimiter[2];
    size_t i;
    size_t count = 1;

    str_copy = IOHprofiler_strdup(string);

    /* Counts the parts between delimiters */
    ptr = str_copy;
    while (*ptr != '\0') {
        if (*ptr == delimiter) {
            count++;
        }
        ptr++;
    }
    /* Makes room for an empty string that will be appended at the end */
    count++;

    result = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));

    /* Iterates through tokens
   * NOTE: strtok() ignores multiple delimiters, therefore the final number of detected substrings might be
   * lower than the count. This is OK. */
    i = 0;
    /* A char* delimiter needs to be used, otherwise strtok() can surprise */
    str_delimiter[0] = delimiter;
    str_delimiter[1] = '\0';
    token = strtok(str_copy, str_delimiter);
    while (token) {
        assert(i < count);
        *(result + i++) = IOHprofiler_strdup(token);
        token = strtok(NULL, str_delimiter);
    }
    *(result + i) = NULL;

    IOHprofiler_free_memory(str_copy);

    return result;
}

/**
 * @brief Creates and returns a string with removed characters between from and to.
 *
 * If you wish to remove characters from the beginning of the string, set from to "".
 * If you wish to remove characters until the end of the string, set to to "".
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_remove_from_string(const char *string, const char *from, const char *to) {
    char *result, *start, *stop;

    result = IOHprofiler_strdup(string);

    if (strcmp(from, "") == 0) {
        /* Remove from the start */
        start = result;
    } else
        start = strstr(result, from);

    if (strcmp(to, "") == 0) {
        /* Remove until the end */
        stop = result + strlen(result);
    } else
        stop = strstr(result, to);

    if ((start == NULL) || (stop == NULL) || (stop < start)) {
        IOHprofiler_error("IOHprofiler_remove_from_string(): failed to remove characters between %s and %s from string %s",
                          from, to, string);
        return NULL; /* Never reached */
    }

    memmove(start, stop, strlen(stop) + 1);

    return result;
}

/**
 * @brief Returns the numbers defined by the ranges.
 *
 * Reads ranges from a string of positive ranges separated by commas. For example: "-3,5-6,8-". Returns the
 * numbers that are defined by the ranges if min and max are used as their extremes. If the ranges with open
 * beginning/end are not allowed, use 0 as min/max. The returned string has an appended 0 to mark its end.
 * A maximum of max_count values is returned. If there is a problem with one of the ranges, the parsing stops
 * and the current result is returned. The memory of the returned object needs to be freed by the caller.
 */
static size_t *IOHprofiler_string_parse_ranges(const char *string,
                                               const size_t min,
                                               const size_t max,
                                               const char *name,
                                               const size_t max_count) {
    char *ptr, *dash = NULL;
    char **ranges, **numbers;
    size_t i, j, count;
    size_t num[2];

    size_t *result;
    size_t i_result = 0;

    char *str = IOHprofiler_strdup(string);

    /* Check for empty string */
    if ((str == NULL) || (strlen(str) == 0)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): cannot parse empty ranges");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    ptr = str;
    /* Check for disallowed characters */
    while (*ptr != '\0') {
        if ((*ptr != '-') && (*ptr != ',') && !isdigit((unsigned char)*ptr)) {
            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - cannot parse ranges with '%c'", str,
                                *ptr);
            IOHprofiler_free_memory(str);
            return NULL;
        } else
            ptr++;
    }
    /* Check for incorrect boundaries */
    if ((max > 0) && (min > max)) {
        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): incorrect boundaries");
        IOHprofiler_free_memory(str);
        return NULL;
    }

    result = IOHprofiler_allocate_vector_size_t(max_count + 1);

    /* Split string to ranges w.r.t commas */
    ranges = IOHprofiler_string_split(str, ',');
    IOHprofiler_free_memory(str);
    if (ranges) {
        /* Go over the current range */
        for (i = 0; *(ranges + i); i++) {
            ptr = *(ranges + i);
            /* Count the number of '-' */
            count = 0;
            while (*ptr != '\0') {
                if (*ptr == '-') {
                    if (count == 0)
                        /* Remember the position of the first '-' */
                        dash = ptr;
                    count++;
                }
                ptr++;
            }
            /* Point again to the start of the range */
            ptr = *(ranges + i);

            /* Check for incorrect number of '-' */
            if (count > 1) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): problem parsing '%s' - too many '-'s", string);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            } else if (count == 0) {
                /* Range is in the format: n (no range) */
                num[0] = (size_t)strtol(ptr, NULL, 10);
                num[1] = num[0];
            } else {
                /* Range is in one of the following formats: n-m / -n / n- / - */

                /* Split current range to numbers w.r.t '-' */
                numbers = IOHprofiler_string_split(ptr, '-');
                j = 0;
                if (numbers) {
                    /* Read the numbers */
                    for (j = 0; *(numbers + j); j++) {
                        assert(j < 2);
                        num[j] = (size_t)strtol(*(numbers + j), NULL, 10);
                        IOHprofiler_free_memory(*(numbers + j));
                    }
                }
                IOHprofiler_free_memory(numbers);

                if (j == 0) {
                    /* Range is in the format - (open ends) */
                    if ((min == 0) || (max == 0)) {
                        IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open ends; some ranges ignored", name);
                        /* Cleanup */
                        for (j = i; *(ranges + j); j++)
                            IOHprofiler_free_memory(*(ranges + j));
                        IOHprofiler_free_memory(ranges);
                        if (i_result == 0) {
                            IOHprofiler_free_memory(result);
                            return NULL;
                        }
                        result[i_result] = 0;
                        return result;
                    }
                    num[0] = min;
                    num[1] = max;
                } else if (j == 1) {
                    if (dash - *(ranges + i) == 0) {
                        /* Range is in the format -n */
                        if (min == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open beginning; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = num[0];
                        num[0] = min;
                    } else {
                        /* Range is in the format n- */
                        if (max == 0) {
                            IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges cannot have an open end; some ranges ignored", name);
                            /* Cleanup */
                            for (j = i; *(ranges + j); j++)
                                IOHprofiler_free_memory(*(ranges + j));
                            IOHprofiler_free_memory(ranges);
                            if (i_result == 0) {
                                IOHprofiler_free_memory(result);
                                return NULL;
                            }
                            result[i_result] = 0;
                            return result;
                        }
                        num[1] = max;
                    }
                }
                /* if (j == 2), range is in the format n-m and there is nothing to do */
            }

            /* Make sure the boundaries are taken into account */
            if ((min > 0) && (num[0] < min)) {
                num[0] = min;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be >= %lu", name,
                                    (unsigned long)min);
              }
            if ((max > 0) && (num[1] > max)) {
                num[1] = max;
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges adjusted to be <= %lu", name, (unsigned long) max);
            }
            if (num[0] > num[1]) {
                IOHprofiler_warning("IOHprofiler_string_parse_ranges(): '%s' ranges not within boundaries; some ranges ignored", name);
                /* Cleanup */
                for (j = i; *(ranges + j); j++)
                    IOHprofiler_free_memory(*(ranges + j));
                IOHprofiler_free_memory(ranges);
                if (i_result == 0) {
                    IOHprofiler_free_memory(result);
                    return NULL;
                }
                result[i_result] = 0;
                return result;
            }

            /* Write in result */
            for (j = num[0]; j <= num[1]; j++) {
                if (i_result > max_count - 1)
                    break;
                result[i_result++] = j;
            }

            IOHprofiler_free_memory(*(ranges + i));
            *(ranges + i) = NULL;
        }
    }

    IOHprofiler_free_memory(ranges);

    if (i_result == 0) {
        IOHprofiler_free_memory(result);
        return NULL;
    }

    result[i_result] = 0;
    return result;
}

/**
 * @brief Trims the given string (removes any leading and trailing spaces).
 *
 * If the string contains any leading spaces, the contents are shifted so that if it was dynamically
 * allocated, it can be still freed on the returned pointer.
 */
static char *IOHprofiler_string_trim(char *string) {
    size_t len = 0;
    char *frontp = string;
    char *endp = NULL;

    if (string == NULL) {
        return NULL;
    }
    if (string[0] == '\0') {
        return string;
    }

    len = strlen(string);
    endp = string + len;

    /* Move the front and back pointers to address the first non-whitespace characters from each end. */
    while (isspace((unsigned char)*frontp)) {
        ++frontp;
    }
    if (endp != frontp) {
        while (isspace((unsigned char)*(--endp)) && endp != frontp) {
        }
    }

    if (string + len - 1 != endp)
        *(endp + 1) = '\0';
    else if (frontp != string && endp == frontp)
        *string = '\0';

    /* Shift the string. Note the reuse of endp to mean the front of the string buffer now. */
    endp = string;
    if (frontp != string) {
        while (*frontp) {
            *endp++ = *frontp++;
        }
        *endp = '\0';
    }

    return string;
}
#endif
#line 7 "code-experiments/src/profiler/../suite/WModel/utils.c"
#line 8 "code-experiments/src/profiler/../suite/WModel/utils.c"

static int layer_number;
/*static char **layer_para;*/
static char * dimensions;

#define BUFF 50
/*
 * this files contains basic functions about parameters for the layer
*/
static int layer_para[4] ={0,0,0,0};

int * copy_and_realloc(const int *src, const size_t number_of_elements,int new_size);
/*old*/
/*
void init_parameters(int number,char**lp){
  layer_number=number;
  layer_parameters=lp;

}*/
/*old*/
int number_of_op(size_t * layer){
  int i=1,sum=1;
  if (layer==NULL){return 0;}
  while(*(layer+i)!=0){
    sum++;i++;
  }
  return sum;
}
void pr_para(int * p){
fprintf(stderr,"%d  ",p[0]);
fprintf(stderr,"%d  ",p[1]);
fprintf(stderr,"%d  ",p[2]);
fprintf(stderr,"%d \n",p[3]);
}
int compute_problem_dimension(int dim,int du,int ne){
  int output_dim =dim;
  if(du>dim){return 0;}
  output_dim = (int)(output_dim- (int)(du));
  if(ne>0 && ne<output_dim){
    output_dim=(int)(output_dim/ (ne));
  }else if(ne<0 || ne>=output_dim){ return 0;}
/*  if(output_dim<4){fprintf(stderr,"\n dim %d du %d ne %d dim %d\n",dim,du,ne,output_dim);}*/
  return output_dim;
}
int correct_epistasis(int dim,int * ep){
  int sum;
  sum=0;
  int i=0;
  do{
    if (ep[i] !=0 && ep[i]<dim){sum++;}
    i++;
  }while(ep[i]!=0);
  return sum;
}
int correct_ruggedness(int dim,int * ru){
  int sum;
  sum=0;
  int i=0;
  do{
    if (ru[i]<(dim*(dim-1))/2){sum++;}
    i++;
  }while(ru[i]!=0);
  return sum;
}
float dim_proportion(int dim,int dum,int neutr){
  if(neutr==0){return ( 100-dum);}

/*  fprintf(stderr,"%d %d %f  res %d\n",dum,neutr,(100.-dum)/neutr,(100.-dum)/neutr>=5);*/
  return  (100.-dum)/neutr;
}
int is_correct_problem(const int dim, const int dum,const int neutr){
/*  if (dim_proportion(dim,dum,neutr)>=(float) 1/dim){return 1;}*/
  if (dim_proportion(dim,dum,neutr)>=5){return 1;}
  
  else{return 0;}
}
int valid(int dim, int du, int ne, int ep,int ru){
/*  if(ep==5){fprintf(stderr,"ep %d val %d \n",ep,!(ep !=0 && ep<dim));}*/
  if(!(ru<=(dim*(dim-1))/2)){return 0;}
  if(!(ep !=0 && ep<dim)){return 0;}
  return is_correct_problem(dim, du, ne);
}
int nb_elt(int *l){
  int s=0;
  do{s++;
  }while(l[s]!=0);
  return s;
}
int get_real_value(int dim,int min,int_to_int_func f,int ind){
  int max=f(dim);
  int res= (min+((int) (ind*(max-min)/100)));
  return res;
}
typedef struct  WModel WModel;
/*Count total number of problem based on the number of layer*their range*/
int compute_number_of_functions(WModel *wm,int dimension){
    int dim=dimension;
    int i;
    int * dummy=IOHprofiler_allocate_int_vector(nb_elt(wm->layer1));
    for(i=0;i<nb_elt(wm->layer1);i++){dummy[i]=get_real_value(dimension,wm->min1,wm->l_max1,wm->layer1[i]);}
    int * neutr=IOHprofiler_allocate_int_vector(nb_elt(wm->layer2));
    for(i=0;i<nb_elt(wm->layer2);i++){neutr[i]=get_real_value(dimension,wm->min2,wm->l_max2,wm->layer2[i]);}
    int * epis=IOHprofiler_allocate_int_vector(nb_elt(wm->layer3));
    for(i=0;i<nb_elt(wm->layer3);i++){epis[i]=get_real_value(dimension,wm->min3,wm->l_max3,wm->layer3[i]);}
    int * rugg=IOHprofiler_allocate_int_vector(nb_elt(wm->layer4));
    for(i=0;i<nb_elt(wm->layer4);i++){rugg[i]=get_real_value(dimension,wm->min4,wm->l_max4,wm->layer4[i]);}
    int b,c,d,e,sum,temp;
    sum=0;
    c=0;
    b=0;
    temp=0;
    d=nb_elt(wm->layer3);
    e=nb_elt(wm->layer4);
    do{c=0;
      do{
        temp+=is_correct_problem(dim,wm->layer1[b],wm->layer2[c]);
        c++;
      }while(c <nb_elt(wm->layer2));
      b++;
    }while(b<nb_elt(wm->layer1));
    sum+=temp*d*e;
/*    fprintf(stderr,"\n-------- dim %d sum %d ---------\n",dim,sum);*/
/*
for(i=0;i<nb_elt(wm->layer1);i++){fprintf(stderr," %d ",dummy[i]);}
fprintf(stderr,"\n");
for(i=0;i<nb_elt(wm->layer2);i++){fprintf(stderr," %d ",neutr[i]);}
fprintf(stderr,"\n");
for(i=0;i<nb_elt(wm->layer3);i++){fprintf(stderr," %d ",epis[i]);}
fprintf(stderr,"\n");
for(i=0;i<nb_elt(wm->layer4);i++){fprintf(stderr," %d ",rugg[i]);}
fprintf(stderr,"\nsum %d\n",sum);*/
    IOHprofiler_free_memory(dummy);
    IOHprofiler_free_memory(neutr);
    IOHprofiler_free_memory(epis);
    IOHprofiler_free_memory(rugg);
    return sum;
}



int * get_WModel_parameters(WModel* wm){

  int *res=IOHprofiler_allocate_int_vector(wm->number_of_layers);
  res[0]=wm->layer1[wm->counter[0]];
  res[1]=wm->layer2[wm->counter[1]];
  res[2]=wm->layer3[wm->counter[2]];
  if(wm->counter[3] >=0){
    res[3]=wm->layer4[wm->counter[3]];
  }else {res[3]=0;}
  return res;
}
int * get_real_parameters(int dim,WModel * wm){
  int * p=get_WModel_parameters(wm);
  int *res=IOHprofiler_allocate_int_vector(wm->number_of_layers);
  res[0]=get_real_value(dim,wm->min1,wm->l_max1,p[0]);
  res[1]=get_real_value(dim,wm->min2,wm->l_max2,p[1]);
  res[2]=get_real_value(dim,wm->min3,wm->l_max3,p[2]);
  res[3]=get_real_value(dim,wm->min4,wm->l_max4,p[3]);
  IOHprofiler_free_memory(p);
  return res;
}
static int * get_layers_parameters(void);
void increment_layers_param(WModel * wm,int dim){
int * temp1,temp2;
int x=0;


/*-----------------------------------------------*/
  if (wm->counter[3]<nb_elt(wm->layer4)-1){
    wm->counter[3]++;
  }else if(wm->counter[3]==nb_elt(wm->layer4)-1){
    wm->counter[3]=0;
    if (wm->counter[2]<nb_elt(wm->layer3)-1){
      wm->counter[2]++;
    }else if(wm->counter[2]==nb_elt(wm->layer3)-1){
     wm->counter[2]=0;
     if (wm->counter[1]<nb_elt(wm->layer2)-1){
       wm->counter[1]++;
      }else if(wm->counter[1]==nb_elt(wm->layer2)-1){
        wm->counter[1]=0;
        if (wm->counter[0]<nb_elt(wm->layer1)-1){
          wm->counter[0]++;
        }else if(wm->counter[0]==nb_elt(wm->layer1)-1){
          wm->counter[0]=0;
        }
      }
    }
  }
  int * r=get_real_parameters(dim,wm);
  int * r2=get_WModel_parameters(wm);
  if(!valid(dim, r2[0],r2[1],r[2],r[3]))
    {  IOHprofiler_free_memory(r);IOHprofiler_free_memory(r2);
       increment_layers_param(wm, dim);}
  else{IOHprofiler_free_memory(r);IOHprofiler_free_memory(r2);}
  r=get_WModel_parameters(wm);
  int i;
  for(i=0;i<4;i++){layer_para[i]=r[i];}
  IOHprofiler_free_memory(r);

}



char* get_name_problem(int id_problem, struct WModel * wm){
  int * para;
  char *name;
  para=get_WModel_parameters(wm);
  name=malloc(sizeof(char)*100);
    
/*  if(id_problem==1){
/*    sprintf(name, "one_max_dummy=%d_mu=%d_nu=%d_gamma=%d",layer_para[0],layer_para[1],layer_para[2],layer_para[3]);*/
    sprintf(name, "one_max_D%d_N%d_E%d_R%d",para[0],para[1],para[2],para[3]);
/*  }*/
  IOHprofiler_free_memory(para);
  return name;
}
char* get_name_problem2(int id_problem, int * para){
  char *name;
  name=malloc(sizeof(char)*100);
    
/*  if(id_problem==1){
/*    sprintf(name, "one_max_dummy=%d_mu=%d_nu=%d_gamma=%d",layer_para[0],layer_para[1],layer_para[2],layer_para[3]);*/
    sprintf(name, "one_max_D%d_N%d_E%d_R%d",para[0],para[1],para[2],para[3]);
/*  }*/
  return name;
}
/*old*//*
void incr(int ind){
  if(ind>0){
  size_t * p;
  p=IOHprofiler_string_parse_ranges(layer_parameters[layer_number-ind], 0, 0, "layer_parameter", MAX_PARAMETER);
  if (number_of_op(p)> (layer_para[layer_number-ind]+1)){
    layer_para[layer_number-ind]++;
  }else if(number_of_op(p)==(layer_para[layer_number-ind]+1)){
    layer_para[layer_number-ind]=0;
    incr(ind-1);
  }
  IOHprofiler_free_memory(p);
  }
}*/
/*old*//*
void incr_layer_para(void){
  int i;
  i=layer_number;
  incr(i);
}*/

static int * get_layers_parameters(void){
  int n_l=4;
  int * layer_values=IOHprofiler_allocate_int_vector(n_l);
  int i;

  for (i=0;i<n_l;i++){layer_values[i]=layer_para[i];}
  return layer_values;
}
/*
calcule la dimension du problem après les features du W-Model
casse un peu la modularité
*/

/*old*/

int compute_problem_get_dimension(int dim){
  int *p;
  p=get_layers_parameters();
  int output_dim =dim+1;
  if(p[0]>dim){return 0;}
  output_dim = output_dim- (int)(p[0]);
  if(p[1]>0 && p[1]<output_dim){
    output_dim=output_dim/ (p[1]);
/*  printf(".%d  %d %d\n",output_dim,p[1],output_dim/ (p[1]));*/
  }else if(p[1]<0 || p[1]>=output_dim){ return 0;}
  else if(p[2]>output_dim){return 0;}
  else if(p[3]>((output_dim-1)*(output_dim)/2)){return 0;}

/*  printf("%d  %d %d\n",p[0],p[1],output_dim);*/
  return output_dim;
}
/*old*/
/*Return a string of the layers parameters "k=a_mu=b_nu=c_gamma=d"*/
void get_name(int id_problem,char *name){
  int * para;
  para=get_layers_parameters();
  if(id_problem==1){
/*    sprintf(name, "one_max_dummy=%d_mu=%d_nu=%d_gamma=%d",layer_para[0],layer_para[1],layer_para[2],layer_para[3]);*/
    sprintf(name, "one_max_D%d_N%d_E%d_R%d",para[0],para[1],para[2],para[3]);
  }
  IOHprofiler_free_memory(para);
}

/*
 my own parser because at least it will work
*/
char * extract_number(char *l){
  char * res= IOHprofiler_allocate_memory(BUFF * sizeof(char *));
  if (strlen(l)==0 || l == NULL){
    res[0]=0;
  return res;
  }
  int i =0;
  while(isdigit(l[i])){
    res[i]=l[i];
    i+=1;
  }
  res[i]='\0';
  return res;
}
int* parse_range_layer(char * l){
  int i,j;
  int current_free_space=BUFF;
  int realloc=1;
  int nb_elt=0;
  int a,b,c;
  int * res= IOHprofiler_allocate_int_vector(BUFF);
  i=0;
  char * int_temp1;
  char * int_temp2;
  if (strlen(l)==0 || l == NULL){
    res[0]=0;
  return res;
  }
  while(i<=strlen(l) && l[i]!='\0'){
    if(isdigit(l[i])){
      int_temp1=extract_number(l+i);
      i+=strlen(int_temp1);
      if(l[i]=='\0'){
        if (current_free_space<=1){
         realloc+=1;
         res=copy_and_realloc(res,nb_elt,realloc*BUFF);
         current_free_space+=BUFF;
        }
        current_free_space-=1;
        res[nb_elt] = atoi((char*) int_temp1);
        nb_elt+=1;
        IOHprofiler_free_memory(int_temp1);
        i+=2;
      }else if(l[i]==','){
        if (current_free_space<=1){
         realloc+=1;
         res=copy_and_realloc(res,nb_elt,realloc*BUFF);
         current_free_space+=BUFF;
        }
        current_free_space-=1;
        res[nb_elt] = atoi((char*) int_temp1);
        nb_elt+=1;
        IOHprofiler_free_memory(int_temp1);
        i+=1;
      }else if(l[i]=='-'){
        i+=1;
        int_temp2=extract_number(l+i);
        i+=strlen(int_temp2);
        a=atoi(int_temp1);
        b=atoi(int_temp2);
        IOHprofiler_free_memory(int_temp1);
        IOHprofiler_free_memory(int_temp2);
        if(b<=a){IOHprofiler_error("parse layers wrong parameter1");}
        c=b-a;
        while (current_free_space<=c+1){
         realloc+=1;
         res=copy_and_realloc(res,nb_elt,realloc*BUFF);
         current_free_space+=BUFF;
        }
        for(j=0;j<=c;j++){
          res[nb_elt] = a+j;
          nb_elt+=1;
          current_free_space-=1;
        }if(l[i]!=',' && l[i]!='\0'){IOHprofiler_error("parse layers wrong parameter1");}
        i+=1;
      }
    }else{IOHprofiler_error("parse layers wrong parameter2");}
  }
  res[nb_elt]=0;
/*  for(i=0;i<=nb_elt;i++){
  fprintf(stderr,"\%d  ",res[i]);
} fprintf(stderr,"\n");*/
  return res;
}
int * copy_and_realloc(const int *src, const size_t number_of_elements,int new_size) {
    size_t i;
    int *dst;

    assert(src != NULL);
    assert(new_size > 0);

    dst = IOHprofiler_allocate_int_vector(new_size);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }IOHprofiler_free_memory(src);
    return dst;
}

#endif
#line 12 "code-experiments/src/profiler/../suite/WModel/suite_WModel.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/WModel_struct.h"
#ifndef WMODEL_STRUCT
#define WMODEL_STRUCT

/**
 * @brief Data type for transform_vars_dummy.
 */
typedef struct {
  int *offset;
  int *reduncted_x;
  int *postion_match;
  IOHprofiler_problem_free_function_t old_free_problem;
} dummy_random_data_t;

/**
 * @brief Data type for transform_vars_epistasis.
 */
typedef struct {
  int *offset;
  int *epistasis_x;/*result of the epistasis transformation */
  IOHprofiler_problem_free_function_t old_free_problem;
} epistasis_data_t;

/**
 * @brief Data type for transform_vars_neutrality.
 */
typedef struct {
  int *offset;
  int *neutrality_x;
  IOHprofiler_problem_free_function_t old_free_problem;
} neutrality_data_t;


typedef struct {
  double offset;
} ruggedness_data_t;

typedef struct {
  dummy_random_data_t *data1;
  neutrality_data_t *data2;
  epistasis_data_t *data3;
  ruggedness_data_t *data4;
  int * parameters;
  int number_of_layer;
  int old_dim;
} WModel_data_t;

#endif
#line 13 "code-experiments/src/profiler/../suite/WModel/suite_WModel.c"

void WModel_struct_free(struct WModel * wm){
  if(wm!=NULL){
  IOHprofiler_free_memory(wm->layer1);
  IOHprofiler_free_memory(wm->layer2);
  IOHprofiler_free_memory(wm->layer3);
  IOHprofiler_free_memory(wm->layer4);
  IOHprofiler_free_memory(wm->counter);
  
  }
}

/**
* filter layers for the WModel
*
*
static void IOHprofiler_suite_filter_layers(size_t *layer, const size_t *layer_numbers) {
    size_t i, j;
    size_t count = IOHprofiler_count_numbers(layer_numbers, IOHprofiler_MAX_INSTANCES, "layers_WModel");
    int found;

    for (i = 0; i < suite->number_of_dimensions; i++) {
        found = 0;
        for (j = 0; j < count; j++) {
            if (layer[i] == dimension_numbers[j])
                found = 1;
        }
        if (!found)
            layer[i] = 0;
    }
}*/
static IOHprofiler_suite_t *IOHprofiler_suite_allocate(const char *suite_name,
                                                       const size_t number_of_functions,
                                                       const size_t number_of_dimensions,
                                                       const size_t *dimensions,
                                                       const char *default_instances);

/**
 * @brief Sets the dimensions and default instances for the IOHprofiler suite.
 */
 int range_to_n(int dim){return dim;}
int range_to_nsquare_div2(int dim){return (dim*(dim-1))/2;}


static IOHprofiler_suite_t *suite_WModel_initialize(int number,char **layer_param,char* dim) {
    /*old*/
/*    init_parameters(number,layer_param);*/
    /*---*/

    IOHprofiler_suite_t *suite;
    size_t i;
    const char *suite_name = "WModel";

    size_t dimension[20000];
    int * temp_dim=parse_range_layer(dim);

    struct WModel * wm = (struct WModel *)IOHprofiler_allocate_memory(sizeof(struct WModel));
    wm->number_of_layers=number;
    wm->layer1=parse_range_layer(layer_param[0]);
    wm->min1=0;
    wm->l_max1=&range_to_n;
    wm->layer2=parse_range_layer(layer_param[1]);
    wm->min2=1;
    wm->l_max2=&range_to_n;
    wm->layer3=parse_range_layer(layer_param[2]);
    wm->min3=1;
    wm->l_max3=&range_to_n;
    wm->layer4=parse_range_layer(layer_param[3]);
    wm->min4=0;
    wm->l_max4=&range_to_nsquare_div2;

    int * counter=IOHprofiler_allocate_int_vector(number);
    for(i=0;i<number;i++){counter[i]=0;}
    counter[number-1]=0;
    wm->counter=counter;

    const size_t number_of_dimension = sizeof(dimension) / sizeof(dimension[0]);
    for (i = 0; i < number_of_dimension; ++i){
        dimension[i] = i + 1;
    }
    const size_t number_of_functions=(size_t) compute_number_of_functions(wm, temp_dim[0]);
    fprintf(stderr,"--------%d------------\n",number_of_functions);
    /* IMPORTANT: Make sure to change the default instance for every new workshop! */
    suite = IOHprofiler_suite_allocate(suite_name, number_of_functions, number_of_dimension, dimension, "year: 2019");
    
    suite->data =wm;
    suite->data_free_function = WModel_struct_free;
    IOHprofiler_free_memory(temp_dim);
    return suite;

}

/**
 * @brief Sets the instances associated with years for the IOHprofiler suite.
 */
static const char *suite_WModel_get_instances_by_year(const int year) {
    if (year == 2018) {
        return "1-100";
    } else {
        IOHprofiler_error("suite_WModel_get_instances_by_year(): year %d not defined for suite_IOHprofiler", year);
        return NULL;
    }
}

/**
 * @brief Creates and returns a IOHprofiler problem without needing the actual IOHprofiler suite.
 *
 * Useful for other suites as well (see for example suite_biobj.c).
 */

static IOHprofiler_problem_t *WModel_get_problem(const size_t function,
                                              const size_t dimension,
                                              const size_t instance,struct WModel* wm) {
    IOHprofiler_problem_t *problem = NULL;
    char *name;
    name =get_name_problem(id_problem,wm);

    const char *problem_id_template;
    problem_id_template=IOHprofiler_allocate_string(strlen(name)+1);
    strcpy(problem_id_template,name);
    free(name);

    const char *problem_name_template = "WModel suite problem f%lu instance %lu in %luD";

    const long rseed = (long)(function + 10000 * instance);

    int * para;
    para=get_real_parameters(dimension,wm);
    problem = f_IOHprofiler_problem_allocate(function, dimension, instance, rseed,
                                                         problem_id_template, problem_name_template,para,wm->number_of_layers);
    if(problem==NULL){
      IOHprofiler_error("get_IOHprofiler_problem(): cannot retrieve problem f%lu instance %lu in %luD",
                          (unsigned long)function, (unsigned long)instance, (unsigned long)dimension);
        return NULL; /* Never reached */
    }
    return problem;
}

/**
 * @brief Returns the problem from the IOHprofiler suite that corresponds to the given parameters.
 *
 * @param suite The IOHprofiler suite.
 * @param function_idx Index of the function (starting from 0).
 * @param dimension_idx Index of the dimension (starting from 0).
 * @param instance_idx Index of the instance (starting from 0).
 * @return The problem that corresponds to the given parameters.
 */
static IOHprofiler_problem_t *suite_WModel_get_problem(IOHprofiler_suite_t *suite,
                                                    const size_t function_idx,
                                                    const size_t dimension_idx,
                                                    const size_t instance_idx) {
    IOHprofiler_problem_t *problem = NULL;

/*delete later
    int *l;
    l=get_layers_parameters();
    fprintf(stderr,"parameter : dummy:%d neutrality:%d epistasis:%d ruggedness:%d\n",*l,*(l+1),*(l+2),*(l+3));
    free(l);
*/


    const size_t function = suite->functions[function_idx];
    const size_t dimension = suite->dimensions[dimension_idx];
    const size_t instance = suite->instances[instance_idx];
    problem = WModel_get_problem(function, dimension, instance,(struct WModel *)suite->data);
   
    problem->suite_dep_function = function;
    problem->suite_dep_instance = instance;
    problem->suite_dep_index = IOHprofiler_suite_encode_problem_index(suite, function_idx, dimension_idx, instance_idx);

    return problem;
}
#endif
#line 22 "code-experiments/src/profiler/IOHprofiler_suite.c"

/** @brief The maximum number of different instances in a suite. */
#define IOHprofiler_MAX_INSTANCES 1000
#define MIN_DIMENSION 4

/**
 * @brief Calls the initializer of the given suite.
 *
 * @note This function needs to be updated when a new suite is added to IOHprofiler.
 */
static IOHprofiler_suite_t *IOHprofiler_suite_initialize(const char *suite_name,int number,char **layer_param,char * temp_dim) {
    IOHprofiler_suite_t *suite;
    if (strcmp(suite_name, "PBO") == 0) {
        suite = suite_PBO_initialize();
    }else if (strcmp(suite_name, "WModel") == 0) {
        suite = suite_WModel_initialize(number,layer_param,temp_dim);
    } else {
        IOHprofiler_error("IOHprofiler_suite_initialize(): unknown problem suite");
        return NULL;
    }

    return suite;
}

/**
 * @brief Calls the function that sets the instanced by year for the given suite.
 * @note This function needs to be updated when a new suite is added to IOHprofiler.
 */
static const char *IOHprofiler_suite_get_instances_by_year(const IOHprofiler_suite_t *suite, const int year) {
    const char *year_string;

    if (strcmp(suite->suite_name, "PBO") == 0) {
        year_string = suite_PBO_get_instances_by_year(year);
    }if (strcmp(suite->suite_name, "WModel") == 0) {
        year_string = suite_WModel_get_instances_by_year(year);
    } else {
        IOHprofiler_error("IOHprofiler_suite_get_instances_by_year(): suite '%s' has no years defined", suite->suite_name);
        return NULL;
    }

    return year_string;
}

/**
 * @brief Calls the function that returns the problem corresponding to the given suite, function index,
 * dimension index and instance index. If the indices don't correspond to a problem because of suite
 * filtering, it returns NULL.
 *
 * @note This function needs to be updated when a new suite is added to IOHprofiler.
 */
static IOHprofiler_problem_t *IOHprofiler_suite_get_problem_from_indices(IOHprofiler_suite_t *suite,
                                                                         const size_t function_idx,
                                                                         const size_t dimension_idx,
                                                                         const size_t instance_idx) {
    IOHprofiler_problem_t *problem;

    if ((suite->functions[function_idx] == 0) ||
        (suite->dimensions[dimension_idx] == 0)) {
        return NULL;
    }

    if (strcmp(suite->suite_name, "PBO") == 0) {
        problem = suite_PBO_get_problem(suite, function_idx, dimension_idx, instance_idx);
    }else if (strcmp(suite->suite_name, "WModel") == 0) {
        problem = suite_WModel_get_problem(suite, function_idx, dimension_idx, instance_idx);
    } else {
        IOHprofiler_error("IOHprofiler_suite_get_problem_from_indices(): unknown problem suite");
        return NULL;
    }
     

    IOHprofiler_problem_set_suite(problem, suite);

    return problem;
}

/**
 * @note: While a suite can contain multiple problems with equal function, dimension and instance, this
 * function always returns the first problem in the suite with the given function, dimension and instance
 * values. If the given values don't correspond to a problem, the function returns NULL.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_problem_by_function_dimension_instance(IOHprofiler_suite_t *suite,
                                                                                    const size_t function,
                                                                                    const size_t dimension,
                                                                                    const size_t instance) {
    size_t i;
    int function_idx, dimension_idx, instance_idx;
    int found;

    found = 0;
    for (i = 0; i < suite->number_of_functions; i++) {
        if (suite->functions[i] == function) {
            function_idx = (int)i;
            found = 1;
            break;
        }
    }
    if (!found)
        return NULL;

    found = 0;
    for (i = 0; i < suite->number_of_dimensions; i++) {
        if (suite->dimensions[i] == dimension) {
            dimension_idx = (int)i;
            found = 1;
            break;
        }
    }
    if (!found)
        return NULL;

    found = 0;
    for (i = 0; i < suite->number_of_instances; i++) {
        if (suite->instances[i] == instance) {
            instance_idx = (int)i;
            found = 1;
            break;
        }
    }
    if (!found)
        return NULL;

    return IOHprofiler_suite_get_problem_from_indices(suite, (size_t)function_idx, (size_t)dimension_idx, (size_t)instance_idx);
}

/**
 * @brief Allocates the space for a IOHprofiler_suite_t instance.
 *
 * This function sets the functions and dimensions contained in the suite, while the instances are set by
 * the function IOHprofiler_suite_set_instance.
 */
static IOHprofiler_suite_t *IOHprofiler_suite_allocate(const char *suite_name,
                                                       const size_t number_of_functions,
                                                       const size_t number_of_dimensions,
                                                       const size_t *dimensions,
                                                       const char *default_instances) {
    IOHprofiler_suite_t *suite;
    size_t i;

    suite = (IOHprofiler_suite_t *)IOHprofiler_allocate_memory(sizeof(*suite));

    suite->suite_name = IOHprofiler_strdup(suite_name);

    suite->number_of_dimensions = number_of_dimensions;
    assert(number_of_dimensions > 0);
    suite->dimensions = IOHprofiler_allocate_vector_size_t(suite->number_of_dimensions);
    for (i = 0; i < suite->number_of_dimensions; i++) {
        suite->dimensions[i] = dimensions[i];
    }

    suite->number_of_functions = number_of_functions;
    assert(number_of_functions > 0);
    suite->functions = IOHprofiler_allocate_vector_size_t(suite->number_of_functions);
    for (i = 0; i < suite->number_of_functions; i++) {
        suite->functions[i] = i + 1;
    }

    assert(strlen(default_instances) > 0);
    suite->default_instances = IOHprofiler_strdup(default_instances);

    /* Will be set to the first valid dimension index before the constructor ends */
    suite->current_dimension_idx = -1;
    /* Will be set to the first valid function index before the constructor ends  */
    suite->current_function_idx = -1;

    suite->current_instance_idx = -1;
    suite->current_problem = NULL;

    /* To be set in IOHprofiler_suite_set_instance() */
    suite->number_of_instances = 0;
    suite->instances = NULL;

    /* To be set in particular suites if needed */
    suite->data = NULL;
    suite->data_free_function = NULL;

    return suite;
}

/**
 * @brief Sets the suite instance to the given instance_numbers.
 */
static void IOHprofiler_suite_set_instance(IOHprofiler_suite_t *suite,
                                           const size_t *instance_numbers) {
    size_t i;

    if (!instance_numbers) {
        IOHprofiler_error("IOHprofiler_suite_set_instance(): no instance given");
        return;
    }

    suite->number_of_instances = IOHprofiler_count_numbers(instance_numbers, IOHprofiler_MAX_INSTANCES, "suite instance numbers");
    suite->instances = IOHprofiler_allocate_vector_size_t(suite->number_of_instances);
    for (i = 0; i < suite->number_of_instances; i++) {
        suite->instances[i] = instance_numbers[i];
    }
}

/**
 * @brief Filters the given items w.r.t. the given indices (starting from 1).
 *
 * Sets items[i - 1] to 0 for every i that cannot be found in indices (this function performs the conversion
 * from user-friendly indices starting from 1 to C-friendly indices starting from 0).
 */
static void IOHprofiler_suite_filter_indices(size_t *items, const size_t number_of_items, const size_t *indices, const char *name) {
    size_t i, j;
    size_t count = IOHprofiler_count_numbers(indices, IOHprofiler_MAX_INSTANCES, name);
    int found;

    for (i = 1; i <= number_of_items; i++) {
        found = 0;
        for (j = 0; j < count; j++) {
            if (i == indices[j]) {
                found = 1;
                break;
            }
        }
        if (!found)
            items[i - 1] = 0;
    }
}

/**
 * @brief Filters dimensions w.r.t. the given dimension_numbers.
 *
 * Sets suite->dimensions[i] to 0 for every dimension value that cannot be found in dimension_numbers.
 */
static void IOHprofiler_suite_filter_dimensions(IOHprofiler_suite_t *suite, const size_t *dimension_numbers) {
    size_t i, j;
    size_t count = IOHprofiler_count_numbers(dimension_numbers, IOHprofiler_MAX_INSTANCES, "dimensions");
    int found;

    for (i = 0; i < suite->number_of_dimensions; i++) {
        found = 0;
        for (j = 0; j < count; j++) {
            if (suite->dimensions[i] == dimension_numbers[j])
                found = 1;
        }
        if (!found)
            suite->dimensions[i] = 0;
    }
}


/**
 * @param suite The given suite.
 * @param function_idx The index of the function in question (starting from 0).
 *
 * @return The function number in position function_idx in the suite. If the function has been filtered out
 * through suite_options in the IOHprofiler_suite function, the result is 0.
 */
size_t IOHprofiler_suite_get_function_from_function_index(const IOHprofiler_suite_t *suite, const size_t function_idx) {
    if (function_idx >= suite->number_of_functions) {
        IOHprofiler_error("IOHprofiler_suite_get_function_from_function_index(): function index exceeding the number of functions in the suite");
        return 0; /* Never reached*/
    }

    return suite->functions[function_idx];
}

/**
 * @param suite The given suite.
 * @param dimension_idx The index of the dimension in question (starting from 0).
 *
 * @return The dimension number in position dimension_idx in the suite. If the dimension has been filtered out
 * through suite_options in the IOHprofiler_suite function, the result is 0.
 */
size_t IOHprofiler_suite_get_dimension_from_dimension_index(const IOHprofiler_suite_t *suite, const size_t dimension_idx) {
    if (dimension_idx >= suite->number_of_dimensions) {
        IOHprofiler_error("IOHprofiler_suite_get_dimension_from_dimension_index(): dimensions index exceeding the number of dimensions in the suite");
        return 0; /* Never reached*/
    }

    return suite->dimensions[dimension_idx];
}

/**
 * @param suite The given suite.
 * @param instance_idx The index of the instance in question (starting from 0).
 *
 * @return The instance number in position instance_idx in the suite. If the instance has been filtered out
 * through suite_options in the IOHprofiler_suite function, the result is 0.
 */
size_t IOHprofiler_suite_get_instance_from_instance_index(const IOHprofiler_suite_t *suite, const size_t instance_idx) {
    if (instance_idx >= suite->number_of_instances) {
        IOHprofiler_error("IOHprofiler_suite_get_instance_from_instance_index(): instance index exceeding the number of instances in the suite");
        return 0; /* Never reached*/
    }

    return suite->functions[instance_idx];
}

void IOHprofiler_suite_free(IOHprofiler_suite_t *suite) {
    if (suite != NULL) {
        if (suite->suite_name) {
            IOHprofiler_free_memory(suite->suite_name);
            suite->suite_name = NULL;
        }
        if (suite->dimensions) {
            IOHprofiler_free_memory(suite->dimensions);
            suite->dimensions = NULL;
        }
        if (suite->functions) {
            IOHprofiler_free_memory(suite->functions);
            suite->functions = NULL;
        }
        if (suite->instances) {
            IOHprofiler_free_memory(suite->instances);
            suite->instances = NULL;
        }
        if (suite->default_instances) {
            IOHprofiler_free_memory(suite->default_instances);
            suite->default_instances = NULL;
        }

        if (suite->current_problem) {
            IOHprofiler_problem_free(suite->current_problem);
            suite->current_problem = NULL;
        }

        if (suite->data != NULL) {
            if (suite->data_free_function != NULL) {
                suite->data_free_function(suite->data);
            }
            IOHprofiler_free_memory(suite->data);
            suite->data = NULL;
        }

        IOHprofiler_free_memory(suite);
        suite = NULL;
    }
}

/**
 * Note that the problem_index depends on the number of instances a suite is defined with.
 *
 * @param suite The given suite.
 * @param problem_index The index of the problem to be returned.
 *
 * @return The problem of the suite defined by problem_index (NULL if this problem has been filtered out
 * from the suite).
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_problem(IOHprofiler_suite_t *suite, const size_t problem_index) {
    size_t function_idx = 0, instance_idx = 0, dimension_idx = 0;
    IOHprofiler_suite_decode_problem_index(suite, problem_index, &function_idx, &dimension_idx, &instance_idx);

    return IOHprofiler_suite_get_problem_from_indices(suite, function_idx, dimension_idx, instance_idx);
}

/**
 * The number of problems in the suite is computed as a product of the number of instances, number of
 * functions and number of dimensions and therefore doesn't account for any filtering done through the
 * suite_options parameter of the IOHprofiler_suite function.
 *
 * @param suite The given suite.
 *
 * @return The number of problems in the suite.
 */
size_t IOHprofiler_suite_get_number_of_problems(const IOHprofiler_suite_t *suite) {
    return (suite->number_of_instances * suite->number_of_functions * suite->number_of_dimensions);
}

/**
 * @brief Returns the instances read from either a "year: YEAR" or "instances: NUMBERS" string.
 *
 * If both "year" and "instances" are given, the second is ignored (and a warning is raised). See the
 * IOHprofiler_suite function for more information about the required format.
 */
static size_t *IOHprofiler_suite_get_instance_indices(const IOHprofiler_suite_t *suite, const char *suite_instance) {
    int year = -1;
    char *instances = NULL;
    const char *year_string = NULL;
    long year_found, instances_found;
    int parce_year = 1, parce_instances = 1;
    size_t *result = NULL;

    if (suite_instance == NULL)
        return NULL;

    year_found = IOHprofiler_strfind(suite_instance, "year");
    instances_found = IOHprofiler_strfind(suite_instance, "instances");

    if ((year_found < 0) && (instances_found < 0))
        return NULL;

    if ((year_found > 0) && (instances_found > 0)) {
        if (year_found < instances_found) {
            parce_instances = 0;
            IOHprofiler_warning("IOHprofiler_suite_get_instance_indices(): 'instances' suite option ignored because it follows 'year'");
        } else {
            parce_year = 0;
            IOHprofiler_warning("IOHprofiler_suite_get_instance_indices(): 'year' suite option ignored because it follows 'instances'");
        }
    }

    if ((year_found >= 0) && (parce_year == 1)) {
        if (IOHprofiler_options_read_int(suite_instance, "year", &(year)) != 0) {
            year_string = IOHprofiler_suite_get_instances_by_year(suite, year);
            result = IOHprofiler_string_parse_ranges(year_string, 1, 0, "instances", IOHprofiler_MAX_INSTANCES);
        } else {
            IOHprofiler_warning("IOHprofiler_suite_get_instance_indices(): problems parsing the 'year' suite_instance option, ignored");
        }
    }

    instances = IOHprofiler_allocate_string(IOHprofiler_MAX_INSTANCES);
    if ((instances_found >= 0) && (parce_instances == 1)) {
        if (IOHprofiler_options_read_values(suite_instance, "instances", instances) > 0) {
            result = IOHprofiler_string_parse_ranges(instances, 1, 0, "instances", IOHprofiler_MAX_INSTANCES);
        } else {
            IOHprofiler_warning("IOHprofiler_suite_get_instance_indices(): problems parsing the 'instance' suite_instance option, ignored");
        }
    }
    IOHprofiler_free_memory(instances);

    return result;
}

/**
 * @brief Iterates through the items from the current_item_id position on in search for the next positive
 * item.
 *
 * If such an item is found, current_item_id points to this item and the method returns 1. If such an
 * item cannot be found, current_item_id points to the first positive item and the method returns 0.
 */
static int IOHprofiler_suite_is_next_item_found(const size_t *items, const size_t number_of_items, long *current_item_id) {
    if ((*current_item_id) != number_of_items - 1) {
        /* Not the last item, iterate through items */
        do {
            (*current_item_id)++;
        } while (((*current_item_id) < number_of_items - 1) && (items[*current_item_id] == 0));

        assert((*current_item_id) < number_of_items);
        if (items[*current_item_id] != 0) {
            /* Next item is found, return true */
            return 1;
        }
    }

    /* Next item cannot be found, move to the first good item and return false */
    *current_item_id = -1;
    do {
        (*current_item_id)++;
    } while ((*current_item_id < number_of_items - 1) && (items[*current_item_id] == 0));
    if (items[*current_item_id] == 0)
        IOHprofiler_error("IOHprofiler_suite_is_next_item_found(): the chosen suite has no valid (positive) items");
    return 0;
}

/**
 * @brief Iterates through the instances of the given suite from the current_instance_idx position on in
 * search for the next positive instance.
 *
 * If such an instance is found, current_instance_idx points to this instance and the method returns 1. If
 * such an instance cannot be found, current_instance_idx points to the first positive instance and the
 * method returns 0.
 */
static int IOHprofiler_suite_is_next_instance_found(IOHprofiler_suite_t *suite) {
    return IOHprofiler_suite_is_next_item_found(suite->instances, suite->number_of_instances,
                                                &suite->current_instance_idx);
}

/**
 * @brief Iterates through the functions of the given suite from the current_function_idx position on in
 * search for the next positive function.
 *
 * If such a function is found, current_function_idx points to this function and the method returns 1. If
 * such a function cannot be found, current_function_idx points to the first positive function,
 * current_instance_idx points to the first positive instance and the method returns 0.
 */
static int IOHprofiler_suite_is_next_function_found(IOHprofiler_suite_t *suite) {
    int result = IOHprofiler_suite_is_next_item_found(suite->functions, suite->number_of_functions,
                                                      &suite->current_function_idx);
    if (!result) {
        /* Reset the instances */
        suite->current_instance_idx = -1;
        IOHprofiler_suite_is_next_instance_found(suite);
    }
    return result;
}

/**
 * @brief Iterates through the dimensions of the given suite from the current_dimension_idx position on in
 * search for the next positive dimension.
 *
 * If such a dimension is found, current_dimension_idx points to this dimension and the method returns 1. If
 * such a dimension cannot be found, current_dimension_idx points to the first positive dimension and the
 * method returns 0.
 */
static int IOHprofiler_suite_is_next_dimension_found(IOHprofiler_suite_t *suite) {
    return IOHprofiler_suite_is_next_item_found(suite->dimensions, suite->number_of_dimensions,
                                                &suite->current_dimension_idx);
}

/**
 * Currently, five suites are supported:
 * - "IOHprofiler" contains 5 single-objective functions in 6 dimensions (500,1000,1500,2000,2500,3000)
 *
 * Only the suite_name parameter needs to be non-empty. The suite_instance and suite_options can be "" or
 * NULL. In this case, default values are taken (default instances of a suite are those used in the last year
 * and the suite is not filtered by default).
 *
 * @param suite_name A string containing the name of the suite. Currently supported suite name is "IOHprofiler".
 * @param suite_instance A string used for defining the suite instances. Two ways are supported:
 * - "year: TODO: definition of classification of instances.
 * - "instances: VALUES", where VALUES are instance numbers from 1 on written as a comma-separated list or a
 * range m-n.
 * @param suite_options A string of pairs "key: value" used to filter the suite (especially useful for
 * parallelizing the experiments). Supported options:
 * - "dimensions: LIST", where LIST is the list of dimensions to keep in the suite (range-style syntax is
 * not allowed here),
 * - "dimension_indices: VALUES", where VALUES is a list or a range of dimension indices (starting from 1) to keep
 * in the suite, and
 * - "function_indices: VALUES", where VALUES is a list or a range of function indices (starting from 1) to keep
 * in the suite, and
 * - "instance_indices: VALUES", where VALUES is a list or a range of instance indices (starting from 1) to keep
 * in the suite.
 *
 * @return The constructed suite object.
 */
IOHprofiler_suite_t *IOHprofiler_suite(const char *suite_name, const char *suite_instance, const char *suite_options,int number,char **layer_param,char * temp_dim) {
    IOHprofiler_suite_t *suite;
    size_t *instances;
    char *option_string = NULL;
    char *ptr;
    size_t *indices = NULL;
    size_t *dimensions = NULL;
    long dim_found, dim_idx_found;
    int parce_dim = 1, parce_dim_idx = 1;

    IOHprofiler_option_keys_t *known_option_keys, *given_option_keys, *redundant_option_keys;

    /* Sets the valid keys for suite options and suite instance */
    const char *known_keys_o[] = { "dimensions", "dimension_indices", "function_indices", "instance_indices" };
    const char *known_keys_i[] = { "year", "instances" };

    /* Initialize the suite */
    suite = IOHprofiler_suite_initialize(suite_name,number,layer_param,temp_dim);
    /* Set the instance */
    if ((!suite_instance) || (strlen(suite_instance) == 0))
        instances = IOHprofiler_suite_get_instance_indices(suite, suite->default_instances);
    else {
        instances = IOHprofiler_suite_get_instance_indices(suite, suite_instance);

        if (!instances) {
            /* Something wrong in the suite_instance string, use default instead */
            instances = IOHprofiler_suite_get_instance_indices(suite, suite->default_instances);
        }

        /* Check for redundant option keys for suite instance */
        known_option_keys = IOHprofiler_option_keys_allocate(sizeof(known_keys_i) / sizeof(char *), known_keys_i);
        given_option_keys = IOHprofiler_option_keys(suite_instance);

        if (given_option_keys) {
            redundant_option_keys = IOHprofiler_option_keys_get_redundant(known_option_keys, given_option_keys);

            if ((redundant_option_keys != NULL) && (redundant_option_keys->count > 0)) {
                /* Warn the user that some of given options are being ignored and output the valid options */
                char *output_redundant = IOHprofiler_option_keys_get_output_string(redundant_option_keys,
                    "IOHprofiler_suite(): Some keys in suite instance were ignored:\n");
                char *output_valid = IOHprofiler_option_keys_get_output_string(known_option_keys,
                    "Valid keys for suite instance are:\n");
                IOHprofiler_warning("%s%s", output_redundant, output_valid);
                IOHprofiler_free_memory(output_redundant);
                IOHprofiler_free_memory(output_valid);
            }

            IOHprofiler_option_keys_free(given_option_keys);
            IOHprofiler_option_keys_free(redundant_option_keys);
        }
        IOHprofiler_option_keys_free(known_option_keys);
    }
    IOHprofiler_suite_set_instance(suite, instances);
    IOHprofiler_free_memory(instances);

    /* Apply filter if any given by the suite_options */
    if ((suite_options) && (strlen(suite_options) > 0)) {
        option_string = IOHprofiler_allocate_string(IOHprofiler_PATH_MAX);
        if (IOHprofiler_options_read_values(suite_options, "function_indices", option_string) > 0) {
            indices = IOHprofiler_string_parse_ranges(option_string, 1, suite->number_of_functions, "function_indices", IOHprofiler_MAX_INSTANCES);
            if (indices != NULL) {
              if(strcmp(suite->suite_name,"WModel")!=0){
                IOHprofiler_suite_filter_indices(suite->functions, suite->number_of_functions, indices, "function_indices");
              }
                IOHprofiler_free_memory(indices);
            }
        }
        IOHprofiler_free_memory(option_string);

        option_string = IOHprofiler_allocate_string(IOHprofiler_PATH_MAX);
        if (IOHprofiler_options_read_values(suite_options, "instance_indices", option_string) > 0) {
            indices = IOHprofiler_string_parse_ranges(option_string, 1, suite->number_of_instances, "instance_indices", IOHprofiler_MAX_INSTANCES);
            if (indices != NULL) {
                IOHprofiler_suite_filter_indices(suite->instances, suite->number_of_instances, indices, "instance_indices");
                IOHprofiler_free_memory(indices);
            }
        }
        IOHprofiler_free_memory(option_string);

        dim_found = IOHprofiler_strfind(suite_options, "dimensions");
        dim_idx_found = IOHprofiler_strfind(suite_options, "dimension_indices");

        if ((dim_found > 0) && (dim_idx_found > 0)) {
            if (dim_found < dim_idx_found) {
                parce_dim_idx = 0;
                IOHprofiler_warning("IOHprofiler_suite(): 'dimension_indices' suite option ignored because it follows 'dimensions'");
            } else {
                parce_dim = 0;
                IOHprofiler_warning("IOHprofiler_suite(): 'dimensions' suite option ignored because it follows 'dimension_indices'");
            }
        }

        option_string = IOHprofiler_allocate_string(IOHprofiler_PATH_MAX);
        if ((dim_idx_found >= 0) && (parce_dim_idx == 1) && (IOHprofiler_options_read_values(suite_options, "dimension_indices", option_string) > 0)) {
            indices = IOHprofiler_string_parse_ranges(option_string, 1, suite->number_of_dimensions, "dimension_indices",
                                                      IOHprofiler_MAX_INSTANCES);
            if (indices != NULL) {
                IOHprofiler_suite_filter_indices(suite->dimensions, suite->number_of_dimensions, indices, "dimension_indices");
                IOHprofiler_free_memory(indices);
            }
        }
        IOHprofiler_free_memory(option_string);

        option_string = IOHprofiler_allocate_string(IOHprofiler_PATH_MAX);
        if ((dim_found >= 0) && (parce_dim == 1) && (IOHprofiler_options_read_values(suite_options, "dimensions", option_string) > 0)) {
            ptr = option_string;
            /* Check for disallowed characters */
            while (*ptr != '\0') {
                if ((*ptr != ',') && !isdigit((unsigned char)*ptr)) {
                    IOHprofiler_warning("IOHprofiler_suite(): 'dimensions' suite option ignored because of disallowed characters");
                    return NULL;
                } else
                    ptr++;
            }
            dimensions = IOHprofiler_string_parse_ranges(option_string, suite->dimensions[0],
                                                         suite->dimensions[suite->number_of_dimensions - 1], "dimensions", IOHprofiler_MAX_INSTANCES);
            if (dimensions != NULL) {
                IOHprofiler_suite_filter_dimensions(suite, dimensions);
                IOHprofiler_free_memory(dimensions);
            }
        }
        IOHprofiler_free_memory(option_string);

        /* Check for redundant option keys for suite options */
        known_option_keys = IOHprofiler_option_keys_allocate(sizeof(known_keys_o) / sizeof(char *), known_keys_o);
        given_option_keys = IOHprofiler_option_keys(suite_options);

        if (given_option_keys) {
            redundant_option_keys = IOHprofiler_option_keys_get_redundant(known_option_keys, given_option_keys);

            if ((redundant_option_keys != NULL) && (redundant_option_keys->count > 0)) {
                /* Warn the user that some of given options are being ignored and output the valid options */
                char *output_redundant = IOHprofiler_option_keys_get_output_string(redundant_option_keys,
                                                                                   "IOHprofiler_suite(): Some keys in suite options were ignored:\n");
                char *output_valid = IOHprofiler_option_keys_get_output_string(known_option_keys,
                                                                               "Valid keys for suite options are:\n");
                IOHprofiler_warning("%s%s", output_redundant, output_valid);
                IOHprofiler_free_memory(output_redundant);
                IOHprofiler_free_memory(output_valid);
            }

            IOHprofiler_option_keys_free(given_option_keys);
            IOHprofiler_option_keys_free(redundant_option_keys);
        }
        IOHprofiler_option_keys_free(known_option_keys);
    }

    /* Check that there are enough dimensions, functions and instances left */
    if ((suite->number_of_dimensions < 1) || (suite->number_of_functions < 1) || (suite->number_of_instances < 1)) {
        IOHprofiler_error("IOHprofiler_suite(): the suite does not contain at least one dimension, function and instance");
        return NULL;
    }

    /* Set the starting values of the current indices in such a way, that when the instance_idx is incremented,
   * this results in a valid problem */
    IOHprofiler_suite_is_next_function_found(suite);
    IOHprofiler_suite_is_next_dimension_found(suite);

    return suite;
}

/**
 * Iterates through the suite first by instances, then by functions and finally by dimensions.
 * The instances/functions/dimensions that have been filtered out using the suite_options of the IOHprofiler_suite
 * function are skipped. Outputs some information regarding the current place in the iteration. The returned
 * problem is wrapped with the observer. If the observer is NULL, the returned problem is unobserved.
 *
 * @param suite The given suite.
 * @param observer The observer used to wrap the problem. If NULL, the problem is returned unobserved.
 *
 * @returns The next problem of the suite or NULL if there is no next problem left.
 */
IOHprofiler_problem_t *IOHprofiler_suite_get_next_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer) {
    size_t function_idx;
    size_t dimension_idx;
    size_t instance_idx;
    IOHprofiler_problem_t *problem;

    long previous_function_idx;
    long previous_dimension_idx;
    long previous_instance_idx;
    int i;
    assert(suite != NULL);

    previous_function_idx = suite->current_function_idx;
    previous_dimension_idx = suite->current_dimension_idx;
    previous_instance_idx = suite->current_instance_idx;

    /* Iterate through the suite by instances, then functions and lastly dimensions in search for the next
   * problem. Note that these functions set the values of suite fields current_instance_idx,
   * current_function_idx and current_dimension_idx. */
    if (!IOHprofiler_suite_is_next_instance_found(suite) && !IOHprofiler_suite_is_next_function_found(suite) && !IOHprofiler_suite_is_next_dimension_found(suite)) {
        IOHprofiler_info_partial("done\n");
        return NULL;
    }

    if (suite->current_problem) {
        IOHprofiler_problem_free(suite->current_problem);
    }
    if(((long)suite->current_dimension_idx != previous_dimension_idx) && (strcmp(suite->suite_name,"WModel")==0)) {
       for (i = 0; i < (((struct WModel *) suite->data)->number_of_layers);i++){
         ((struct WModel *) suite->data)->counter[i]=0;
       }
       ((struct WModel *) suite->data)->counter[(((struct WModel *) suite->data)->number_of_layers)-1]=-1;
       increment_layers_param((struct WModel *) suite->data,suite->current_dimension_idx+1);
       
    }else if((suite->current_function_idx>previous_function_idx) && (strcmp(suite->suite_name,"WModel")==0)){
      increment_layers_param((struct WModel *) suite->data,suite->current_dimension_idx+1);
    }
    assert(suite->current_function_idx >= 0);
    assert(suite->current_dimension_idx >= 0);
    assert(suite->current_instance_idx >= 0);
    function_idx = (size_t)suite->current_function_idx;
    dimension_idx = (size_t)suite->current_dimension_idx;
    instance_idx = (size_t)suite->current_instance_idx;
    problem = IOHprofiler_suite_get_problem_from_indices(suite, function_idx, dimension_idx, instance_idx);
    if (observer != NULL)
        problem = IOHprofiler_problem_add_observer(problem, observer);

    suite->current_problem = problem;
     
    /* Output information regarding the current place in the iteration */
    if (IOHprofiler_log_level >= IOHprofiler_INFO) {
        if (((long)dimension_idx != previous_dimension_idx) || (previous_instance_idx < 0)) {
            /* A new dimension started */
           if(strcmp(suite->suite_name,"WModel")==0){

             suite->number_of_functions=compute_number_of_functions(suite->data,dimension_idx+1);

    fprintf(stderr,"--------%d------------\n",suite->number_of_functions);
             IOHprofiler_free_memory(suite->functions);
             suite->functions = IOHprofiler_allocate_vector_size_t(suite->number_of_functions);
             for (i = 0; i < suite->number_of_functions; i++) {
               suite->functions[i] = i + 1;
             }
           }
            char *time_string = IOHprofiler_current_time_get_string();
            if (dimension_idx > 0)
                IOHprofiler_info_partial("done\n");
            else
                IOHprofiler_info_partial("\n");
            IOHprofiler_info_partial("IOHprofiler INFO: %s, d=%lu, running: \nf%02lu", time_string,
                                     (unsigned long)suite->dimensions[dimension_idx], (unsigned long)suite->functions[function_idx]);
            IOHprofiler_free_memory(time_string);
        } else if ((long)function_idx != previous_function_idx) {
            /* A new function started */
            IOHprofiler_info_partial("\nf%02lu", (unsigned long)suite->functions[function_idx]);
        }
        /* One dot for each instance */
        IOHprofiler_info_partial(".", suite->instances[instance_idx]);
    }
    return problem;
}

/**
 *
 * @returns The current problem of the suite.
 */
IOHprofiler_problem_t *IOHprofiler_suite_reset_problem(IOHprofiler_suite_t *suite, IOHprofiler_observer_t *observer) {
    size_t function_idx;
    size_t dimension_idx;
    size_t instance_idx;
    IOHprofiler_problem_t *problem;

    long previous_function_idx;
    long previous_dimension_idx;
    long previous_instance_idx;

    assert(suite != NULL);
    if (suite->current_problem) {
        IOHprofiler_problem_free(suite->current_problem);
    }

    previous_function_idx = suite->current_function_idx;
    previous_dimension_idx = suite->current_dimension_idx;
    previous_instance_idx = suite->current_instance_idx;

    function_idx = (size_t)suite->current_function_idx;
    dimension_idx = (size_t)suite->current_dimension_idx;
    instance_idx = (size_t)suite->current_instance_idx;

    problem = IOHprofiler_suite_get_problem_from_indices(suite, function_idx, dimension_idx, instance_idx);

    if (observer != NULL)
        problem = IOHprofiler_problem_add_observer(problem, observer);

    suite->current_problem = problem;

    /* Output information regarding the current place in the iteration */
    if (IOHprofiler_log_level >= IOHprofiler_INFO) {
        if (((long)dimension_idx != previous_dimension_idx) || (previous_instance_idx < 0)) {
            /* A new dimension started */
            char *time_string = IOHprofiler_current_time_get_string();
            if (dimension_idx > 0)
                IOHprofiler_info_partial("done\n");
            else
                IOHprofiler_info_partial("\n");
            IOHprofiler_info_partial("IOHprofiler INFO: %s, d=%lu, running: \nf%02lu", time_string,
                                     (unsigned long)suite->dimensions[dimension_idx], (unsigned long)suite->functions[function_idx]);
            IOHprofiler_free_memory(time_string);
        } else if ((long)function_idx != previous_function_idx) {
            /* A new function started */
            IOHprofiler_info_partial("\nf%02lu", (unsigned long)suite->functions[function_idx]);
        }
        /* One dot for each instance */
        IOHprofiler_info_partial(".", suite->instances[instance_idx]);
    }

    return problem;
}

/* See IOHprofiler.h for more information on encoding and decoding problem index */

/**
 * @param suite The suite.
 * @param function_idx Index of the function (starting with 0).
 * @param dimension_idx Index of the dimension (starting with 0).
 * @param instance_idx Index of the insatnce (starting with 0).
 *
 * @return The problem index in the suite computed from function_idx, dimension_idx and instance_idx.
 */
size_t IOHprofiler_suite_encode_problem_index(const IOHprofiler_suite_t *suite,
                                              const size_t function_idx,
                                              const size_t dimension_idx,
                                              const size_t instance_idx) {
    return instance_idx + (function_idx * suite->number_of_instances) +
           (dimension_idx * suite->number_of_instances * suite->number_of_functions);
}

/**
 * @param suite The suite.
 * @param problem_index Index of the problem in the suite (starting with 0).
 * @param function_idx Pointer to the index of the function, which is set by this function.
 * @param dimension_idx Pointer to the index of the dimension, which is set by this function.
 * @param instance_idx Pointer to the index of the instance, which is set by this function.
 */
void IOHprofiler_suite_decode_problem_index(const IOHprofiler_suite_t *suite,
                                            const size_t problem_index,
                                            size_t *function_idx,
                                            size_t *dimension_idx,
                                            size_t *instance_idx) {
    if (problem_index > (suite->number_of_instances * suite->number_of_functions * suite->number_of_dimensions) - 1) {
        IOHprofiler_warning("IOHprofiler_suite_decode_problem_index(): problem_index too large");
        function_idx = 0;
        instance_idx = 0;
        dimension_idx = 0;
        return;
    }

    *instance_idx = problem_index % suite->number_of_instances;
    *function_idx = (problem_index / suite->number_of_instances) % suite->number_of_functions;
    *dimension_idx = problem_index / (suite->number_of_instances * suite->number_of_functions);
}

#endif

#line 1 "code-experiments/src/profiler/IOHprofiler_observer.c"
/**
 * @file IOHprofiler_observer.c
 * @brief Definitions of functions regarding IOHprofiler observers.
 */
#ifndef IOH_PROFILER_OBSERVER
#define IOH_PROFILER_OBSERVER

#line 9 "code-experiments/src/profiler/IOHprofiler_observer.c"
#line 10 "code-experiments/src/profiler/IOHprofiler_observer.c"
#include <limits.h>
#include <float.h>
#include <math.h>

/**
 * @brief The type for triggers based on target values.
 *
 * The target values that trigger logging are at every 10**(exponent/number_of_triggers) from positive
 * infinity down to precision, at 0, and from -precision on with step -10**(exponent/number_of_triggers) until
 * negative infinity.
 */
typedef struct {

  int exponent;               /**< @brief Value used to compare with the previously hit target. */
  double value;               /**< @brief Value of the currently hit target. */
  size_t number_of_triggers;  /**< @brief Number of target triggers between 10**i and 10**(i+1) for any i. */
  double precision;           /**< @brief Minimal precision of interest. */

} IOHprofiler_observer_targets_t;

/**
 * @brief The type for triggers based on numbers of evaluations.
 *
 * The numbers of evaluations that trigger logging are any of the two:
 * - every 10**(exponent1/number_of_triggers) for exponent1 >= 0
 * - every base_evaluation * dimension * (10**exponent2) for exponent2 >= 0
 */
typedef struct {

  /* First trigger */
  size_t value1;              /**< @brief The next value for the first trigger. */
  size_t exponent1;           /**< @brief Exponent used to compute the first trigger. */
  size_t number_of_triggers;  /**< @brief Number of target triggers between 10**i and 10**(i+1) for any i. */

  /* Second trigger */
  size_t value2;              /**< @brief The next value for the second trigger. */
  size_t exponent2;           /**< @brief Exponent used to compute the second trigger. */
  size_t *base_evaluations;   /**< @brief The base evaluation numbers used to compute the actual evaluation
                                   numbers that trigger logging. */
  size_t base_count;          /**< @brief The number of base evaluations. */
  size_t base_index;          /**< @brief The next index of the base evaluations. */
  size_t dimension;           /**< @brief Dimension used in the calculation of the first trigger. */

}IOHprofiler_observer_evaluations_t;

/**
 * @brief The type for triggers based on updating.
 * The traget values that trigger logging are at every updating iteration.
 */
typedef struct {
  double previous_value;      /**< @brief Evaluation last updated. */
}IOHprofiler_observer_update_t;



/**
 * @brief The maximum number of evaluations to trigger logging.
 *
 * @note This is not the maximal evaluation number to be logged, but the maximal number of times logging is
 * triggered by the number of evaluations.
 */
#define IOHprofiler_MAX_EVALS_TO_LOG 1000

/***********************************************************************************************************/

/**
 * @name Methods regarding triggers based on target values
 */

/**
 * @brief Creates and returns a structure containing information on targets.
 *
 * @param number_of_targets The number of targets between 10**(i/n) and 10**((i+1)/n) for each i.
 * @param precision Minimal precision of interest.
 */
static IOHprofiler_observer_targets_t *IOHprofiler_observer_targets(const size_t number_of_targets,
                                                      const double precision) {

  IOHprofiler_observer_targets_t *targets = (IOHprofiler_observer_targets_t *) IOHprofiler_allocate_memory(sizeof(*targets));
  targets->exponent = INT_MAX;
  targets->value = DBL_MAX;
  targets->number_of_triggers = number_of_targets;
  targets->precision = precision;

  return targets;
}

/**
 * @brief Computes and returns whether the given value should trigger logging.
 */
static int IOHprofiler_observer_targets_trigger(IOHprofiler_observer_targets_t *targets, const double given_value) {

  int update_performed = 0;

  const double number_of_targets_double = (double) (long) targets->number_of_triggers;

  double verified_value = 0;
  int last_exponent = 0;
  int current_exponent = 0;
  int adjusted_exponent = 0;

  assert(targets != NULL);

  /* The given_value is positive or zero */
  if (given_value >= 0) {

    if (given_value == 0) {
      /* If zero, use even smaller value than precision */
      verified_value = targets->precision / 10.0;
    } else if (given_value < targets->precision) {
      /* If close to zero, use precision instead of the given_value*/
      verified_value = targets->precision;
    } else {
      verified_value = given_value;
    }

    current_exponent = (int) (ceil(log10(verified_value) * number_of_targets_double));

    /* If this is the first time the update was called, set the last_exponent to some value greater than the
     * current exponent */
    if (last_exponent == INT_MAX) {
      last_exponent = current_exponent + 1;
    } else {
      last_exponent = targets->exponent;
    }

    if (current_exponent < last_exponent) {
      /* Update the target information */
      targets->exponent = current_exponent;
      if (given_value == 0)
        targets->value = 0;
      else
        targets->value = pow(10, (double) current_exponent / number_of_targets_double);
      update_performed = 1;
    }
  }
  /* The given_value is negative, therefore adjustments need to be made */
  else {

    /* If close to zero, use precision instead of the given_value*/
    if (given_value > -targets->precision) {
      verified_value = targets->precision;
    } else {
      verified_value = -given_value;
    }

    /* Adjustment: use floor instead of ceil! */
    current_exponent = (int) (floor(log10(verified_value) * number_of_targets_double));

    /* If this is the first time the update was called, set the last_exponent to some value greater than the
     * current exponent */
    if (last_exponent == INT_MAX) {
      last_exponent = current_exponent + 1;
    } else {
      last_exponent = targets->exponent;
    }

    /* Compute the adjusted_exponent in such a way, that it is always diminishing in value. The adjusted
     * exponent can only be used to verify if a new target has been hit. To compute the actual target
     * value, the current_exponent needs to be used. */
    adjusted_exponent = 2 * (int) (ceil(log10(targets->precision / 10.0) * number_of_targets_double))
        - current_exponent - 1;

    if (adjusted_exponent < last_exponent) {
      /* Update the target information */
      targets->exponent = adjusted_exponent;
      targets->value = - pow(10, (double) current_exponent / number_of_targets_double);
      update_performed = 1;
    }
  }

  return update_performed;
}

/**
 * @brief Creates and returns a structure containing information on triggers based on evaluation numbers.
 *
 * The numbers of evaluations that trigger logging are any of the two:
 * - every 10**(exponent1/number_of_triggers) for exponent1 >= 0
 * - every base_evaluation * dimension * (10**exponent2) for exponent2 >= 0
 *
 * @note The IOHprofiler_observer_evaluations_t object instances need to be freed using the
 * IOHprofiler_observer_evaluations_free function!
 *
 * @param base_evaluations Evaluation numbers formatted as a string, which are used as the base to compute
 * the second trigger. For example, if base_evaluations = "1,2,5", the logger will be triggered by
 * evaluations dim*1, dim*2, dim*5, 10*dim*1, 10*dim*2, 10*dim*5, 100*dim*1, 100*dim*2, 100*dim*5, ...
 */
static IOHprofiler_observer_evaluations_t *IOHprofiler_observer_evaluations(const char *base_evaluations,
                                                              const size_t dimension) {

  IOHprofiler_observer_evaluations_t *evaluations = (IOHprofiler_observer_evaluations_t *) IOHprofiler_allocate_memory(
      sizeof(*evaluations));

  /* First trigger */
  evaluations->value1 = 1;
  evaluations->exponent1 = 0;
  evaluations->number_of_triggers = 20;

  /* Second trigger */
  evaluations->base_evaluations = IOHprofiler_string_parse_ranges(base_evaluations, 0, 0, "base_evaluations",
      IOHprofiler_MAX_EVALS_TO_LOG);
  evaluations->dimension = dimension;
  evaluations->base_count = IOHprofiler_count_numbers(evaluations->base_evaluations, IOHprofiler_MAX_EVALS_TO_LOG,
      "base_evaluations");
  evaluations->base_index = 0;
  evaluations->value2 = dimension * evaluations->base_evaluations[0];
  evaluations->exponent2 = 0;

  return evaluations;
}

/**
 * @brief Computes and returns whether the given evaluation number triggers the first condition of the
 * logging based on the number of evaluations.
 *
 * The second condition is:
 * evaluation_number == 10**(exponent1/number_of_triggers)
 */
static int IOHprofiler_observer_evaluations_trigger_first(IOHprofiler_observer_evaluations_t *evaluations,
                                                   const size_t evaluation_number) {

  assert(evaluations != NULL);

  if (evaluation_number == evaluations->value1) {
    /* Compute the next value for the first trigger */
    while (IOHprofiler_double_to_size_t(floor(pow(10, (double) evaluations->exponent1 / (double) evaluations->number_of_triggers)) <= evaluations->value1)) {
      evaluations->exponent1++;
    }
    evaluations->value1 = IOHprofiler_double_to_size_t(floor(pow(10, (double) evaluations->exponent1 / (double) evaluations->number_of_triggers)));
    return 1;
  }
  return 0;
}

/**
 * @brief Computes and returns whether the given evaluation number triggers the second condition of the
 * logging based on the number of evaluations.
 *
 * The second condition is:
 * evaluation_number == base_evaluation[base_index] * dimension * (10**exponent2)
 */
static int IOHprofiler_observer_evaluations_trigger_second(IOHprofiler_observer_evaluations_t *evaluations,
                                                    const size_t evaluation_number) {

  assert(evaluations != NULL);

  if (evaluation_number == evaluations->value2) {
    /* Compute the next value for the second trigger */
    if (evaluations->base_index < evaluations->base_count - 1) {
      evaluations->base_index++;
    } else {
      evaluations->base_index = 0;
      evaluations->exponent2++;
    }
    evaluations->value2 = IOHprofiler_double_to_size_t(pow(10, (double) evaluations->exponent2)
        * (double) (long) evaluations->dimension
        * (double) (long) evaluations->base_evaluations[evaluations->base_index]);
    return 1;
  }
  return 0;
}

/**
 * @brief Returns 1 if any of the two triggers based on the number of evaluations equal 1 and 0 otherwise.
 *
 * The numbers of evaluations that trigger logging are any of the two:
 * - every 10**(exponent1/number_of_triggers) for exponent1 >= 0
 * - every base_evaluation * dimension * (10**exponent2) for exponent2 >= 0
 */
static int IOHprofiler_observer_evaluations_trigger(IOHprofiler_observer_evaluations_t *evaluations,
                                             const size_t evaluation_number) {

  /* Both functions need to be called so that both triggers are correctly updated */
  int first = IOHprofiler_observer_evaluations_trigger_first(evaluations, evaluation_number);
  int second = IOHprofiler_observer_evaluations_trigger_second(evaluations, evaluation_number);

  return (first + second > 0) ? 1: 0;
}

/**
 * @brief Frees the given evaluations object.
 */
static void IOHprofiler_observer_evaluations_free(IOHprofiler_observer_evaluations_t *evaluations) {

  assert(evaluations != NULL);
  IOHprofiler_free_memory(evaluations->base_evaluations);
  IOHprofiler_free_memory(evaluations);
}


/**
 * @brief Creates and returns a structure containing information on triggers every time updating.
 */
static IOHprofiler_observer_update_t  *IOHprofiler_observer_update(void) {
   IOHprofiler_observer_update_t *updating = (IOHprofiler_observer_update_t *) IOHprofiler_allocate_memory(sizeof(*updating));
   updating->previous_value = -DBL_MAX;

   return updating;
}


/**
 * @brief Returns 1 if current evaluation is larger than previous one.
 */
static int IOHprofiler_observer_update_trigger(IOHprofiler_observer_update_t *updating,
                                             const double evaluation) {

  int update_performed = 0;
  if(evaluation > updating->previous_value){
    updating->previous_value = evaluation;
    update_performed = 1;
  }
  return update_performed;
}

static void IOHprofiler_observer_update_free(IOHprofiler_observer_update_t *updating){
  assert(updating != NULL);
  IOHprofiler_free_memory(updating);
}

/**
 * @brief Returns 1 every interval times.
 * Probably being useful in future.
 */
/*
static int IOHprofiler_observer_interval_trigger(const int interval,
                                             const size_t evaluation_number) {

  int update_performed = 0;
  if(interval%evaluation_number == 0){
    update_performed = 1;
  }
  return update_performed;
}
*/


/**
 * @brief Allocates memory for a IOHprofiler_observer_t instance.
 */
static IOHprofiler_observer_t *IOHprofiler_observer_allocate(const char *result_folder,
                                               const char *observer_name,
                                               const char *algorithm_name,
                                               const char *algorithm_info,
                                               const size_t number_target_triggers,
                                               const double target_precision,
                                               const size_t number_evaluation_triggers,
                                               const char *base_evaluation_triggers,
                                               const size_t number_interval_triggers,
                                               const char *complete_triggers,
                                               const int precision_x,
                                               const int precision_f,
                                               const char *parameters_name) {

  IOHprofiler_observer_t *observer;
  observer = (IOHprofiler_observer_t *) IOHprofiler_allocate_memory(sizeof(*observer));
  /* Initialize fields to sane/safe defaults */
  observer->result_folder = IOHprofiler_strdup(result_folder);
  observer->observer_name = IOHprofiler_strdup(observer_name);
  observer->algorithm_name = IOHprofiler_strdup(algorithm_name);
  observer->algorithm_info = IOHprofiler_strdup(algorithm_info);
  observer->parameters_name = IOHprofiler_strdup(parameters_name);
  observer->number_target_triggers = number_target_triggers;
  observer->target_precision = target_precision;
  observer->number_evaluation_triggers = number_evaluation_triggers;
  observer->base_evaluation_triggers = IOHprofiler_strdup(base_evaluation_triggers);
  observer->number_interval_triggers = number_interval_triggers;
  observer->complete_triggers = IOHprofiler_strdup(complete_triggers);
  observer->precision_x = precision_x;
  observer->precision_f = precision_f;
  observer->data = NULL;
  observer->data_free_function = NULL;
  observer->logger_allocate_function = NULL;
  observer->logger_free_function = NULL;
  observer->is_active = 1;
  return observer;
}

void IOHprofiler_observer_free(IOHprofiler_observer_t *observer) {
  if (observer != NULL) {
    observer->is_active = 0;
    if (observer->observer_name != NULL)
      IOHprofiler_free_memory(observer->observer_name);
    if (observer->result_folder != NULL)
      IOHprofiler_free_memory(observer->result_folder);
    if (observer->algorithm_name != NULL)
      IOHprofiler_free_memory(observer->algorithm_name);
    if (observer->algorithm_info != NULL)
      IOHprofiler_free_memory(observer->algorithm_info);
    if (observer->base_evaluation_triggers != NULL)
      IOHprofiler_free_memory(observer->base_evaluation_triggers);
    if (observer->complete_triggers != NULL)
      IOHprofiler_free_memory(observer->complete_triggers);
    if (observer->data != NULL) {
      if (observer->data_free_function != NULL) {
        observer->data_free_function(observer->data);
      }
      IOHprofiler_free_memory(observer->data);
      observer->data = NULL;
    }

    observer->logger_allocate_function = NULL;
    observer->logger_free_function = NULL;

    IOHprofiler_free_memory(observer);
    observer = NULL;
  }
}

#line 1 "code-experiments/src/profiler/../suite/PBO/logger_PBO.c"
/**
 * @file logger_PBO.c
 * @brief Implementation of the IOHprofiler logger.
 *
 * Logs the performance of a single-objective optimizer on noisy or noiseless problems.
 * It produces four kinds of files:
 * - The "info" files ...
 * - The "dat" files ...
 * - The "tdat" files ...
 * - The "rdat" files ...
 */

/* TODO: Document this file in doxygen style! */

#include <stdio.h>
#include <assert.h>
#include <limits.h>
#include <float.h>
#include <math.h>
#include <errno.h>
#include <stdarg.h>

#ifndef IOHPROFILER
#define IOHPROFILER
#line 26 "code-experiments/src/profiler/../suite/PBO/logger_PBO.c"
#endif
#ifndef IOHPROFILER_UTILITIES
#define IOHPROFILER_UTILITIES
#line 30 "code-experiments/src/profiler/../suite/PBO/logger_PBO.c"
#endif
#ifndef IOHPROFILER_PROBLEM
#define IOHPROFILER_PROBLEM
#line 34 "code-experiments/src/profiler/../suite/PBO/logger_PBO.c"
#endif
#ifndef IOHPROFILER_STRING
#define IOHPROFILER_STRING
#line 38 "code-experiments/src/profiler/../suite/PBO/logger_PBO.c"
#endif
#line 1 "code-experiments/src/profiler/../suite/PBO/observer_PBO.c"
/**
 * @file observer_bbob.c
 * @brief Implementation of the PBO observer.
 */
#ifndef OBSERVER_PBO
#define OBSERVER_PBO


#line 10 "code-experiments/src/profiler/../suite/PBO/observer_PBO.c"
#line 11 "code-experiments/src/profiler/../suite/PBO/observer_PBO.c"

static IOHprofiler_problem_t *logger_PBO(IOHprofiler_observer_t *observer, IOHprofiler_problem_t *problem);
static void logger_PBO_free(void *logger);

/**
 * @brief The IOHprofiler observer data type.
 */
typedef struct {
    /* TODO: Can be used to store variables that need to be accessible during one run (i.e. for multiple
   * problems). For example, the following global variables from logger_bbob.c could be stored here: */
    size_t current_dim;
    size_t current_fun_id;
    /* ... and others */
} observer_PBO_data_t;

/**
 * @brief Initializes the bbob observer.
 */
static void PBO_observer_IOHprofiler(IOHprofiler_observer_t *observer, const char *options, IOHprofiler_option_keys_t **option_keys) {
    observer->logger_allocate_function = logger_PBO;
    observer->logger_free_function = logger_PBO_free;
    observer->data_free_function = NULL;
    observer->data = NULL;

    *option_keys = NULL;

    (void)options; /* To silence the compiler */
}
#endif
#line 40 "code-experiments/src/profiler/../suite/PBO/logger_PBO.c"

/*static const size_t IOHprofiler_nbpts_nbevals = 20; Wassim: tentative, are now observer options with these default values*/
/*static const size_t IOHprofiler_nbpts_fval = 5;*/
static size_t PBO_current_dim = 0;
static size_t PBO_current_funId = 0;
static size_t PBO_infoFile_firstInstance = 0;
char PBO_infoFile_firstInstance_char[3];
/* a possible solution: have a list of dims that are already in the file, if the ones we're about to log
 * is != PBO_current_dim and the funId is currend_funId, create a new .info file with as suffix the
 * number of the first instance */
static const int PBO_number_of_dimensions = 6;
static size_t PBO_dimensions_in_current_infoFile[6] = { 0, 0, 0, 0, 0, 0 }; /* TODO should use dimensions from the suite */

/* The current_... mechanism fails if several problems are open.
 * For the time being this should lead to an error.
 *
 * A possible solution: PBO_logger_is_open becomes a reference
 * counter and as long as another logger is open, always a new info
 * file is generated.
 * TODO: Shouldn't the new way of handling observers already fix this?
 */
static int PBO_logger_is_open = 0; /* this could become lock-list of .info files */

/* TODO: add possibility of adding a prefix to the index files (easy to do through observer options) */
static double PBO_fmax(double a, double b) {
  return (a > b) ? a : b;
}

/**
 * @brief The IOHprofiler logger data type.
 */
typedef struct {
  IOHprofiler_observer_t *observer;
  int is_initialized;
  /*char *path;// relative path to the data folder. //Wassim: now fetched from the observer */
  /*const char *alg_name; the alg name, for now, temporarily the same as the path. Wassim: Now in the observer */
  FILE *index_file; /* index file */
  FILE *fdata_file; /* function value aligned data file */
  FILE *tdata_file; /* number of function evaluations aligned data file */
  /*
  FILE *rdata_file;  restart info data file */
  
  FILE *idata_file; /* fixed interval aligned data file */
  FILE *cdata_file; /* complete data file */

  int f_flag; /* symbol for writing fdata_file*/
  int t_flag; /* symbol for writing tdata_file*/
  int i_flag; /* symbol for writing idata_file*/
  int c_flag; /* symbol for writing cdata_file*/
  size_t number_of_evaluations;
  double best_fvalue;
  double last_fvalue;
  double raw_value;
  double best_raw_value;
  short written_last_eval; /* allows writing the the data of the final fun eval in the .tdat file if not already written by the t_trigger*/
  int *best_solution;
  /* The following are to only pass data as a parameter in the free function. The
   * interface should probably be the same for all free functions so passing the
   * problem as a second parameter is not an option even though we need info
   * form it.*/
  size_t function_id; /*TODO: consider changing name*/
  size_t instance_id;
  size_t number_of_variables;
  size_t inner_dimension;
  double optimal_fvalue;

  size_t number_of_parameters;
  double *parameters;

  IOHprofiler_observer_targets_t *targets;          /**< @brief Triggers based on target values. */
  IOHprofiler_observer_evaluations_t *evaluations;  /**< @brief Triggers based on the number of evaluations. */
  IOHprofiler_observer_update_t *updating;          /**< @brief Triggers based on the updating. */
  size_t interval;                    /**< @brief The value of triggers interval. */

} logger_PBO_data_t;

static const char *PBO_file_header_str = "\"function evaluation\" "
    "\"current f(x)\" "
    "\"best-so-far f(x)\" "
    "\"current af(x)+b\"  "
    "\"best af(x)+b\" ";

static const char *PBO_file_para_str = "\"%s\" ";

/**
 * adds a formated line to a data file
 */
static void logger_PBO_write_data(FILE *target_file,
                                   size_t number_of_evaluations,
                                   double fvalue,
                                   double best_fvalue,
                                   double best_raw_value,
                                   double raw_value,
                                   const double *parameter,
                                   size_t number_of_parameters) {
  /* for some reason, it's %.0f in the old code instead of the 10.9e
   * in the documentation
   */
  size_t i;
  fprintf(target_file, "%lu %+10.5e %+10.5e %+10.5e %+10.5e", (unsigned long) number_of_evaluations,
      raw_value, best_raw_value, fvalue , best_fvalue);
    
  for (i = 0; i < number_of_parameters; i++) {
    fprintf(target_file, " %.6f", parameter[i]);
  }

  fprintf(target_file, "\n");
}

/**
 * Error when trying to create the file "path"
 */
static void logger_PBO_error_io(FILE *path, int errnum) {
  const char *error_format = "Error opening file: %s\n ";
  IOHprofiler_error(error_format, strerror(errnum), path);
}

/**
 * Creates the data files or simply opens it
 */


static void logger_PBO_open_dataFile(FILE **target_file,
                                      const char *path,
                                      const char *dataFile_path,
                                      const char *file_extension) {
  char file_path[IOHprofiler_PATH_MAX] = { 0 };
  char relative_filePath[IOHprofiler_PATH_MAX] = { 0 };
  int errnum;
  strncpy(relative_filePath, dataFile_path,
  IOHprofiler_PATH_MAX - strlen(relative_filePath) - 1);
  strncat(relative_filePath, file_extension,
  IOHprofiler_PATH_MAX - strlen(relative_filePath) - 1);
  IOHprofiler_join_path(file_path, sizeof(file_path), path, relative_filePath, NULL);
  if (*target_file == NULL) {
    *target_file = fopen(file_path, "a+");
    errnum = errno;
    if (*target_file == NULL) {
      logger_PBO_error_io(*target_file, errnum);
    }
  }
}


/**
 * Creates the index file fileName_prefix+problem_id+file_extension in
 * folde_path
 */
static void logger_PBO_openIndexFile(logger_PBO_data_t *logger,
                                      const char *folder_path,
                                      const char *indexFile_prefix,
                                      const char *function_id,
                                      const char *dataFile_path,
                                      const char *suite_name) {
  /* to add the instance number TODO: this should be done outside to avoid redoing this for the .*dat files */
  char used_dataFile_path[IOHprofiler_PATH_MAX] = { 0 };
  int errnum, newLine; /* newLine is at 1 if we need a new line in the info file */
  char function_id_char[3]; /* TODO: consider adding them to logger */
  char file_name[IOHprofiler_PATH_MAX] = { 0 };
  char file_path[IOHprofiler_PATH_MAX] = { 0 };
  FILE **target_file;
  FILE *tmp_file;
  strncpy(used_dataFile_path, dataFile_path, IOHprofiler_PATH_MAX - strlen(used_dataFile_path) - 1);
  if (PBO_infoFile_firstInstance == 0) {
    PBO_infoFile_firstInstance = logger->instance_id;
  }
  sprintf(function_id_char, "%lu", (unsigned long) logger->function_id);
  sprintf(PBO_infoFile_firstInstance_char, "%lu", (unsigned long) PBO_infoFile_firstInstance);
  target_file = &(logger->index_file);
  tmp_file = NULL; /* to check whether the file already exists. Don't want to use target_file */
  strncpy(file_name, indexFile_prefix, IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  strncat(file_name, "_f", IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  strncat(file_name, function_id_char, IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  strncat(file_name, "_i", IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  strncat(file_name, PBO_infoFile_firstInstance_char, IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  strncat(file_name, ".info", IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  IOHprofiler_join_path(file_path, sizeof(file_path), folder_path, file_name, NULL);
  if (*target_file == NULL) {
    tmp_file = fopen(file_path, "r"); /* to check for existence */
    if ((tmp_file) && (PBO_current_dim == logger->inner_dimension)
        && (PBO_current_funId == logger->function_id)) {
        /* new instance of current funId and current dim */
      newLine = 0;
      *target_file = fopen(file_path, "a+");
      if (*target_file == NULL) {
        errnum = errno;
        logger_PBO_error_io(*target_file, errnum);
      }
      fclose(tmp_file);
    } else { /* either file doesn't exist (new funId) or new Dim */
      /* check that the dim was not already present earlier in the file, if so, create a new info file */
      if (PBO_current_dim != logger->inner_dimension) {
        int i, j;
        for (i = 0;
            i < PBO_number_of_dimensions && PBO_dimensions_in_current_infoFile[i] != 0
                && PBO_dimensions_in_current_infoFile[i] != logger->inner_dimension; i++) {
          ; /* checks whether dimension already present in the current infoFile */
        }
        if (i < PBO_number_of_dimensions && PBO_dimensions_in_current_infoFile[i] == 0) {
          /* new dimension seen for the first time */
          PBO_dimensions_in_current_infoFile[i] = logger->inner_dimension;
          newLine = 1;
        } else {
          if (i < PBO_number_of_dimensions) { /* dimension already present, need to create a new file */
            newLine = 0;
            file_path[strlen(file_path) - strlen(PBO_infoFile_firstInstance_char) - 7] = 0; /* truncate the instance part */
            PBO_infoFile_firstInstance = logger->instance_id;
            sprintf(PBO_infoFile_firstInstance_char, "%lu", (unsigned long) PBO_infoFile_firstInstance);
            strncat(file_path, "_i", IOHprofiler_PATH_MAX - strlen(file_name) - 1);
            strncat(file_path, PBO_infoFile_firstInstance_char, IOHprofiler_PATH_MAX - strlen(file_name) - 1);
            strncat(file_path, ".info", IOHprofiler_PATH_MAX - strlen(file_name) - 1);
          } else {/*we have all dimensions*/
            newLine = 1;
          }
          for (j = 0; j < PBO_number_of_dimensions; j++) { /* new info file, reinitialize list of dims */
            PBO_dimensions_in_current_infoFile[j] = 0;
          }
          PBO_dimensions_in_current_infoFile[i] = logger->inner_dimension;
        }
      } else {
        if ( PBO_current_funId != logger->function_id ) {
          /*new function in the same file */
          newLine = 1;
        }
      }
      *target_file = fopen(file_path, "a+"); /* in any case, we append */
      if (*target_file == NULL) {
        errnum = errno;
        logger_PBO_error_io(*target_file, errnum);
      }
      if (tmp_file) { /* File already exists, new dim so just a new line. Also, close the tmp_file */
        if (newLine) {
          fprintf(*target_file, "\n");
        }
        fclose(tmp_file);
      }

      fprintf(*target_file,
          "suite = '%s', funcId = %d, DIM = %lu, algId = '%s', algInfo = '%s'\n",
          suite_name, (int) strtol(function_id, NULL, 10), (unsigned long) logger->inner_dimension,
          logger->observer->algorithm_name, logger->observer->algorithm_info);

      fprintf(*target_file, "%%\n");
      strncat(used_dataFile_path, "_i", IOHprofiler_PATH_MAX - strlen(used_dataFile_path) - 1);
      strncat(used_dataFile_path, PBO_infoFile_firstInstance_char,
      IOHprofiler_PATH_MAX - strlen(used_dataFile_path) - 1);
      fprintf(*target_file, "%s.dat", used_dataFile_path); /* dataFile_path does not have the extension */
      PBO_current_dim = logger->inner_dimension;
      PBO_current_funId = logger->function_id;
    }
  }
}

/**
 * Generates the different files and folder needed by the logger to store the
 * data if these don't already exist
 */
static void logger_PBO_initialize(logger_PBO_data_t *logger, IOHprofiler_problem_t *inner_problem) {
  /*
   Creates/opens the data and index files
   */
  char dataFile_path[IOHprofiler_PATH_MAX] = { 0 }; /* relative path to the .dat file from where the .info file is */
  char folder_path[IOHprofiler_PATH_MAX] = { 0 };
  char *tmpc_funId; /* serves to extract the function id as a char *. There should be a better way of doing this! */
  char *tmpc_dim; /* serves to extract the dimension as a char *. There should be a better way of doing this! */
  char indexFile_prefix[15] = "IOHprofiler"; /* TODO (minor): make the prefix IOHprofilerexp a parameter that the user can modify */
  size_t str_length_funId, str_length_dim;
  
  str_length_funId = IOHprofiler_double_to_size_t(PBO_fmax(1, ceil(log10((double) IOHprofiler_problem_get_suite_dep_function(inner_problem)))));
  str_length_dim = IOHprofiler_double_to_size_t(PBO_fmax(1, ceil(log10((double) inner_problem->dimension))));
  tmpc_funId = IOHprofiler_allocate_string(str_length_funId);
  tmpc_dim = IOHprofiler_allocate_string(str_length_dim);

  assert(logger != NULL);
  assert(inner_problem != NULL);
  assert(inner_problem->problem_id != NULL);

  sprintf(tmpc_funId, "%lu", (unsigned long) IOHprofiler_problem_get_suite_dep_function(inner_problem));
  sprintf(tmpc_dim, "%lu", (unsigned long) inner_problem->dimension);

  /* prepare paths and names */
  strncpy(dataFile_path, "data_f", IOHprofiler_PATH_MAX);
  strncat(dataFile_path, tmpc_funId,
  IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);
  IOHprofiler_join_path(folder_path, sizeof(folder_path), logger->observer->result_folder, dataFile_path,
  NULL);
  IOHprofiler_create_directory(folder_path);
  strncat(dataFile_path, "/IOHprofiler_f",
  IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);
  strncat(dataFile_path, tmpc_funId,
  IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);
  strncat(dataFile_path, "_DIM", IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);
  strncat(dataFile_path, tmpc_dim, IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);

  /* index/info file */
  assert(IOHprofiler_problem_get_suite(inner_problem));
  logger_PBO_openIndexFile(logger, logger->observer->result_folder, indexFile_prefix, tmpc_funId,
      dataFile_path, IOHprofiler_problem_get_suite(inner_problem)->suite_name);
  fprintf(logger->index_file, ", %lu", (unsigned long) IOHprofiler_problem_get_suite_dep_instance(inner_problem));
  /* data files */
  /* TODO: definitely improvable but works for now */
  strncat(dataFile_path, "_i", IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);
  strncat(dataFile_path, PBO_infoFile_firstInstance_char,
  IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);

  if(logger->f_flag == 1){
    logger_PBO_open_dataFile(&(logger->fdata_file), logger->observer->result_folder, dataFile_path, ".dat");
    fprintf(logger->fdata_file,"%s", PBO_file_header_str);
    if(logger->observer->parameters_name != NULL)
      fprintf(logger->fdata_file, PBO_file_para_str,logger->observer->parameters_name);
    fprintf(logger->fdata_file, "\n");
  }

  if(logger->t_flag == 1){
    logger_PBO_open_dataFile(&(logger->tdata_file), logger->observer->result_folder, dataFile_path, ".tdat");
    fprintf(logger->tdata_file,"%s", PBO_file_header_str);
    if(logger->observer->parameters_name != NULL)
      fprintf(logger->tdata_file, PBO_file_para_str,logger->observer->parameters_name);
    fprintf(logger->tdata_file, "\n");
  }

  if(logger->i_flag == 1){
    logger_PBO_open_dataFile(&(logger->idata_file), logger->observer->result_folder, dataFile_path, ".idat");
    fprintf(logger->idata_file, "%s",PBO_file_header_str);
    if(logger->observer->parameters_name != NULL)
      fprintf(logger->idata_file, PBO_file_para_str,logger->observer->parameters_name);
    fprintf(logger->idata_file, "\n");
  }

  if(logger->c_flag == 1){
    logger_PBO_open_dataFile(&(logger->cdata_file), logger->observer->result_folder, dataFile_path, ".cdat");
    fprintf(logger->cdata_file, "%s",PBO_file_header_str);
    if(logger->observer->parameters_name != NULL)
      fprintf(logger->cdata_file, PBO_file_para_str,logger->observer->parameters_name);
    fprintf(logger->cdata_file, "\n");
  }
  /*
  logger_PBO_open_dataFile(&(logger->rdata_file), logger->observer->result_folder, dataFile_path, ".rdat");
  fprintf(logger->rdata_file,"%s", PBO_file_header_str);
  if(logger->observer->parameters_name != NULL)
    fprintf(logger->rdata_file, PBO_file_para_str,logger->observer->parameters_name);
  fprintf(logger->rdata_file, "\n");
  */
  logger->is_initialized = 1;
  IOHprofiler_free_memory(tmpc_dim);
  IOHprofiler_free_memory(tmpc_funId);
}

/**
 * Layer added to the transformed-problem evaluate_function by the logger
 */
static void logger_PBO_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  logger_PBO_data_t *logger = (logger_PBO_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  IOHprofiler_problem_t * inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);


  size_t i;
  if (!logger->is_initialized) {
    logger_PBO_initialize(logger, inner_problem);
  }
  if ((IOHprofiler_log_level >= IOHprofiler_DEBUG) && logger->number_of_evaluations == 0) {
    IOHprofiler_debug("%4lu: ", (unsigned long) inner_problem->suite_dep_index);
    IOHprofiler_debug("on problem %s ... ", IOHprofiler_problem_get_id(inner_problem));
  }
  IOHprofiler_evaluate_function(inner_problem, x, y);
  
  /*Update parameters' info*/
  logger->number_of_parameters = problem->number_of_parameters;
  if(logger->number_of_parameters > 0){
    if(logger->parameters != NULL){
        IOHprofiler_free_memory(logger->parameters);
    }
    logger->parameters = IOHprofiler_allocate_vector(logger->number_of_parameters);
    for(i = 0; i < logger->number_of_parameters; ++i)
      logger->parameters[i] = problem->parameters[i];
  }
  logger->last_fvalue = y[0];
  logger->written_last_eval = 0;
  if (logger->number_of_evaluations == 0 || y[0] > logger->best_fvalue) {
    logger->best_fvalue = y[0];

    for (i = 0; i < problem->number_of_variables; i++)
      logger->best_solution[i] = x[i];
  }
  logger->raw_value = inner_problem->raw_fitness[0];
  if(logger->number_of_evaluations == 0 || logger->raw_value > logger->best_raw_value)
    logger->best_raw_value = logger->raw_value;

  
  logger->number_of_evaluations++;
  if(logger->f_flag == 1){
    if (IOHprofiler_observer_update_trigger(logger->updating,y[0])) {
      logger->best_fvalue = y[0];
      for (i = 0; i < problem->number_of_variables; i++)
        logger->best_solution[i] = x[i];
        logger_PBO_write_data(
          logger->fdata_file, 
          logger->number_of_evaluations,
          y[0], 
          logger->best_fvalue,
          logger->best_raw_value,
          logger->raw_value,
          problem->parameters, 
          problem->number_of_parameters);
    }
  }
  if(logger->t_flag == 1){
    /* Add a line in the .tdat file each time an fevals trigger is reached.*/
    if (IOHprofiler_observer_evaluations_trigger(logger->evaluations, logger->number_of_evaluations)) {
      logger_PBO_write_data(
          logger->tdata_file, 
          logger->number_of_evaluations,
          y[0], 
          logger->best_fvalue,
          logger->best_raw_value,
          logger->raw_value,
          problem->parameters, 
          problem->number_of_parameters);
      logger->written_last_eval = 1;
    }
  }

  if(logger->i_flag == 1){
    if ( logger->number_of_evaluations % logger->interval == 0) {
      logger_PBO_write_data(
          logger->idata_file, 
          logger->number_of_evaluations,
          y[0], 
          logger->best_fvalue,         
          logger->best_raw_value,
          logger->raw_value,
          problem->parameters, 
          problem->number_of_parameters);
    }
  }

  if(logger->c_flag == 1){
    logger_PBO_write_data(
        logger->cdata_file, 
        logger->number_of_evaluations,
        y[0], 
        logger->best_fvalue,          
        logger->best_raw_value,
        logger->raw_value,
        problem->parameters, 
        problem->number_of_parameters);
  }
  /* Add sanity check for optimal f value */
  assert(y[0] <= logger->optimal_fvalue);

  /* Flush output so that impatient users can see progress. */
  if(logger->f_flag == 1)
    fflush(logger->fdata_file);
}

/**
 * Also serves as a finalize run method so. Must be called at the end
 * of Each run to correctly fill the index file
 *
 * TODO: make sure it is called at the end of each run or move the
 * writing into files to another function
 */
static void logger_PBO_free(void *stuff) {
  /* TODO: do all the "non simply freeing" stuff in another function
   * that can have problem as input
   */
  logger_PBO_data_t *logger = (logger_PBO_data_t *) stuff;

  if ((IOHprofiler_log_level >= IOHprofiler_DEBUG) && logger && logger->number_of_evaluations > 0) {
    IOHprofiler_debug("best f=%e after %lu fevals (done observing)\n", logger->best_fvalue,
        (unsigned long) logger->number_of_evaluations);
  }
  if (logger->index_file != NULL) {
    fprintf(logger->index_file, ":%lu|%.5e", (unsigned long) logger->number_of_evaluations,
        logger->best_fvalue);
    fclose(logger->index_file);
    logger->index_file = NULL;
  }
  if (logger->fdata_file != NULL) {
    fclose(logger->fdata_file);
    logger->fdata_file = NULL;
  }
  if (logger->tdata_file != NULL) {
    /* TODO: make sure it handles restarts well. i.e., it writes
     * at the end of a single run, not all the runs on a given
     * instance. Maybe start with forcing it to generate a new
     * "instance" of problem for each restart in the beginning
     */
    if (!logger->written_last_eval) {
      logger_PBO_write_data(logger->tdata_file, logger->number_of_evaluations, logger->last_fvalue,
          logger->best_fvalue, logger->best_raw_value, logger->raw_value, logger->parameters, logger->number_of_parameters);
    }
    fclose(logger->tdata_file);
    logger->tdata_file = NULL;
  }
  /*
  if (logger->rdata_file != NULL) {
    fclose(logger->rdata_file);
    logger->rdata_file = NULL;
  }*/
  if (logger->idata_file != NULL) {
    logger_PBO_write_data(logger->idata_file, logger->number_of_evaluations, logger->last_fvalue,
          logger->best_fvalue, logger->best_raw_value, logger->raw_value, logger->parameters, logger->number_of_parameters);
    fclose(logger->idata_file);
    logger->idata_file = NULL;
  }
  
  if (logger->cdata_file != NULL) {
    fclose(logger->cdata_file);
    logger->cdata_file = NULL;
  }

  if (logger->best_solution != NULL) {
    IOHprofiler_free_memory(logger->best_solution);
    logger->best_solution = NULL;
  }

  if (logger->targets != NULL){
    IOHprofiler_free_memory(logger->targets);
    logger->targets = NULL;
  }

  if (logger->evaluations != NULL){
    IOHprofiler_observer_evaluations_free(logger->evaluations);
    logger->evaluations = NULL;
  }

  if (logger->updating != NULL){
    IOHprofiler_observer_update_free(logger->updating);
    logger->updating = NULL;
  }

  if (logger->parameters != NULL){
    IOHprofiler_free_memory(logger->parameters);
    logger->parameters = NULL;
  }

  PBO_logger_is_open = 0;
}

static IOHprofiler_problem_t *logger_PBO(IOHprofiler_observer_t *observer, IOHprofiler_problem_t *inner_problem) {
  logger_PBO_data_t *logger_PBO;
  IOHprofiler_problem_t *problem;

  logger_PBO = (logger_PBO_data_t *) IOHprofiler_allocate_memory(sizeof(*logger_PBO));
  logger_PBO->observer = observer;

  if (inner_problem->number_of_objectives != 1) {
    IOHprofiler_warning("logger_PBO(): The IOHprofiler logger shouldn't be used to log a problem with %d objectives",
        inner_problem->number_of_objectives);
  }

  if (PBO_logger_is_open)
    IOHprofiler_error("The current IOHprofiler_logger (observer) must be closed before a new one is opened");
  /* This is the name of the folder which happens to be the algName */
  /*logger->path = IOHprofiler_strdup(observer->output_folder);*/
  logger_PBO->index_file = NULL;
  logger_PBO->fdata_file = NULL;
  logger_PBO->tdata_file = NULL;
  /* delete rdat files*/
  /*
  logger_PBO->rdata_file = NULL;
  */
  logger_PBO->cdata_file = NULL;
  logger_PBO->idata_file = NULL;
  logger_PBO->f_flag = 0;
  logger_PBO->t_flag = 0;
  logger_PBO->i_flag = 0;
  logger_PBO->c_flag = 0;



  
  logger_PBO->f_flag = 1;
  if(strcmp(observer->base_evaluation_triggers,"") != 0)
    logger_PBO->t_flag = 1;
  if(observer->number_interval_triggers != 0)
    logger_PBO->i_flag = 1;
  if(strcmp(observer->complete_triggers,"true") == 0)
    logger_PBO->c_flag = 1;
  logger_PBO->number_of_variables = inner_problem->number_of_variables;
  logger_PBO->inner_dimension = inner_problem->dimension;
  logger_PBO->number_of_parameters = inner_problem->number_of_parameters;
  logger_PBO->parameters = NULL;
  if (inner_problem->best_value == NULL) {
    /* IOHprofiler_error("Optimal f value must be defined for each problem in order for the logger to work properly"); */
    /* Setting the value to 0 results in the assertion y>=optimal_fvalue being susceptible to failure */
    IOHprofiler_warning("undefined optimal f value. Set to 0");
    logger_PBO->optimal_fvalue = 0;
  } else {
    logger_PBO->optimal_fvalue = *(inner_problem->best_value);
  }

  logger_PBO->number_of_evaluations = 0;
  logger_PBO->best_solution = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);
  /* TODO: the following inits are just to be in the safe side and
   * should eventually be removed. Some fields of the IOHprofiler_logger struct
   * might be useless
   */
  logger_PBO->function_id = IOHprofiler_problem_get_suite_dep_function(inner_problem);
  logger_PBO->instance_id = IOHprofiler_problem_get_suite_dep_instance(inner_problem);
  logger_PBO->written_last_eval = 1;
  logger_PBO->last_fvalue = -DBL_MAX;
  logger_PBO->is_initialized = 0;
  logger_PBO->best_fvalue = -DBL_MAX;
  logger_PBO->best_raw_value  = -DBL_MAX;
  /* Initialize triggers based on target values and number of evaluations */
  logger_PBO->targets = IOHprofiler_observer_targets(observer->number_target_triggers, observer->target_precision);
  logger_PBO->evaluations = IOHprofiler_observer_evaluations(observer->base_evaluation_triggers, inner_problem->number_of_variables);
  logger_PBO->updating = IOHprofiler_observer_update();
  logger_PBO->interval = observer->number_interval_triggers;
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, logger_PBO, logger_PBO_free, observer->observer_name);

  problem->evaluate_function = logger_PBO_evaluate;
  PBO_logger_is_open = 1;
  return problem;
}
#line 421 "code-experiments/src/profiler/IOHprofiler_observer.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/logger_WModel.c"
/**
 * @file logger_WModel.c
 * @brief Implementation of the IOHprofiler logger.
 *
 * Logs the performance of a single-objective optimizer on noisy or noiseless problems.
 * It produces four kinds of files:
 * - The "info" files ...
 * - The "dat" files ...
 * - The "tdat" files ...
 * - The "rdat" files ...
 */

/* TODO: Document this file in doxygen style! */
#ifndef LOGGER_WMODEL
#define LOGGER_WMODEL

#include <stdio.h>
#include <assert.h>
#include <limits.h>
#include <float.h>
#include <math.h>
#include <errno.h>
#include <stdarg.h>

#line 26 "code-experiments/src/profiler/../suite/WModel/logger_WModel.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_utilities.c"
/**
 * @file IOHprofiler_utilities.c
 * @brief Definitions of miscellaneous functions used throughout the IOHprofiler framework.
 */
#ifndef IOH_PROFILER_UTILITIES
#define IOH_PROFILER_UTILITIES

#line 1 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_platform.h"
/**
 * @file IOHprofiler_platform.h
 * @brief Automatic platform-dependent configuration of the IOHprofiler framework.
 *
 * Some platforms and standard conforming compilers require extra defines or includes to provide some
 * functionality.
 *
 * Because most feature defines need to be set before the first system header is included and we do not
 * know when a system header is included for the first time in the amalgamation, all internal files
 * that need these definitions should include this file before any system headers.
 */

#ifndef __COCO_PLATFORM__
#define __COCO_PLATFORM__

#include <stddef.h>

/* Definitions of IOHprofiler_PATH_MAX, IOHprofiler_path_separator, HAVE_GFA and HAVE_STAT heavily used by functions in
 * IOHprofiler_utilities.c */
#if defined(_WIN32) || defined(_WIN64) || defined(__MINGW64__) || defined(__CYGWIN__)
#include <windows.h>
static const char *IOHprofiler_path_separator = "\\";
#define IOHprofiler_PATH_MAX MAX_PATH
#define HAVE_GFA 1
#elif defined(__gnu_linux__)
#include <linux/limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__APPLE__)
#include <sys/stat.h>
#include <sys/syslimits.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif defined(__FreeBSD__)
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#elif (defined(__sun) || defined(sun)) && (defined(__SVR4) || defined(__svr4__))
/* Solaris */
#include <limits.h>
#include <sys/stat.h>
#include <sys/types.h>
static const char *IOHprofiler_path_separator = "/";
#define HAVE_STAT 1
#define IOHprofiler_PATH_MAX PATH_MAX
#else
#error Unknown platform
#endif
#if !defined(IOHprofiler_PATH_MAX)
#error IOHprofiler_PATH_MAX undefined
#endif

/* Definitions needed for creating and removing directories */
/* Separately handle the special case of Microsoft Visual Studio 2008 with x86_64-w64-mingw32-gcc */
#if _MSC_VER
#include <direct.h>
#elif defined(__MINGW32__) || defined(__MINGW64__)
#include <dirent.h>
#else
#include <dirent.h>

#ifdef __cplusplus
extern "C" {
#endif

/* To silence the compiler (implicit-function-declaration warning). */
/** @cond */
int rmdir(const char *pathname);
int unlink(const char *file_name);
int mkdir(const char *pathname, mode_t mode);
/** @endcond */
#endif

/* Definition of the S_IRWXU constant needed to set file permissions */
#if defined(HAVE_GFA)
#define S_IRWXU 0700
#endif

/* To silence the Visual Studio compiler (C4996 warnings in the python build). */
#ifdef _MSC_VER
#pragma warning(disable : 4996)
#endif

#ifdef __cplusplus
}
#endif

#endif
#line 9 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_utilities.c"

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#line 18 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_utilities.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_internal.h"
/**
 * @file IOHprofiler_internal.h
 * @brief Definitions of internal IOHprofiler structures and typedefs.
 *
 * These are used throughout the IOHprofiler code base but should not be used by any external code.
 */

#ifndef __IOHprofiler_INTERNAL__
#define __IOHprofiler_INTERNAL__

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************************************/
/**
 * @brief The data free function type.
 *
 * This is a template for functions that free the contents of data (used to free the contents of data
 * fields in IOHprofiler_problem, IOHprofiler_suite and IOHprofiler_observer).
 */
typedef void (*IOHprofiler_data_free_function_t)(void *data);

/**
 * @brief The problem free function type.
 *
 * This is a template for functions that free the problem structure.
 */
typedef void (*IOHprofiler_problem_free_function_t)(IOHprofiler_problem_t *problem);

/**
 * @brief The initial solution function type.
 *
 * This is a template for functions that return an initial solution of the problem.
 */
typedef void (*IOHprofiler_initial_solution_function_t)(const IOHprofiler_problem_t *problem, int *x);

/**
 * @brief The evaluate function type.
 *
 * This is a template for functions that perform an evaluation of the problem (to evaluate the problem
 * function, the problems constraints etc.).
 */
typedef void (*IOHprofiler_evaluate_function_t)(IOHprofiler_problem_t *problem, const int *x, double *y);

/**
 * @brief The recommend solutions function type.
 *
 * This is a template for functions that log a recommended solution.
 */
typedef void (*IOHprofiler_recommend_function_t)(IOHprofiler_problem_t *problem, const int *x);

/**
 * @brief The allocate logger function type.
 *
 * This is a template for functions that allocate a logger (wrap a logger around the given problem and return
 * the wrapped problem).
 */
typedef IOHprofiler_problem_t *(*IOHprofiler_logger_allocate_function_t)(IOHprofiler_observer_t *observer,
                                                                         IOHprofiler_problem_t *problem);

/**
 * @brief The transformed IOHprofiler problem data type.
 *
 * This is a type of a generic structure for a transformed ("outer") IOHprofiler_problem. It makes possible the
 * wrapping of problems as layers of an onion. Initialized in the IOHprofiler_problem_transformed_allocate function,
 * it makes the current ("outer") transformed problem a "derived problem class", which inherits from the
 * "inner" problem, the "base class".
 *
 * From the perspective of the inner problem:
 * - data holds the meta-information to administer the inheritance
 * - data->data holds the additional fields of the derived class (the outer problem)
 * - data->inner_problem points to the inner problem (now we have a linked list)
 */
typedef struct {
    IOHprofiler_problem_t *inner_problem;                /**< @brief Pointer to the inner problem */
    void *data;                                          /**< @brief Pointer to data, which enables further
                                                  wrapping of the problem */
    IOHprofiler_data_free_function_t data_free_function; /**< @brief Function to free the contents of data */
} IOHprofiler_problem_transformed_data_t;

/**
 * @brief The free logger function type.
 *
 * This is a template for functions that free a logger.
 */
typedef void (*IOHprofiler_logger_free_function_t)(void *logger);

/**
 * @brief The stacked IOHprofiler problem data type.
 *
 * This is a type of a structure used when stacking two problems (especially useful for constructing
 * multi-objective problems).
 */
typedef struct {
    IOHprofiler_problem_t *problem1; /**< @brief Pointer to the first problem (objective) */
    IOHprofiler_problem_t *problem2; /**< @brief Pointer to the second problem (objective) */
} IOHprofiler_problem_stacked_data_t;

/**
 * @brief The option keys data type.
 *
 * This is a type of a structure used to contain a set of known option keys (used by suites and observers).
 */
typedef struct {
    size_t count; /**< @brief Number of option keys */
    char **keys;  /**< @brief Pointer to option keys */
} IOHprofiler_option_keys_t;

/***********************************************************************************************************/

/**
 * @brief The IOHprofiler problem structure.
 *
 * This is one of the main structures in IOHprofiler. It contains information about a problem to be optimized. The
 * problems can be wrapped around each other (similar to the onion layers) by means of the data field and
 * the IOHprofiler_problem_transformed_data_t structure creating some kind of "object inheritance". Even the logger
 * is considered as just another IOHprofiler_problem instance wrapped around the original problem.
 */
struct IOHprofiler_problem_s {
    IOHprofiler_initial_solution_function_t initial_solution;  /**< @brief  The function for creating an initial solution. */
    IOHprofiler_evaluate_function_t evaluate_function;         /**< @brief  The function for evaluating the problem. */
    IOHprofiler_recommend_function_t recommend_solution;       /**< @brief  The function for recommending a solution. */
    IOHprofiler_problem_free_function_t problem_free_function; /**< @brief  The function for freeing this problem. */

    size_t dimension; /**< @brief Number of variables expected before any transformation, used for logging files. */
    size_t number_of_variables;  /**< @brief Number of variables expected by the function, i.e.
                                       problem dimension */
    size_t number_of_objectives; /**< @brief Number of objectives. */
    size_t number_of_parameters; /**<  IOHprofiler @brief Number of parameters. */

    int *smallest_values_of_interest; /**< @brief The lower bounds of the ROI in the decision space. */
    int *largest_values_of_interest;  /**< @brief The upper bounds of the ROI in the decision space. */

    double *best_value;  /**< @brief Optimal (smallest) function value */
    double *nadir_value; /**< @brief The nadir point (defined when number_of_objectives > 1) */
    int *best_parameter; /**< @brief Optimal decision vector (defined only when unique) */
    double *parameters;  /** IOHprofiler @brief parameters setting */
    double *raw_fitness;

    char *problem_name; /**< @brief Problem name. */
    char *problem_id;   /**< @brief Problem ID (unique in the containing suite) */
    char *problem_type; /**< @brief Problem type */

    size_t evaluations; /**< @brief Number of evaluations performed on the problem. */

    /* Convenience fields for output generation */

    double final_target_delta[1];       /**< @brief Final target delta. */
    double best_observed_fvalue[1];     /**< @brief The best observed value so far. */
    size_t best_observed_evaluation[1]; /**< @brief The evaluation when the best value so far was achieved. */

    /* Fields depending on the containing benchmark suite */

    IOHprofiler_suite_t *suite; /**< @brief Pointer to the containing suite (NULL if not given) */
    size_t suite_dep_index;     /**< @brief Suite-depending problem index (starting from 0) */
    size_t suite_dep_function;  /**< @brief Suite-depending function */
    size_t suite_dep_instance;  /**< @brief Suite-depending instance */

    void *data; /**< @brief Pointer to a data instance @see IOHprofiler_problem_transformed_data_t */
};

/**
 * @brief The IOHprofiler observer structure.
 *
 * An observer observes the whole benchmark process. It is independent of suites and problems. Each time a
 * new problem of the suite is being observed, the observer initializes a new logger (wraps the observed
 * problem with the corresponding logger).
 */
struct IOHprofiler_observer_s {
    int is_active;         /**< @brief Whether the observer is active (the logger will log some output). */
    char *observer_name;   /**< @brief Name of the observer for identification purposes. */
    char *result_folder;   /**< @brief Name of the result folder. */
    char *algorithm_name;  /**< @brief Name of the algorithm to be used in logger output. */
    char *algorithm_info;  /**< @brief Additional information on the algorithm to be used in logger output. */
    char *parameters_name; /**< @brief Name of recorded parameters to be used in logger output. */
    size_t number_target_triggers;
    /**< @brief The number of targets between each 10**i and 10**(i+1). */
    double target_precision; /**< @brief The minimal precision used for targets. */
    size_t number_evaluation_triggers;
    /**< @brief The number of triggers between each 10**i and 10**(i+1) evaluation number. */
    char *base_evaluation_triggers;
    /**< @brief The "base evaluations" used to evaluations that trigger logging. */
    size_t number_interval_triggers;
    /**< @brief The size of interval between two triggers. */
    char *complete_triggers; /**< @brief The symbol for recording all evaluation. */

    int precision_x; /**< @brief Output precision for decision variables. */
    int precision_f; /**< @brief Output precision for function values. */
    void *data;      /**< @brief Void pointer that can be used to point to data specific to an observer. */

    IOHprofiler_data_free_function_t data_free_function;             /**< @brief  The function for freeing this observer. */
    IOHprofiler_logger_allocate_function_t logger_allocate_function; /**< @brief  The function for allocating the logger. */
    IOHprofiler_logger_free_function_t logger_free_function;         /**< @brief  The function for freeing the logger. */
};

/**
 * @brief The IOHprofiler suite structure.
 *
 * A suite is a collection of problems constructed by a Cartesian product of the suite's optimization
 * functions, dimensions and instances. The functions and dimensions are fixed for a suite with some name,
 * while the instances are defined dynamically. The suite can be filtered - only the chosen functions,
 * dimensions and instances will be taken into account when iterating through the suite.
 */
struct IOHprofiler_suite_s {
    char *suite_name; /**< @brief Name of the suite. */

    size_t number_of_dimensions; /**< @brief Number of dimensions contained in the suite. */
    size_t *dimensions;          /**< @brief The dimensions contained in the suite. */

    size_t number_of_functions; /**< @brief Number of functions contained in the suite. */
    size_t *functions;          /**< @brief The functions contained in the suite. */

    size_t number_of_instances; /**< @brief Number of instances contained in the suite. */
    char *default_instances;    /**< @brief The instances contained in the suite by default. */
    size_t *instances;          /**< @brief The instances contained in the suite. */

    IOHprofiler_problem_t *current_problem; /**< @brief Pointer to the currently tackled problem. */
    long current_dimension_idx;             /**< @brief The dimension index of the currently tackled problem. */
    long current_function_idx;              /**< @brief The function index of the currently tackled problem. */
    long current_instance_idx;              /**< @brief The instance index of the currently tackled problem. */

    void *data; /**< @brief Void pointer that can be used to point to data specific to a suite. */

    IOHprofiler_data_free_function_t data_free_function; /**< @brief The function for freeing this suite. */
};

#ifdef __cplusplus
}
#endif
#endif
#line 19 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_utilities.c"
#line 20 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_utilities.c"

/***********************************************************************************************************/

/**
 * @brief Initializes the logging level to IOHprofiler_INFO.
 */
static IOHprofiler_log_level_type_e IOHprofiler_log_level = IOHprofiler_INFO;

/**
 * @param log_level Denotes the level of information given to the user through the standard output and
 * error streams. Can take on the values:
 * - "error" (only error messages are output),
 * - "warning" (only error and warning messages are output),
 * - "info" (only error, warning and info messages are output) and
 * - "debug" (all messages are output).
 * - "" does not set a new value
 * The default value is info.
 *
 * @return The previous IOHprofiler_log_level value as an immutable string.
 */
const char *IOHprofiler_set_log_level(const char *log_level) {
    IOHprofiler_log_level_type_e previous_log_level = IOHprofiler_log_level;

    if (strcmp(log_level, "error") == 0)
        IOHprofiler_log_level = IOHprofiler_ERROR;
    else if (strcmp(log_level, "warning") == 0)
        IOHprofiler_log_level = IOHprofiler_WARNING;
    else if (strcmp(log_level, "info") == 0)
        IOHprofiler_log_level = IOHprofiler_INFO;
    else if (strcmp(log_level, "debug") == 0)
        IOHprofiler_log_level = IOHprofiler_DEBUG;
    else if (strcmp(log_level, "") == 0) {
        /* Do nothing */
    } else {
        IOHprofiler_warning("IOHprofiler_set_log_level(): unknown level %s", log_level);
    }

    if (previous_log_level == IOHprofiler_ERROR)
        return "error";
    else if (previous_log_level == IOHprofiler_WARNING)
        return "warning";
    else if (previous_log_level == IOHprofiler_INFO)
        return "info";
    else if (previous_log_level == IOHprofiler_DEBUG)
        return "debug";
    else {
        IOHprofiler_error("IOHprofiler_set_log_level(): unknown previous log level");
        return "";
    }
}

/***********************************************************************************************************/

/**
 * @name Methods regarding file, directory and path manipulations
 */
/**@{*/
/**
 * @brief Creates a platform-dependent path from the given strings.
 *
 * @note The last argument must be NULL.
 * @note The first parameter must be able to accommodate path_max_length characters and the length
 * of the joined path must not exceed path_max_length characters.
 * @note Should work cross-platform.
 *
 * Usage examples:
 * - IOHprofiler_join_path(base_path, 100, folder1, folder2, folder3, NULL) creates base_path/folder1/folder2/folder3
 * - IOHprofiler_join_path(base_path, 100, folder1, file_name, NULL) creates base_path/folder1/file_name
 * @param path The base path; it's also where the joined path is stored to.
 * @param path_max_length The maximum length of the path.
 * @param ... Additional strings, must end with NULL
 */
static void IOHprofiler_join_path(char *path, const size_t path_max_length, ...) {
    const size_t path_separator_length = strlen(IOHprofiler_path_separator);
    va_list args;
    char *path_component;
    size_t path_length = strlen(path);

    va_start(args, path_max_length);
    while (NULL != (path_component = va_arg(args, char *))) {
        size_t component_length = strlen(path_component);
        if (path_length + path_separator_length + component_length >= path_max_length) {
            IOHprofiler_error("IOHprofiler_join_path() failed because the ${path} is too short.");
            return; /* never reached */
        }
        /* Both should be safe because of the above check. */
        if (strlen(path) > 0)
            strncat(path, IOHprofiler_path_separator, path_max_length - strlen(path) - 1);
        strncat(path, path_component, path_max_length - strlen(path) - 1);
    }
    va_end(args);
}

/**
 * @brief Checks if the given directory exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a directory and 0 otherwise.
 */
static int IOHprofiler_directory_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Checks if the given file exists.
 *
 * @note Should work cross-platform.
 *
 * @param path The given path.
 *
 * @return 1 if the path exists and corresponds to a file and 0 otherwise.
 */
static int IOHprofiler_file_exists(const char *path) {
    int res;
#if defined(HAVE_GFA)
    DWORD dwAttrib = GetFileAttributesA(path);
    res = (dwAttrib != INVALID_FILE_ATTRIBUTES) && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
#elif defined(HAVE_STAT)
    struct stat buf;
    res = (!stat(path, &buf) && !S_ISDIR(buf.st_mode));
#else
#error Ooops
#endif
    return res;
}

/**
 * @brief Calls the right mkdir() method (depending on the platform).
 *
 * @param path The directory path.
 *
 * @return 0 on successful completion, and -1 on error.
 */
static int IOHprofiler_mkdir(const char *path) {
#if _MSC_VER
    return _mkdir(path);
#elif defined(__MINGW32__) || defined(__MINGW64__)
    return mkdir(path);
#else
    return mkdir(path, S_IRWXU);
#endif
}

/**
 * @brief Creates a directory with full privileges for the user.
 *
 * @note Should work cross-platform.
 *
 * @param path The directory path.
 */
static void IOHprofiler_create_directory(const char *path) {
    char *tmp = NULL;
    char *p;
    size_t len = strlen(path);
    char path_sep = IOHprofiler_path_separator[0];

    /* Nothing to do if the path exists. */
    if (IOHprofiler_directory_exists(path))
        return;

    tmp = IOHprofiler_strdup(path);
    /* Remove possible trailing slash */
    if (tmp[len - 1] == path_sep)
        tmp[len - 1] = 0;
    for (p = tmp + 1; *p; p++) {
        if (*p == path_sep) {
            *p = 0;
            if (!IOHprofiler_directory_exists(tmp)) {
                if (0 != IOHprofiler_mkdir(tmp))
                    IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
            }
            *p = path_sep;
        }
    }
    if (0 != IOHprofiler_mkdir(tmp))
        IOHprofiler_error("IOHprofiler_create_path(): failed creating %s", tmp);
    IOHprofiler_free_memory(tmp);
    return;
}

/* Commented to silence the compiler (unused function warning) */
#if 0

#endif

/**
 * @brief Creates a unique directory from the given path.
 *
 * If the given path does not yet exit, it is left as is, otherwise it is changed(!) by appending a number
 * to it. If path already exists, path-01 will be tried. If this one exists as well, path-02 will be tried,
 * and so on. If path-99 exists as well, the function throws an error.
 */
static void IOHprofiler_create_unique_directory(char **path) {
    int counter = 1;
    char *new_path;

    /* Create the path if it does not yet exist */
    if (!IOHprofiler_directory_exists(*path)) {
        IOHprofiler_create_directory(*path);
        return;
    }

    while (counter < 999) {
        new_path = IOHprofiler_strdupf("%s-%03d", *path, counter);

        if (!IOHprofiler_directory_exists(new_path)) {
            IOHprofiler_free_memory(*path);
            *path = new_path;
            IOHprofiler_create_directory(*path);
            return;
        } else {
            counter++;
            IOHprofiler_free_memory(new_path);
        }
    }

    IOHprofiler_error("IOHprofiler_create_unique_path(): could not create a unique path with name %s", *path);
    return; /* Never reached */
}

/**
 * The method should work across different platforms/compilers.
 *
 * @path The path to the directory
 *
 * @return 0 on successful completion, and -1 on error.
 */
int IOHprofiler_remove_directory(const char *path) {
#if _MSC_VER
    WIN32_FIND_DATA find_data_file;
    HANDLE find_handle = NULL;
    char *buf;
    int r = -1;
    int r2 = -1;

    buf = IOHprofiler_strdupf("%s\\*.*", path);
    /* Nothing to do if the folder does not exist */
    if ((find_handle = FindFirstFile(buf, &find_data_file)) == INVALID_HANDLE_VALUE) {
        IOHprofiler_free_memory(buf);
        return 0;
    }
    IOHprofiler_free_memory(buf);

    do {
        r = 0;

        /* Skip the names "." and ".." as we don't want to recurse on them */
        if (strcmp(find_data_file.cFileName, ".") != 0 && strcmp(find_data_file.cFileName, "..") != 0) {
            /* Build the new path using the argument path the file/folder name we just found */
            buf = IOHprofiler_strdupf("%s\\%s", path, find_data_file.cFileName);

            if (find_data_file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                /* Buf is a directory, recurse on it */
                r2 = IOHprofiler_remove_directory(buf);
            } else {
                /* Buf is a file, delete it */
                /* Careful, DeleteFile returns 0 if it fails and nonzero otherwise! */
                r2 = -(DeleteFile(buf) == 0);
            }

            IOHprofiler_free_memory(buf);
        }

        r = r2;

    } while (FindNextFile(find_handle, &find_data_file)); /* Find the next file */

    FindClose(find_handle);

    if (!r) {
        /* Path is an empty directory, delete it */
        /* Careful, RemoveDirectory returns 0 if it fails and nonzero otherwise! */
        r = -(RemoveDirectory(path) == 0);
    }

    return r;
#else
    DIR *d = opendir(path);
    int r = -1;
    int r2 = -1;
    char *buf;

    /* Nothing to do if the folder does not exist */
    if (!IOHprofiler_directory_exists(path))
        return 0;

    if (d) {
        struct dirent *p;

        r = 0;

        while (!r && (p = readdir(d))) {
            /* Skip the names "." and ".." as we don't want to recurse on them */
            if (!strcmp(p->d_name, ".") || !strcmp(p->d_name, "..")) {
                continue;
            }

            buf = IOHprofiler_strdupf("%s/%s", path, p->d_name);
            if (buf) {
                if (IOHprofiler_directory_exists(buf)) {
                    /* Buf is a directory, recurse on it */
                    r2 = IOHprofiler_remove_directory(buf);
                } else {
                    /* Buf is a file, delete it */
                    r2 = unlink(buf);
                }
            }
            IOHprofiler_free_memory(buf);

            r = r2;
        }

        closedir(d);
    }

    if (!r) {
        /* Path is an empty directory, delete it */
        r = rmdir(path);
    }

    return r;
#endif
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding memory allocations
 */
/**@{*/
double *IOHprofiler_allocate_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(double);
    return (double *)IOHprofiler_allocate_memory(block_size);
}

int *IOHprofiler_allocate_int_vector(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(int);
    return (int *)IOHprofiler_allocate_memory(block_size);
}
/**
 * @brief Allocates memory for a vector and sets all its elements to value.
 */
static double *IOHprofiler_allocate_vector_with_value(const size_t number_of_elements, double value) {
    const size_t block_size = number_of_elements * sizeof(double);
    double *vector = (double *)IOHprofiler_allocate_memory(block_size);
    size_t i;

    for (i = 0; i < number_of_elements; i++)
        vector[i] = value;

    return vector;
}

/**
 * @brief Safe memory allocation for a vector with size_t elements that either succeeds or triggers a
 * IOHprofiler_error.
 */
static size_t *IOHprofiler_allocate_vector_size_t(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(size_t);
    return (size_t *)IOHprofiler_allocate_memory(block_size);
}

static char *IOHprofiler_allocate_string(const size_t number_of_elements) {
    const size_t block_size = number_of_elements * sizeof(char);
    return (char *)IOHprofiler_allocate_memory(block_size);
}

static double *IOHprofiler_duplicate_vector(const double *src, const size_t number_of_elements) {
    size_t i;
    double *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}

static int *IOHprofiler_duplicate_int_vector(const int *src, const size_t number_of_elements) {
    size_t i;
    int *dst;

    assert(src != NULL);
    assert(number_of_elements > 0);

    dst = IOHprofiler_allocate_int_vector(number_of_elements);
    for (i = 0; i < number_of_elements; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods regarding string options
 */
/**@{*/

/**
 * @brief Allocates an option keys structure holding the given number of option keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_allocate(const size_t count, const char **keys) {
    size_t i;
    IOHprofiler_option_keys_t *option_keys;

    if ((count == 0) || (keys == NULL))
        return NULL;

    option_keys = (IOHprofiler_option_keys_t *)IOHprofiler_allocate_memory(sizeof(*option_keys));

    option_keys->keys = (char **)IOHprofiler_allocate_memory(count * sizeof(char *));
    for (i = 0; i < count; i++) {
        assert(keys[i]);
        option_keys->keys[i] = IOHprofiler_strdup(keys[i]);
    }
    option_keys->count = count;

    return option_keys;
}

/**
 * @brief Frees the given option keys structure.
 */
static void IOHprofiler_option_keys_free(IOHprofiler_option_keys_t *option_keys) {
    size_t i;

    if (option_keys) {
        for (i = 0; i < option_keys->count; i++) {
            IOHprofiler_free_memory(option_keys->keys[i]);
        }
        IOHprofiler_free_memory(option_keys->keys);
        IOHprofiler_free_memory(option_keys);
    }
}

/**
 * @brief Returns redundant option keys (the ones present in given_option_keys but not in known_option_keys).
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys_get_redundant(const IOHprofiler_option_keys_t *known_option_keys,
                                                                        const IOHprofiler_option_keys_t *given_option_keys) {
    size_t i, j, count = 0;
    int found;
    char **redundant_keys;
    IOHprofiler_option_keys_t *redundant_option_keys;

    assert(known_option_keys != NULL);
    assert(given_option_keys != NULL);

    /* Find the redundant keys */
    redundant_keys = (char **)IOHprofiler_allocate_memory(given_option_keys->count * sizeof(char *));
    for (i = 0; i < given_option_keys->count; i++) {
        found = 0;
        for (j = 0; j < known_option_keys->count; j++) {
            if (strcmp(given_option_keys->keys[i], known_option_keys->keys[j]) == 0) {
                found = 1;
                break;
            }
        }
        if (!found) {
            redundant_keys[count++] = IOHprofiler_strdup(given_option_keys->keys[i]);
        }
    }
    redundant_option_keys = IOHprofiler_option_keys_allocate(count, (const char **)redundant_keys);

    /* Free memory */
    for (i = 0; i < count; i++) {
        IOHprofiler_free_memory(redundant_keys[i]);
    }
    IOHprofiler_free_memory(redundant_keys);

    return redundant_option_keys;
}

/**
 * @brief Adds additional option keys to the given basic option keys (changes the basic keys).
 */
static void IOHprofiler_option_keys_add(IOHprofiler_option_keys_t **basic_option_keys,
                                        const IOHprofiler_option_keys_t *additional_option_keys) {
    size_t i, j;
    size_t new_count;
    char **new_keys;
    IOHprofiler_option_keys_t *new_option_keys;

    assert(*basic_option_keys != NULL);
    if (additional_option_keys == NULL)
        return;

    /* Construct the union of both keys */
    new_count = (*basic_option_keys)->count + additional_option_keys->count;
    new_keys = (char **)IOHprofiler_allocate_memory(new_count * sizeof(char *));
    for (i = 0; i < (*basic_option_keys)->count; i++) {
        new_keys[i] = IOHprofiler_strdup((*basic_option_keys)->keys[i]);
    }
    for (j = 0; j < additional_option_keys->count; j++) {
        new_keys[(*basic_option_keys)->count + j] = IOHprofiler_strdup(additional_option_keys->keys[j]);
    }
    new_option_keys = IOHprofiler_option_keys_allocate(new_count, (const char **)new_keys);

    /* Free the old basic keys */
    IOHprofiler_option_keys_free(*basic_option_keys);
    *basic_option_keys = new_option_keys;
    for (i = 0; i < new_count; i++) {
        IOHprofiler_free_memory(new_keys[i]);
    }
    IOHprofiler_free_memory(new_keys);
}

/**
 * @brief Creates an instance of option keys from the given string of options containing keys and values
 * separated by colons.
 *
 * @note Relies heavily on the "key: value" format and might fail if the number of colons doesn't match the
 * number of keys.
 */
static IOHprofiler_option_keys_t *IOHprofiler_option_keys(const char *option_string) {
    size_t i;
    char **keys;
    IOHprofiler_option_keys_t *option_keys = NULL;
    char *string_to_parse, *key;

    /* Check for empty string */
    if ((option_string == NULL) || (strlen(option_string) == 0)) {
        return NULL;
    }

    /* Split the options w.r.t ':' */
    keys = IOHprofiler_string_split(option_string, ':');

    if (keys) {
        /* Keys now contain something like this: "values_of_previous_key this_key" except for the first, which
     * contains only the key and the last, which contains only the previous values */
        for (i = 0; *(keys + i); i++) {
            string_to_parse = IOHprofiler_strdup(*(keys + i));

            /* Remove any leading and trailing spaces */
            string_to_parse = IOHprofiler_string_trim(string_to_parse);

            /* Stop if this is the last substring (contains a value and no key) */
            if ((i > 0) && (*(keys + i + 1) == NULL)) {
                IOHprofiler_free_memory(string_to_parse);
                break;
            }

            /* Disregard everything before the last space */
            key = strrchr(string_to_parse, ' ');
            if ((key == NULL) || (i == 0)) {
                /* No spaces left (or this is the first key), everything is the key */
                key = string_to_parse;
            } else {
                /* Move to the start of the key (one char after the space) */
                key++;
            }

            /* Put the key in keys */
            IOHprofiler_free_memory(*(keys + i));
            *(keys + i) = IOHprofiler_strdup(key);
            IOHprofiler_free_memory(string_to_parse);
        }

        option_keys = IOHprofiler_option_keys_allocate(i, (const char **)keys);

        /* Free the keys */
        for (i = 0; *(keys + i); i++) {
            IOHprofiler_free_memory(*(keys + i));
        }
        IOHprofiler_free_memory(keys);
    }

    return option_keys;
}

/**
 * @brief Creates and returns a string containing the info_string and all keys from option_keys.
 *
 * Can be used to output information about the given option_keys.
 */
static char *IOHprofiler_option_keys_get_output_string(const IOHprofiler_option_keys_t *option_keys,
                                                       const char *info_string) {
    size_t i;
    char *string = NULL, *new_string;

    if ((option_keys != NULL) && (option_keys->count > 0)) {
        string = IOHprofiler_strdup(info_string);
        for (i = 0; i < option_keys->count; i++) {
            new_string = IOHprofiler_strdupf("%s %s\n", string, option_keys->keys[i]);
            IOHprofiler_free_memory(string);
            string = new_string;
        }
    }

    return string;
}

/**
 * @brief Parses options in the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - value needs to be a single string (no spaces allowed)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read(const char *options, const char *name, const char *format, void *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing whitespaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    return sscanf(&options[i2], format, pointer);
}

/**
 * @brief Reads an integer from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be an integer
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_int(const char *options, const char *name, int *pointer) {
    return IOHprofiler_options_read(options, name, " %i", pointer);
}

/**
 * @brief Reads a size_t from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a size_t
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_size_t(const char *options, const char *name, size_t *pointer) {
    return IOHprofiler_options_read(options, name, "%lu", pointer);
}

/**
 * @brief Reads a double value from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a double
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_double(const char *options, const char *name, double *pointer) {
    return IOHprofiler_options_read(options, name, "%lf", pointer);
}

/**
 * @brief Reads a string from options using the form "name1: value1 name2: value2".
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 * - the value corresponding to the given name needs to be a string - either a single word or multiple words
 * in double quotes
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_string(const char *options, const char *name, char *pointer) {
    long i1, i2;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    if (options[i2] == '\"') {
        /* The value starts with a quote: read everything between two quotes into a string */
        return sscanf(&options[i2], "\"%[^\"]\"", pointer);
    } else
        return sscanf(&options[i2], "%s", pointer);
}

/**
 * @brief Reads (possibly delimited) values from options using the form "name1: value1,value2,value3 name2: value4",
 * i.e. reads all characters from the corresponding name up to the next whitespace or end of string.
 *
 * Formatting requirements:
 * - name and value need to be separated by a colon (spaces are optional)
 *
 * @return The number of successful assignments.
 */
static int IOHprofiler_options_read_values(const char *options, const char *name, char *pointer) {
    long i1, i2;
    int i;

    if ((!options) || (strlen(options) == 0))
        return 0;

    i1 = IOHprofiler_strfind(options, name);
    if (i1 < 0)
        return 0;
    i2 = i1 + IOHprofiler_strfind(&options[i1], ":") + 1;

    /* Remove trailing white spaces */
    while (isspace((unsigned char)options[i2]))
        i2++;

    if (i2 <= i1) {
        return 0;
    }

    i = 0;
    while (!isspace((unsigned char)options[i2 + i]) && (options[i2 + i] != '\0')) {
        pointer[i] = options[i2 + i];
        i++;
    }
    pointer[i] = '\0';
    return i;
}
/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods implementing functions on double values not contained in C89 standard
 */
/**@{*/

/**
 * @brief Rounds the given double to the nearest integer.
 */
static double IOHprofiler_double_round(const double number) {
    return floor(number + 0.5);
}

/**
 * @brief Returns the maximum of a and b.
 */
static double IOHprofiler_double_max(const double a, const double b) {
    if (a >= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Returns the minimum of a and b.
 */
static double IOHprofiler_double_min(const double a, const double b) {
    if (a <= b) {
        return a;
    } else {
        return b;
    }
}

/**
 * @brief Performs a "safer" double to size_t conversion.
 */
static size_t IOHprofiler_double_to_size_t(const double number) {
    return (size_t)IOHprofiler_double_round(number);
}

/**
 * @brief  Returns 1 if |a - b| < precision and 0 otherwise.
 */
static int IOHprofiler_double_almost_equal(const double a, const double b, const double precision) {
    return (fabs(a - b) < precision);
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Methods handling NAN and INFINITY
 */
/**@{*/

/**
 * @brief Returns 1 if x is NAN and 0 otherwise.
 */
static int IOHprofiler_is_nan(const int x) {
    /*return (isnan(x) || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
*/
    return (0 || (x != x) || !(x == x) || ((x >= NAN / (1 + 1e-9)) && (x <= NAN * (1 + 1e-9))));
}

/**
 * @brief Returns 1 if the input vector of dimension dim contains any NAN values and 0 otherwise.
 */
static int IOHprofiler_vector_contains_nan(const int *x, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        if (IOHprofiler_is_nan(x[i]))
            return 1;
    }
    return 0;
}

/**
 * @brief Sets all dim values of y to NAN.
 */
static void IOHprofiler_vector_set_to_nan(double *y, const size_t dim) {
    size_t i;
    for (i = 0; i < dim; i++) {
        y[i] = NAN;
    }
}

/**
 * @brief Returns 1 if x is INFINITY and 0 otherwise.
 */
static int IOHprofiler_is_inf(const int x) {
    if (IOHprofiler_is_nan(x))
        return 0;
    /*return (isinf(x) || (x <= -INFINITY) || (x >= INFINITY));*/
    return (0 || (x <= -INFINITY) || (x >= INFINITY));
}

/**@}*/

/***********************************************************************************************************/

/**
 * @name Miscellaneous methods
 */
/**@{*/

/**
 * @brief Returns the current time as a string.
 *
 * The caller is responsible for freeing the allocated memory using IOHprofiler_free_memory().
 */
static char *IOHprofiler_current_time_get_string(void) {
    time_t timer;
    char *time_string = IOHprofiler_allocate_string(30);
    struct tm *tm_info;
    time(&timer);
    tm_info = localtime(&timer);
    assert(tm_info != NULL);
    strftime(time_string, 30, "%d.%m.%y %H:%M:%S", tm_info);
    return time_string;
}

/**
 * @brief Returns the number of positive numbers pointed to by numbers (the count stops when the first
 * 0 is encountered of max_count numbers have been read).
 *
 * If there are more than max_count numbers, a IOHprofiler_error is raised. The name argument is used
 * only to provide more informative output in case of any problems.
 */
static size_t IOHprofiler_count_numbers(const size_t *numbers, const size_t max_count, const char *name) {
    size_t count = 0;
    while ((count < max_count) && (numbers[count] != 0)) {
        count++;
    }
    if (count == max_count) {
        IOHprofiler_error("IOHprofiler_count_numbers(): over %lu numbers in %s", (unsigned long)max_count, name);
        return 0; /* Never reached*/
    }

    return count;
}

/**@}*/

/***********************************************************************************************************/
#endif
#line 27 "code-experiments/src/profiler/../suite/WModel/logger_WModel.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_problem.c"
/**
 * @file IOHprofiler_problem.c
 * @brief Definitions of functions regarding IOHprofiler problems.
 */
#ifndef IOH_PROFILER_PROBLEM
#define IOH_PROFILER_PROBLEM

#include <float.h>
#line 10 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_problem.c"
#line 11 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_problem.c"

#line 13 "code-experiments/src/profiler/../suite/WModel/../../profiler/IOHprofiler_problem.c"

/**
 * Evaluates the problem function, increases the number of evaluations and updates the best observed value
 * and the best observed evaluation number.
 *
 * @note Both x and y must point to correctly sized allocated memory regions.
 *
 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 * @param y The objective vector that is the result of the evaluation (in single-objective problems only the
 * first vector item is being set). Currently multi-objective is not supported.
 * @param number_of_parameters The number of parameters need to be logged. Set as zero by default.
 * @param parameters The list of parameters. Set as NULL by default.
 */
void IOHprofiler_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {

    assert(problem != NULL);
    assert(problem->evaluate_function != NULL);
    problem->evaluate_function(problem, x, y);
    problem->evaluations++; /* each derived class has its own counter, only the most outer will be visible */

    /* A little bit of bookkeeping */
    if (y[0] > problem->best_observed_fvalue[0]) {
        problem->best_observed_fvalue[0] = y[0];
        problem->best_observed_evaluation[0] = problem->evaluations;
    }
}

/**
 * Evaluates and logs the given solution (as the IOHprofiler_evaluate_function), but does not return the evaluated
 * value.
 *
 * @note None of the observers implements this function yet!
 * @note x must point to a correctly sized allocated memory region.

 * @param problem The given IOHprofiler problem.
 * @param x The decision vector.
 */
void IOHprofiler_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    assert(problem != NULL);
    if (problem->recommend_solution == NULL) {
        IOHprofiler_error("IOHprofiler_recommend_solutions(): No recommend solution function implemented for problem %s",
                          problem->problem_id);
    }
    problem->recommend_solution(problem, x);
}

/**
 * @brief Allocates a new IOHprofiler_problem_t for the given number of variables and number of objectives.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate(const size_t number_of_variables,
                                                           const size_t number_of_objectives) {
    IOHprofiler_problem_t *problem;
    problem = (IOHprofiler_problem_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    /* Initialize fields to sane/safe defaults */
    problem->initial_solution = NULL;
    problem->evaluate_function = NULL;
    problem->recommend_solution = NULL;
    problem->problem_free_function = NULL;
    problem->dimension = number_of_variables;
    problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = number_of_objectives;
    problem->number_of_parameters = 0;
    problem->parameters = NULL;
    problem->smallest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->largest_values_of_interest = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_parameter = IOHprofiler_allocate_int_vector(number_of_variables);
    problem->best_value = IOHprofiler_allocate_vector(number_of_objectives);
    problem->raw_fitness = IOHprofiler_allocate_vector(number_of_objectives);
    if (number_of_objectives > 1)
        problem->nadir_value = IOHprofiler_allocate_vector(number_of_objectives);
    else
        problem->nadir_value = NULL;
    problem->problem_name = NULL;
    problem->problem_id = NULL;
    problem->problem_type = NULL;
    problem->evaluations = 0;
    problem->final_target_delta[0] = 1e-8; /* in case to be modified by the benchmark */
    problem->best_observed_fvalue[0] = DBL_MIN_EXP;
    problem->best_observed_evaluation[0] = 0;
    problem->suite = NULL; /* To be initialized in the IOHprofiler_suite_get_problem_from_indices() function */
    problem->suite_dep_index = 0;
    problem->suite_dep_function = 0;
    problem->suite_dep_instance = 0;
    problem->data = NULL;
    return problem;
}

/**
 * @brief Creates a duplicate of the 'other' problem for all fields except for data, which points to NULL.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_duplicate(const IOHprofiler_problem_t *other) {
    size_t i;
    IOHprofiler_problem_t *problem;
    problem = IOHprofiler_problem_allocate(other->number_of_variables, other->number_of_objectives);

    problem->dimension = other->dimension;
    problem->initial_solution = other->initial_solution;
    problem->evaluate_function = other->evaluate_function;
    problem->recommend_solution = other->recommend_solution;
    problem->problem_free_function = other->problem_free_function;

    for (i = 0; i < problem->number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = other->smallest_values_of_interest[i];
        problem->largest_values_of_interest[i] = other->largest_values_of_interest[i];
        if (other->best_parameter)
            problem->best_parameter[i] = other->best_parameter[i];
    }

    if (other->best_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->best_value[i] = other->best_value[i];
        }

    if (other->nadir_value)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->nadir_value[i] = other->nadir_value[i];
        }

    if (other->raw_fitness)
        for (i = 0; i < problem->number_of_objectives; ++i) {
            problem->raw_fitness[i] = other->raw_fitness[i];
        }

    problem->number_of_parameters = other->number_of_parameters;
    for (i = 0; i < problem->number_of_parameters; ++i) {
        problem->parameters[i] = other->parameters[i];
    }

    problem->problem_name = IOHprofiler_strdup(other->problem_name);
    problem->problem_id = IOHprofiler_strdup(other->problem_id);
    problem->problem_type = IOHprofiler_strdup(other->problem_type);

    problem->evaluations = other->evaluations;
    problem->final_target_delta[0] = other->final_target_delta[0];
    problem->best_observed_fvalue[0] = other->best_observed_fvalue[0];
    problem->best_observed_evaluation[0] = other->best_observed_evaluation[0];

    problem->suite = other->suite;
    problem->suite_dep_index = other->suite_dep_index;
    problem->suite_dep_function = other->suite_dep_function;
    problem->suite_dep_instance = other->suite_dep_instance;

    problem->data = NULL;

    return problem;
}

/**
 * @brief Allocates a problem using scalar values for smallest_value_of_interest, largest_value_of_interest
 * and best_parameter.
 * Note that the number of objectives is set as 1 by default.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_allocate_from_scalars(const char *problem_name,
                                                                        IOHprofiler_evaluate_function_t evaluate_function,
                                                                        IOHprofiler_problem_free_function_t problem_free_function,
                                                                        const size_t number_of_variables,
                                                                        const int smallest_value_of_interest,
                                                                        const int largest_value_of_interest,
                                                                        const int best_parameter) {
    size_t i;

    IOHprofiler_problem_t *problem = IOHprofiler_problem_allocate(number_of_variables, 1);

    problem->problem_name = IOHprofiler_strdup(problem_name);
    /*problem->dimension = number_of_variables;
    */problem->number_of_variables = number_of_variables;
    problem->number_of_objectives = 1;
    problem->evaluate_function = evaluate_function;
    problem->problem_free_function = problem_free_function;

    for (i = 0; i < number_of_variables; ++i) {
        problem->smallest_values_of_interest[i] = smallest_value_of_interest;
        problem->largest_values_of_interest[i] = largest_value_of_interest;
        problem->best_parameter[i] = best_parameter;
    }
    return problem;
}

void IOHprofiler_problem_free(IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (problem->problem_free_function != NULL) {
        problem->problem_free_function(problem);
    } else {
        /* Best guess at freeing all relevant structures */
        if (problem->smallest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->smallest_values_of_interest);
        if (problem->largest_values_of_interest != NULL)
            IOHprofiler_free_memory(problem->largest_values_of_interest);
        if (problem->best_parameter != NULL)
            IOHprofiler_free_memory(problem->best_parameter);
        if (problem->best_value != NULL)
            IOHprofiler_free_memory(problem->best_value);
        if (problem->raw_fitness != NULL)
            IOHprofiler_free_memory(problem->raw_fitness);
        if (problem->nadir_value != NULL)
            IOHprofiler_free_memory(problem->nadir_value);
        if (problem->problem_name != NULL)
            IOHprofiler_free_memory(problem->problem_name);
        if (problem->problem_id != NULL)
            IOHprofiler_free_memory(problem->problem_id);
        if (problem->problem_type != NULL)
            IOHprofiler_free_memory(problem->problem_type);
        if (problem->data != NULL)
            IOHprofiler_free_memory(problem->data);
        if (problem->parameters != NULL)
            IOHprofiler_free_memory(problem->parameters);
        problem->smallest_values_of_interest = NULL;
        problem->largest_values_of_interest = NULL;
        problem->best_parameter = NULL;
        problem->best_value = NULL;
        problem->raw_fitness = NULL;
        problem->nadir_value = NULL;
        problem->suite = NULL;
        problem->data = NULL;
        problem->parameters = NULL;
        IOHprofiler_free_memory(problem);
    }
}

/**
 * @brief Checks whether the given string is in the right format to be a problem_id.
 *
 * No non-alphanumeric characters besides '-', '_' and '.' are allowed.
 */
static int IOHprofiler_problem_id_is_fine(const char *id, ...) {
    va_list args;
    const int reject = 0;
    const int accept = 1;
    const char *cp;
    char *s;
    int result = accept;

    va_start(args, id);
    s = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    for (cp = s; *cp != '\0'; ++cp) {
        if (('A' <= *cp) && (*cp <= 'Z'))
            continue;
        if (('a' <= *cp) && (*cp <= 'z'))
            continue;
        if ((*cp == '_') || (*cp == '-'))
            continue;
        if (('0' <= *cp) && (*cp <= '9'))
            continue;
        result = reject;
    }
    IOHprofiler_free_memory(s);
    return result;
}

/**
 * @brief Sets the problem_parameters.
 *
 */
void IOHprofiler_problem_set_parameters(IOHprofiler_problem_t *problem, const size_t number_of_parameters, const double *parameters) {
    size_t i;
    if (number_of_parameters != 0) {
        problem->number_of_parameters = number_of_parameters;
        if (problem->parameters != NULL) {
            IOHprofiler_free_memory(problem->parameters);
        }
        problem->parameters = IOHprofiler_allocate_vector(number_of_parameters);
        for (i = 0; i < problem->number_of_parameters; ++i) {
            problem->parameters[i] = parameters[i];
        }
    }
}

/**
 * @brief Sets the problem_id using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation and verifies that the problem_id is in the correct format.
 */
static void IOHprofiler_problem_set_id(IOHprofiler_problem_t *problem, const char *id, ...) {
    va_list args;

    va_start(args, id);
    if (problem->problem_id != NULL)
        IOHprofiler_free_memory(problem->problem_id);
    problem->problem_id = IOHprofiler_vstrdupf(id, args);
    va_end(args);
    if (!IOHprofiler_problem_id_is_fine(problem->problem_id)) {
        IOHprofiler_error("Problem id should only contain standard chars, not like '%s'", problem->problem_id);
    }
}

/**
 * @brief Sets the problem_name using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_name(IOHprofiler_problem_t *problem, const char *name, ...) {
    va_list args;

    va_start(args, name);
    if (problem->problem_name != NULL)
        IOHprofiler_free_memory(problem->problem_name);
    problem->problem_name = IOHprofiler_vstrdupf(name, args);
    va_end(args);
}

/**
 * @brief Sets the problem_type using formatted printing (as in printf).
 *
 * Takes care of memory (de-)allocation.
 */
static void IOHprofiler_problem_set_type(IOHprofiler_problem_t *problem, const char *type, ...) {
    va_list args;

    va_start(args, type);
    if (problem->problem_type != NULL)
        IOHprofiler_free_memory(problem->problem_type);
    problem->problem_type = IOHprofiler_vstrdupf(type, args);
    va_end(args);
}

size_t IOHprofiler_problem_get_evaluations(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->evaluations;
}

/**
 * @brief Returns 1 if the best parameter is not (close to) zero and 0 otherwise.
 */
static int IOHprofiler_problem_best_parameter_not_zero(const IOHprofiler_problem_t *problem) {
    size_t i = 0;
    int best_is_zero = 1;

    if (IOHprofiler_vector_contains_nan(problem->best_parameter, problem->number_of_variables))
        return 1;

    while (i < problem->number_of_variables && best_is_zero) {
        best_is_zero = IOHprofiler_double_almost_equal(problem->best_parameter[i], 0, 1e-9);
        i++;
    }

    return !best_is_zero;
}

/**
 * @note Can be used to prevent unnecessary burning of CPU time.
 */
int IOHprofiler_problem_final_target_hit(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    if (IOHprofiler_problem_get_number_of_objectives(problem) != 1 ||
        IOHprofiler_problem_get_evaluations(problem) < 1)
        return 0;
    if (problem->best_value == NULL)
        return 0;
    return problem->best_observed_fvalue[0] >= problem->best_value[0] - problem->final_target_delta[0] ? 1 : 0;
}

/**
 * @note Tentative...
 */
double IOHprofiler_problem_get_best_observed_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->best_observed_fvalue[0];
}

/**
 * @note This function breaks the black-box property: the returned  value is not
 * meant to be used by the optimization algorithm.
 */
double IOHprofiler_problem_get_final_target_fvalue1(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->best_value != NULL);
    assert(problem->final_target_delta != NULL);
    return problem->best_value[0] + problem->final_target_delta[0];
}

/**
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_name(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_name != NULL);
    return problem->problem_name;
}

/**
 * The ID is guaranteed to contain only characters in the set [a-z0-9_-]. It should therefore be safe to use
 * it to construct filenames or other identifiers.
 *
 * Each problem ID should be unique within each benchmark suite.
 *
 * @note Do not modify the returned string! If you free the problem, the returned pointer becomes invalid.
 * When in doubt, use IOHprofiler_strdup() on the returned value.
 */
const char *IOHprofiler_problem_get_id(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_id != NULL);
    return problem->problem_id;
}

const char *IOHprofiler_problem_get_type(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->problem_type != NULL);
    return problem->problem_type;
}

size_t IOHprofiler_problem_get_dimension(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->dimension > 0);
    return problem->dimension;
}

size_t IOHprofiler_problem_get_number_of_objectives(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->number_of_objectives > 0);
    return problem->number_of_objectives;
}
const int *IOHprofiler_problem_get_smallest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->smallest_values_of_interest != NULL);
    return problem->smallest_values_of_interest;
}

const int *IOHprofiler_problem_get_largest_values_of_interest(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->largest_values_of_interest != NULL);
    return problem->largest_values_of_interest;
}

/**
 * If a special method for setting an initial solution to the problem does not exist, the center of the
 * problem's region of interest is the initial solution.
 * @param problem The given IOHprofiler problem.
 * @param initial_solution The pointer to the initial solution being set by this method.
 */
void IOHprofiler_problem_get_initial_solution(const IOHprofiler_problem_t *problem, int *initial_solution) {
    assert(problem != NULL);
    if (problem->initial_solution != NULL) {
        problem->initial_solution(problem, initial_solution);
    } else {
        size_t i;
        assert(problem->smallest_values_of_interest != NULL);
        assert(problem->largest_values_of_interest != NULL);
        for (i = 0; i < problem->number_of_variables; ++i)
            initial_solution[i] = (int)(problem->smallest_values_of_interest[i] + 0.5 * (problem->largest_values_of_interest[i] - problem->smallest_values_of_interest[i]));
    }
}

static IOHprofiler_suite_t *IOHprofiler_problem_get_suite(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite;
}

static void IOHprofiler_problem_set_suite(IOHprofiler_problem_t *problem, IOHprofiler_suite_t *suite) {
    assert(problem != NULL);
    problem->suite = suite;
}

size_t IOHprofiler_problem_get_suite_dep_index(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    return problem->suite_dep_index;
}

static size_t IOHprofiler_problem_get_suite_dep_function(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_function > 0);
    return problem->suite_dep_function;
}

static size_t IOHprofiler_problem_get_suite_dep_instance(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->suite_dep_instance > 0);
    return problem->suite_dep_instance;
}

/**
 * @brief Returns the data of the transformed problem.
 */
static void *IOHprofiler_problem_transformed_get_data(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->data != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->data;
}

/**
 * @brief Returns the inner problem of the transformed problem.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_get_inner_problem(const IOHprofiler_problem_t *problem) {
    assert(problem != NULL);
    assert(problem->data != NULL);
    assert(((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem != NULL);

    return ((IOHprofiler_problem_transformed_data_t *)problem->data)->inner_problem;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the inner problem.
 */
static void IOHprofiler_problem_transformed_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_evaluate_function(data->inner_problem, x, y);
}

/**
 * @brief Calls the IOHprofiler_recommend_solution function on the inner problem.
 */
static void IOHprofiler_problem_transformed_recommend_solution(IOHprofiler_problem_t *problem, const int *x) {
    IOHprofiler_problem_transformed_data_t *data;
    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);

    IOHprofiler_recommend_solution(data->inner_problem, x);
}

/**
 * @brief Frees only the data of the transformed problem leaving the inner problem intact.
 *
 * @note If there is no other pointer to the inner problem, access to it will be lost.
 */
static void IOHprofiler_problem_transformed_free_data(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;

    if (data->data != NULL) {
        if (data->data_free_function != NULL) {
            data->data_free_function(data->data);
            data->data_free_function = NULL;
        }
        IOHprofiler_free_memory(data->data);
        data->data = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}

/**
 * @brief Frees the transformed problem.
 */
static void IOHprofiler_problem_transformed_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_transformed_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_transformed_data_t *)problem->data;
    assert(data->inner_problem != NULL);
    if (data->inner_problem != NULL) {
        IOHprofiler_problem_free(data->inner_problem);
        data->inner_problem = NULL;
    }
    IOHprofiler_problem_transformed_free_data(problem);
}

/**
 * @brief Allocates a transformed problem that wraps the inner_problem.
 *
 * By default all methods will dispatch to the inner_problem. A prefix is prepended to the problem name
 * in order to reflect the transformation somewhere.
 */
static IOHprofiler_problem_t *IOHprofiler_problem_transformed_allocate(IOHprofiler_problem_t *inner_problem,
                                                                       void *user_data,
                                                                       IOHprofiler_data_free_function_t data_free_function,
                                                                       const char *name_prefix) {
    IOHprofiler_problem_transformed_data_t *problem;
    IOHprofiler_problem_t *inner_copy;
    char *old_name = IOHprofiler_strdup(inner_problem->problem_name);

    problem = (IOHprofiler_problem_transformed_data_t *)IOHprofiler_allocate_memory(sizeof(*problem));
    problem->inner_problem = inner_problem;
    problem->data = user_data;
    problem->data_free_function = data_free_function;

    inner_copy = IOHprofiler_problem_duplicate(inner_problem);
    inner_copy->evaluate_function = IOHprofiler_problem_transformed_evaluate_function;
    inner_copy->recommend_solution = IOHprofiler_problem_transformed_recommend_solution;
    inner_copy->problem_free_function = IOHprofiler_problem_transformed_free;
    inner_copy->data = problem;

    IOHprofiler_problem_set_name(inner_copy, "%s(%s)", name_prefix, old_name);
    IOHprofiler_free_memory(old_name);

    return inner_copy;
}

/**
 * @brief Calls the IOHprofiler_evaluate_function function on the underlying problems.
 */
static void IOHprofiler_problem_stacked_evaluate_function(IOHprofiler_problem_t *problem, const int *x, double *y) {
    IOHprofiler_problem_stacked_data_t *data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    assert(
        IOHprofiler_problem_get_number_of_objectives(problem) == IOHprofiler_problem_get_number_of_objectives(data->problem1) + IOHprofiler_problem_get_number_of_objectives(data->problem2));

    IOHprofiler_evaluate_function(data->problem1, x, &y[0]);
    IOHprofiler_evaluate_function(data->problem2, x, &y[IOHprofiler_problem_get_number_of_objectives(data->problem1)]);
}

/**
 * @brief Frees the stacked problem.
 */
static void IOHprofiler_problem_stacked_free(IOHprofiler_problem_t *problem) {
    IOHprofiler_problem_stacked_data_t *data;

    assert(problem != NULL);
    assert(problem->data != NULL);
    data = (IOHprofiler_problem_stacked_data_t *)problem->data;

    if (data->problem1 != NULL) {
        IOHprofiler_problem_free(data->problem1);
        data->problem1 = NULL;
    }
    if (data->problem2 != NULL) {
        IOHprofiler_problem_free(data->problem2);
        data->problem2 = NULL;
    }
    /* Let the generic free problem code deal with the rest of the fields. For this we clear the free_problem
   * function pointer and recall the generic function. */
    problem->problem_free_function = NULL;
    IOHprofiler_problem_free(problem);
}
#endif
#line 28 "code-experiments/src/profiler/../suite/WModel/logger_WModel.c"
#line 29 "code-experiments/src/profiler/../suite/WModel/logger_WModel.c"

#line 31 "code-experiments/src/profiler/../suite/WModel/logger_WModel.c"
#line 1 "code-experiments/src/profiler/../suite/WModel/observer_WModel.c"
/**
 * @file observer_bbob.c
 * @brief Implementation of the PBO observer.
 */
#ifndef OBSERVER_WMODEL
#define OBSERVER_WMODEL

#line 9 "code-experiments/src/profiler/../suite/WModel/observer_WModel.c"
#line 10 "code-experiments/src/profiler/../suite/WModel/observer_WModel.c"

static IOHprofiler_problem_t *logger_WModel(IOHprofiler_observer_t *observer, IOHprofiler_problem_t *problem);
static void logger_WModel_free(void *logger);

/**
 * @brief The IOHprofiler observer data type.
 */
typedef struct {
    /* TODO: Can be used to store variables that need to be accessible during one run (i.e. for multiple
   * problems). For example, the following global variables from logger_bbob.c could be stored here: */
    size_t current_dim;
    size_t current_fun_id;
    /* ... and others */
} observer_WModel_data_t;


/**
 * @brief Initializes the bbob observer.
 */
static void WModel_observer_IOHprofiler(IOHprofiler_observer_t *observer, const char *options, IOHprofiler_option_keys_t **option_keys) {
    observer->logger_allocate_function = logger_WModel;
    observer->logger_free_function = logger_WModel_free;
    observer->data_free_function = NULL;
    observer->data = NULL;

    *option_keys = NULL;

    (void)options; /* To silence the compiler */
}

#endif
#line 32 "code-experiments/src/profiler/../suite/WModel/logger_WModel.c"
#line 33 "code-experiments/src/profiler/../suite/WModel/logger_WModel.c"

/*static const size_t IOHprofiler_nbpts_nbevals = 20; Wassim: tentative, are now observer options with these default values*/
/*static const size_t IOHprofiler_nbpts_fval = 5;*/
static size_t WModel_current_dim = 0;
static size_t WModel_current_funId = 0;
static size_t WModel_infoFile_firstInstance = 0;
char WModel_infoFile_firstInstance_char[3];
/* a possible solution: have a list of dims that are already in the file, if the ones we're about to log
 * is != WModel_current_dim and the funId is currend_funId, create a new .info file with as suffix the
 * number of the first instance */
static const int WModel_number_of_dimensions = 6;
static size_t WModel_dimensions_in_current_infoFile[6] = { 0, 0, 0, 0, 0, 0 }; /* TODO should use dimensions from the suite */

/* The current_... mechanism fails if several problems are open.
 * For the time being this should lead to an error.
 *
 * A possible solution: WModel_logger_is_open becomes a reference
 * counter and as long as another logger is open, always a new info
 * file is generated.
 * TODO: Shouldn't the new way of handling observers already fix this?
 */
static int WModel_logger_is_open = 0; /* this could become lock-list of .info files */

/* TODO: add possibility of adding a prefix to the index files (easy to do through observer options) */
static double WModel_fmax(double a, double b) {
  return (a > b) ? a : b;
}

/**
 * @brief The IOHprofiler logger data type.
 */
typedef struct {
  IOHprofiler_observer_t *observer;
  int is_initialized;
  /*char *path;// relative path to the data folder. //Wassim: now fetched from the observer */
  /*const char *alg_name; the alg name, for now, temporarily the same as the path. Wassim: Now in the observer */
  FILE *index_file; /* index file */
  FILE *fdata_file; /* function value aligned data file */
  FILE *tdata_file; /* number of function evaluations aligned data file */
  /*
  FILE *rdata_file;  restart info data file */
  
  FILE *idata_file; /* fixed interval aligned data file */
  FILE *cdata_file; /* complete data file */

  int f_flag; /* symbol for writing fdata_file*/
  int t_flag; /* symbol for writing tdata_file*/
  int i_flag; /* symbol for writing idata_file*/
  int c_flag; /* symbol for writing cdata_file*/
  size_t number_of_evaluations;
  double best_fvalue;
  double last_fvalue;
  double raw_value;
  double best_raw_value;
  short written_last_eval; /* allows writing the the data of the final fun eval in the .tdat file if not already written by the t_trigger*/
  int *best_solution;
  /* The following are to only pass data as a parameter in the free function. The
   * interface should probably be the same for all free functions so passing the
   * problem as a second parameter is not an option even though we need info
   * form it.*/
  size_t function_id; /*TODO: consider changing name*/
  size_t instance_id;
  size_t number_of_variables;
  size_t inner_dimension;
  double optimal_fvalue;

  size_t number_of_parameters;
  double *parameters;

  IOHprofiler_observer_targets_t *targets;          /**< @brief Triggers based on target values. */
  IOHprofiler_observer_evaluations_t *evaluations;  /**< @brief Triggers based on the number of evaluations. */
  IOHprofiler_observer_update_t *updating;          /**< @brief Triggers based on the updating. */
  size_t interval;                    /**< @brief The value of triggers interval. */

} logger_WModel_data_t;

static const char *WModel_file_header_str = "\"function evaluation\" "
    "\"current f(x)\" "
    "\"best-so-far f(x)\" "
    "\"current af(x)+b\"  "
    "\"best af(x)+b\" ";

static const char *WModel_file_para_str = "\"%s\" ";

/**
 * adds a formated line to a data file
 */
static void logger_WModel_write_data(FILE *target_file,
                                   size_t number_of_evaluations,
                                   double fvalue,
                                   double best_fvalue,
                                   double best_raw_value,
                                   double raw_value,
                                   const double *parameter,
                                   size_t number_of_parameters) {
  /* for some reason, it's %.0f in the old code instead of the 10.9e
   * in the documentation
   */
  size_t i;
  fprintf(target_file, "%lu %+10.5e %+10.5e %+10.5e %+10.5e", (unsigned long) number_of_evaluations,
      raw_value, best_raw_value, fvalue , best_fvalue);
    
  for (i = 0; i < number_of_parameters; i++) {
    fprintf(target_file, " %.6f", parameter[i]);
  }

  fprintf(target_file, "\n");
}

/**
 * Error when trying to create the file "path"
 */
static void logger_WModel_error_io(FILE *path, int errnum) {
  const char *error_format = "Error opening file: %s\n ";
  IOHprofiler_error(error_format, strerror(errnum), path);
}

/**
 * Creates the data files or simply opens it
 */


static void logger_WModel_open_dataFile(FILE **target_file,
                                      const char *path,
                                      const char *dataFile_path,
                                      const char *file_extension) {
  char file_path[3*IOHprofiler_PATH_MAX] = { 0 };
  char relative_filePath[3*IOHprofiler_PATH_MAX] = { 0 };
  int errnum;
  strncpy(relative_filePath, dataFile_path,
  3*IOHprofiler_PATH_MAX - strlen(relative_filePath) - 1);
  strncat(relative_filePath, file_extension,
  3*IOHprofiler_PATH_MAX - strlen(relative_filePath) - 1);
  IOHprofiler_join_path(file_path, sizeof(file_path), path, relative_filePath, NULL);
  if (*target_file == NULL) {
    *target_file = fopen(file_path, "a+");
    errnum = errno;
    if (*target_file == NULL) {
      logger_WModel_error_io(*target_file, errnum);
    }
  }
}


/**
 * Creates the index file fileName_prefix+problem_id+file_extension in
 * folde_path
 */
static void logger_WModel_openIndexFile(logger_WModel_data_t *logger,
                                      const char *folder_path,
                                      const char *indexFile_prefix,
                                      const char *function_id,
                                      const char *dataFile_path,
                                      const char *suite_name,
                                      char * layer) {
  /* to add the instance number TODO: this should be done outside to avoid redoing this for the .*dat files */
  char used_dataFile_path[3*IOHprofiler_PATH_MAX] = { 0 };
  int errnum, newLine; /* newLine is at 1 if we need a new line in the info file */
  char function_id_char[10]; /* TODO: consider adding them to logger */
  char file_name[3*IOHprofiler_PATH_MAX] = { 0 };
  char file_path[3*IOHprofiler_PATH_MAX] = { 0 };
  FILE **target_file;
  FILE *tmp_file;
  strncpy(used_dataFile_path, dataFile_path, 3*IOHprofiler_PATH_MAX - strlen(used_dataFile_path) - 1);
  if (WModel_infoFile_firstInstance == 0) {
    WModel_infoFile_firstInstance = logger->instance_id;
  }
  sprintf(function_id_char, "%d", logger->function_id);
  sprintf(WModel_infoFile_firstInstance_char, "%lu", (unsigned long) WModel_infoFile_firstInstance);
  target_file = &(logger->index_file);
  tmp_file = NULL; /* to check whether the file already exists. Don't want to use target_file */
  strncpy(file_name, indexFile_prefix, 3*IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  strncat(file_name, "_f", 3*IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  strncat(file_name, function_id_char, 3*IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  strncat(file_name, "_i", 3*IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  strncat(file_name, WModel_infoFile_firstInstance_char, 3*IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  strncat(file_name, ".info", 3*IOHprofiler_PATH_MAX - strlen(file_name) - 1);
  IOHprofiler_join_path(file_path, sizeof(file_path), folder_path, file_name, NULL);
  if (*target_file == NULL) {
    tmp_file = fopen(file_path, "r"); /* to check for existence */
    if ((tmp_file) && (WModel_current_dim == logger->inner_dimension)
        && (WModel_current_funId == logger->function_id)) {
        /* new instance of current funId and current dim */
      newLine = 0;
      *target_file = fopen(file_path, "a+");
      if (*target_file == NULL) {
        errnum = errno;
        logger_WModel_error_io(*target_file, errnum);
      }
      fclose(tmp_file);
    } else { /* either file doesn't exist (new funId) or new Dim */
      /* check that the dim was not already present earlier in the file, if so, create a new info file */
      if (WModel_current_dim != logger->inner_dimension) {
        int i, j;
        for (i = 0;
            i < WModel_number_of_dimensions && WModel_dimensions_in_current_infoFile[i] != 0
                && WModel_dimensions_in_current_infoFile[i] != logger->inner_dimension; i++) {
          ; /* checks whether dimension already present in the current infoFile */
        }
        if (i < WModel_number_of_dimensions && WModel_dimensions_in_current_infoFile[i] == 0) {
          /* new dimension seen for the first time */
          WModel_dimensions_in_current_infoFile[i] = logger->inner_dimension;
          newLine = 1;
        } else {
          if (i < WModel_number_of_dimensions) { /* dimension already present, need to create a new file */
            newLine = 0;
            file_path[strlen(file_path) - strlen(WModel_infoFile_firstInstance_char) - 7] = 0; /* truncate the instance part */
            WModel_infoFile_firstInstance = logger->instance_id;
            sprintf(WModel_infoFile_firstInstance_char, "%lu", (unsigned long) WModel_infoFile_firstInstance);
            strncat(file_path, "_i", 3*IOHprofiler_PATH_MAX - strlen(file_name) - 1);
            strncat(file_path, WModel_infoFile_firstInstance_char, 3*IOHprofiler_PATH_MAX - strlen(file_name) - 1);
            strncat(file_path, ".info", 3*IOHprofiler_PATH_MAX - strlen(file_name) - 1);
          } else {/*we have all dimensions*/
            newLine = 1;
          }
          for (j = 0; j < WModel_number_of_dimensions; j++) { /* new info file, reinitialize list of dims */
            WModel_dimensions_in_current_infoFile[j] = 0;
          }
          WModel_dimensions_in_current_infoFile[i] = logger->inner_dimension;
        }
      } else {
        if ( WModel_current_funId != logger->function_id ) {
          /*new function in the same file */
          newLine = 1;
        }
      }
      *target_file = fopen(file_path, "a+"); /* in any case, we append */
      if (*target_file == NULL) {
        errnum = errno;
        logger_WModel_error_io(*target_file, errnum);
      }
      if (tmp_file) { /* File already exists, new dim so just a new line. Also, close the tmp_file */
        if (newLine) {
          fprintf(*target_file, "\n");
        }
        fclose(tmp_file);
      }

      fprintf(*target_file,
          "suite = '%s', funcId = %d, DIM = %lu, algId = '%s', algInfo = '%s'\n",
          suite_name, (int) strtol(function_id, NULL, 10), (unsigned long) logger->inner_dimension,
          logger->observer->algorithm_name,logger->observer->algorithm_info);

      fprintf(*target_file, "%%\n");
      strncat(used_dataFile_path, "_i", 3*IOHprofiler_PATH_MAX - strlen(used_dataFile_path) - 1);
      strncat(used_dataFile_path, WModel_infoFile_firstInstance_char,
      3*IOHprofiler_PATH_MAX - strlen(used_dataFile_path) - 1);
      fprintf(*target_file, "%s.dat", used_dataFile_path); /* dataFile_path does not have the extension */
      WModel_current_dim = logger->inner_dimension;
      WModel_current_funId = logger->function_id;
    }
  }
}

/**
 * Generates the different files and folder needed by the logger to store the
 * data if these don't already exist
 */
static void logger_WModel_initialize(logger_WModel_data_t *logger, IOHprofiler_problem_t *inner_problem) {
  /*
   Creates/opens the data and index files
   */
  char dataFile_path[3*IOHprofiler_PATH_MAX] = { 0 }; /* relative path to the .dat file from where the .info file is */
  char folder_path[3*IOHprofiler_PATH_MAX] = { 0 };
  char *tmpc_funId; /* serves to extract the function id as a char *. There should be a better way of doing this! */
  char *tmpc_dim; /* serves to extract the dimension as a char *. There should be a better way of doing this! */
  char indexFile_prefix[15] = "IOHprofiler"; /* TODO (minor): make the prefix IOHprofilerexp a parameter that the user can modify */
  size_t str_length_funId, str_length_dim;
  int * layer;
  char tmpc_layer[3*IOHprofiler_PATH_MAX];
  
  str_length_funId = IOHprofiler_double_to_size_t(WModel_fmax(1, ceil(log10((double) IOHprofiler_problem_get_suite_dep_function(inner_problem)+1))));
  str_length_dim = IOHprofiler_double_to_size_t(WModel_fmax(1, ceil(log10((double) inner_problem->dimension))));
  tmpc_funId = IOHprofiler_allocate_string(str_length_funId+1);
  tmpc_dim = IOHprofiler_allocate_string(str_length_dim+1);
  /*old*/
  layer=get_layers_parameters();
/*  fprintf(stderr,"logger  ");pr_para(layer);*/
  /*---*/
  /*layer=IOHprofiler_duplicate_int_vector((int *)inner_problem->data,4);/*from problem*/
  assert(logger != NULL);
  assert(inner_problem != NULL);
  assert(inner_problem->problem_id != NULL);

  sprintf(tmpc_funId, "%lu", (unsigned long) IOHprofiler_problem_get_suite_dep_function(inner_problem));
  sprintf(tmpc_dim, "%lu", (unsigned long) inner_problem->dimension);

  /* prepare paths and names */
  strncpy(dataFile_path, "data_f", 3*IOHprofiler_PATH_MAX);
  strncat(dataFile_path, tmpc_funId, 3*IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);
/*Layer Parameter in folder names*/
  snprintf(tmpc_layer, 3*IOHprofiler_PATH_MAX*sizeof(char), "_D=%d_N=%d_E=%d_R=%d", layer[Dummy],layer[Neutrality],layer[Epistasis],layer[Ruggedness]);
  strncat(dataFile_path, tmpc_layer, 3*IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);
/* end of layer parameter modification*/

  IOHprofiler_join_path(folder_path, sizeof(folder_path), logger->observer->result_folder, dataFile_path, NULL);
  IOHprofiler_create_directory(folder_path);

  strncat(dataFile_path, "/IOHprofiler_f",  3*IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);
  strncat(dataFile_path, tmpc_funId,  3*IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);

  strncat(dataFile_path, "_DIM", 3*IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);
  strncat(dataFile_path, tmpc_dim, 3*IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);


  /* index/info file */
  assert(IOHprofiler_problem_get_suite(inner_problem));
  logger_WModel_openIndexFile(logger, logger->observer->result_folder, indexFile_prefix, tmpc_funId,
      dataFile_path, IOHprofiler_problem_get_suite(inner_problem)->suite_name,tmpc_layer);
  fprintf(logger->index_file, ", %lu", (unsigned long) IOHprofiler_problem_get_suite_dep_instance(inner_problem));
  /* data files */
  /* TODO: definitely improvable but works for now */
  strncat(dataFile_path, "_i", 3*IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);
  strncat(dataFile_path, WModel_infoFile_firstInstance_char,
  3*IOHprofiler_PATH_MAX - strlen(dataFile_path) - 1);

  if(logger->f_flag == 1){
    logger_WModel_open_dataFile(&(logger->fdata_file), logger->observer->result_folder, dataFile_path, ".dat");
    fprintf(logger->fdata_file,"%s", WModel_file_header_str);
    if(logger->observer->parameters_name != NULL)
      fprintf(logger->fdata_file, WModel_file_para_str,logger->observer->parameters_name);
    fprintf(logger->fdata_file, "\n");
  }

  if(logger->t_flag == 1){
    logger_WModel_open_dataFile(&(logger->tdata_file), logger->observer->result_folder, dataFile_path, ".tdat");
    fprintf(logger->tdata_file,"%s", WModel_file_header_str);
    if(logger->observer->parameters_name != NULL)
      fprintf(logger->tdata_file, WModel_file_para_str,logger->observer->parameters_name);
    fprintf(logger->tdata_file, "\n");
  }

  if(logger->i_flag == 1){
    logger_WModel_open_dataFile(&(logger->idata_file), logger->observer->result_folder, dataFile_path, ".idat");
    fprintf(logger->idata_file, "%s",WModel_file_header_str);
    if(logger->observer->parameters_name != NULL)
      fprintf(logger->idata_file, WModel_file_para_str,logger->observer->parameters_name);
    fprintf(logger->idata_file, "\n");
  }

  if(logger->c_flag == 1){
    logger_WModel_open_dataFile(&(logger->cdata_file), logger->observer->result_folder, dataFile_path, ".cdat");
    fprintf(logger->cdata_file, "%s",WModel_file_header_str);
    if(logger->observer->parameters_name != NULL)
      fprintf(logger->cdata_file, WModel_file_para_str,logger->observer->parameters_name);
    fprintf(logger->cdata_file, "\n");
  }
  /*
  logger_WModel_open_dataFile(&(logger->rdata_file), logger->observer->result_folder, dataFile_path, ".rdat");
  fprintf(logger->rdata_file,"%s", WModel_file_header_str);
  if(logger->observer->parameters_name != NULL)
    fprintf(logger->rdata_file, WModel_file_para_str,logger->observer->parameters_name);
  fprintf(logger->rdata_file, "\n");
  */
  logger->is_initialized = 1;
  IOHprofiler_free_memory(tmpc_dim);
  IOHprofiler_free_memory(tmpc_funId);
  IOHprofiler_free_memory(layer);

}

/**
 * Layer added to the transformed-problem evaluate_function by the logger
 */
static void logger_WModel_evaluate(IOHprofiler_problem_t *problem, const int *x, double *y) {
  logger_WModel_data_t *logger = (logger_WModel_data_t *) IOHprofiler_problem_transformed_get_data(problem);
  IOHprofiler_problem_t * inner_problem = IOHprofiler_problem_transformed_get_inner_problem(problem);
 
  size_t i;
  if (!logger->is_initialized) {
    logger_WModel_initialize(logger, inner_problem);
  }
  if ((IOHprofiler_log_level >= IOHprofiler_DEBUG) && logger->number_of_evaluations == 0) {
    IOHprofiler_debug("%4lu: ", (unsigned long) inner_problem->suite_dep_index);
    IOHprofiler_debug("on problem %s ... ", IOHprofiler_problem_get_id(inner_problem));
  }
  IOHprofiler_evaluate_function(inner_problem, x, y);
  
  /*Update parameters' info*/
  logger->number_of_parameters = problem->number_of_parameters;
  if(logger->number_of_parameters > 0){
    if(logger->parameters != NULL){
        IOHprofiler_free_memory(logger->parameters);
    }
    logger->parameters = IOHprofiler_allocate_vector(logger->number_of_parameters);
    for(i = 0; i < logger->number_of_parameters; ++i)
      logger->parameters[i] = problem->parameters[i];
  }
  logger->last_fvalue = y[0];
  logger->written_last_eval = 0;
  if (logger->number_of_evaluations == 0 || y[0] > logger->best_fvalue) {
    logger->best_fvalue = y[0];

    for (i = 0; i < problem->number_of_variables; i++)
      logger->best_solution[i] = x[i];
  }
  logger->raw_value = inner_problem->raw_fitness[0];
  if(logger->number_of_evaluations == 0 || logger->raw_value > logger->best_raw_value)
    logger->best_raw_value = logger->raw_value;

  
  logger->number_of_evaluations++;
  if(logger->f_flag == 1){
    if (IOHprofiler_observer_update_trigger(logger->updating,y[0])) {
      logger->best_fvalue = y[0];
      for (i = 0; i < problem->number_of_variables; i++)
        logger->best_solution[i] = x[i];
        logger_WModel_write_data(
          logger->fdata_file, 
          logger->number_of_evaluations,
          y[0], 
          logger->best_fvalue,
          logger->best_raw_value,
          logger->raw_value,
          problem->parameters, 
          problem->number_of_parameters);
    }
  }
  if(logger->t_flag == 1){
    /* Add a line in the .tdat file each time an fevals trigger is reached.*/
    if (IOHprofiler_observer_evaluations_trigger(logger->evaluations, logger->number_of_evaluations)) {
      logger_WModel_write_data(
          logger->tdata_file, 
          logger->number_of_evaluations,
          y[0], 
          logger->best_fvalue,
          logger->best_raw_value,
          logger->raw_value,
          problem->parameters, 
          problem->number_of_parameters);
      logger->written_last_eval = 1;
    }
  }

  if(logger->i_flag == 1){
    if ( logger->number_of_evaluations % logger->interval == 0) {
      logger_WModel_write_data(
          logger->idata_file, 
          logger->number_of_evaluations,
          y[0], 
          logger->best_fvalue,         
          logger->best_raw_value,
          logger->raw_value,
          problem->parameters, 
          problem->number_of_parameters);
    }
  }

  if(logger->c_flag == 1){
    logger_WModel_write_data(
        logger->cdata_file, 
        logger->number_of_evaluations,
        y[0], 
        logger->best_fvalue,          
        logger->best_raw_value,
        logger->raw_value,
        problem->parameters, 
        problem->number_of_parameters);
  }
  /* Add sanity check for optimal f value */
  assert(y[0] <= logger->optimal_fvalue);

  /* Flush output so that impatient users can see progress. */
  if(logger->f_flag == 1)
    fflush(logger->fdata_file);
}

/**
 * Also serves as a finalize run method so. Must be called at the end
 * of Each run to correctly fill the index file
 *
 * TODO: make sure it is called at the end of each run or move the
 * writing into files to another function
 */
static void logger_WModel_free(void *stuff) {
  /* TODO: do all the "non simply freeing" stuff in another function
   * that can have problem as input
   */
  logger_WModel_data_t *logger = (logger_WModel_data_t *) stuff;

  if ((IOHprofiler_log_level >= IOHprofiler_DEBUG) && logger && logger->number_of_evaluations > 0) {
    IOHprofiler_debug("best f=%e after %lu fevals (done observing)\n", logger->best_fvalue,
        (unsigned long) logger->number_of_evaluations);
  }
  if (logger->index_file != NULL) {
    fprintf(logger->index_file, ":%lu|%.5e", (unsigned long) logger->number_of_evaluations,
        logger->best_fvalue);
    fclose(logger->index_file);
    logger->index_file = NULL;
  }
  if (logger->fdata_file != NULL) {
    fclose(logger->fdata_file);
    logger->fdata_file = NULL;
  }
  if (logger->tdata_file != NULL) {
    /* TODO: make sure it handles restarts well. i.e., it writes
     * at the end of a single run, not all the runs on a given
     * instance. Maybe start with forcing it to generate a new
     * "instance" of problem for each restart in the beginning
     */
    if (!logger->written_last_eval) {
      logger_WModel_write_data(logger->tdata_file, logger->number_of_evaluations, logger->last_fvalue,
          logger->best_fvalue, logger->best_raw_value, logger->raw_value, logger->parameters, logger->number_of_parameters);
    }
    fclose(logger->tdata_file);
    logger->tdata_file = NULL;
  }
  /*
  if (logger->rdata_file != NULL) {
    fclose(logger->rdata_file);
    logger->rdata_file = NULL;
  }*/
  if (logger->idata_file != NULL) {
    logger_WModel_write_data(logger->idata_file, logger->number_of_evaluations, logger->last_fvalue,
          logger->best_fvalue, logger->best_raw_value, logger->raw_value, logger->parameters, logger->number_of_parameters);
    fclose(logger->idata_file);
    logger->idata_file = NULL;
  }
  
  if (logger->cdata_file != NULL) {
    fclose(logger->cdata_file);
    logger->cdata_file = NULL;
  }

  if (logger->best_solution != NULL) {
    IOHprofiler_free_memory(logger->best_solution);
    logger->best_solution = NULL;
  }

  if (logger->targets != NULL){
    IOHprofiler_free_memory(logger->targets);
    logger->targets = NULL;
  }

  if (logger->evaluations != NULL){
    IOHprofiler_observer_evaluations_free(logger->evaluations);
    logger->evaluations = NULL;
  }

  if (logger->updating != NULL){
    IOHprofiler_observer_update_free(logger->updating);
    logger->updating = NULL;
  }

  if (logger->parameters != NULL){
    IOHprofiler_free_memory(logger->parameters);
    logger->parameters = NULL;
  }

  WModel_logger_is_open = 0;
}

static IOHprofiler_problem_t *logger_WModel(IOHprofiler_observer_t *observer, IOHprofiler_problem_t *inner_problem) {
  logger_WModel_data_t *logger_WModel;
  IOHprofiler_problem_t *problem;
  logger_WModel = (logger_WModel_data_t *) IOHprofiler_allocate_memory(sizeof(*logger_WModel));
  logger_WModel->observer = observer;

  if (inner_problem->number_of_objectives != 1) {
    IOHprofiler_warning("logger_WModel(): The IOHprofiler logger shouldn't be used to log a problem with %d objectives",
        inner_problem->number_of_objectives);
  }

  if (WModel_logger_is_open)
    IOHprofiler_error("The current IOHprofiler_logger (observer) must be closed before a new one is opened");
  /* This is the name of the folder which happens to be the algName */
  /*logger->path = IOHprofiler_strdup(observer->output_folder);*/
  logger_WModel->index_file = NULL;
  logger_WModel->fdata_file = NULL;
  logger_WModel->tdata_file = NULL;
  /* delete rdat files*/
  /*
  logger_WModel->rdata_file = NULL;
  */
  logger_WModel->cdata_file = NULL;
  logger_WModel->idata_file = NULL;
  logger_WModel->f_flag = 0;
  logger_WModel->t_flag = 0;
  logger_WModel->i_flag = 0;
  logger_WModel->c_flag = 0;



  
  logger_WModel->f_flag = 1;
  if(strcmp(observer->base_evaluation_triggers,"") != 0)
    logger_WModel->t_flag = 1;
  if(observer->number_interval_triggers != 0)
    logger_WModel->i_flag = 1;
  if(strcmp(observer->complete_triggers,"true") == 0)
    logger_WModel->c_flag = 1;
  logger_WModel->number_of_variables = inner_problem->number_of_variables;
  logger_WModel->inner_dimension = inner_problem->dimension;
  logger_WModel->number_of_parameters = inner_problem->number_of_parameters;
  logger_WModel->parameters = NULL;
  if (inner_problem->best_value == NULL) {
    /* IOHprofiler_error("Optimal f value must be defined for each problem in order for the logger to work properly"); */
    /* Setting the value to 0 results in the assertion y>=optimal_fvalue being susceptible to failure */
    IOHprofiler_warning("undefined optimal f value. Set to 0");
    logger_WModel->optimal_fvalue = 0;
  } else {
    logger_WModel->optimal_fvalue = *(inner_problem->best_value);
  }

  logger_WModel->number_of_evaluations = 0;
  logger_WModel->best_solution = IOHprofiler_allocate_int_vector(inner_problem->number_of_variables);
  /* TODO: the following inits are just to be in the safe side and
   * should eventually be removed. Some fields of the IOHprofiler_logger struct
   * might be useless
   */
  logger_WModel->function_id = IOHprofiler_problem_get_suite_dep_function(inner_problem);
  logger_WModel->instance_id = IOHprofiler_problem_get_suite_dep_instance(inner_problem);
  logger_WModel->written_last_eval = 1;
  logger_WModel->last_fvalue = -DBL_MAX;
  logger_WModel->is_initialized = 0;
  logger_WModel->best_fvalue = -DBL_MAX;
  logger_WModel->best_raw_value  = -DBL_MAX;
  /* Initialize triggers based on target values and number of evaluations */
  logger_WModel->targets = IOHprofiler_observer_targets(observer->number_target_triggers, observer->target_precision);
  logger_WModel->evaluations = IOHprofiler_observer_evaluations(observer->base_evaluation_triggers, inner_problem->number_of_variables);
  logger_WModel->updating = IOHprofiler_observer_update();
  logger_WModel->interval = observer->number_interval_triggers;
  problem = IOHprofiler_problem_transformed_allocate(inner_problem, logger_WModel, logger_WModel_free, observer->observer_name);

  problem->evaluate_function = logger_WModel_evaluate;
  WModel_logger_is_open = 1;
  return problem;
}

#endif
#line 422 "code-experiments/src/profiler/IOHprofiler_observer.c"


/**
 * Currently, one observers is supported:
 * - "IOHprofiler" is the observer for single-objective problems with known optima, which is available to 
 * creates *.info, *.dat, *.tdat, *.idat, *rdat and *.cdat files and logs the distance to the optimum and parameters.
 *
 * @param observer_name A string containing the name of the observer. Currently supported observer name is
 * "IOHprofiler". Strings "no_observer", "" or NULL return NULL.
 * @param observer_options A string of pairs "key: value" used to pass the options to the observer.
 * - "result_folder: NAME" determines the folder within the "result_folder" folder into which the results will be
 * output. If the folder with the given name already exists, first NAME_001 will be tried, then NAME_002 and
 * so on. The default value is "default".
 * - "algorithm_name: NAME", where NAME is a short name of the algorithm that will be used in plots (no
 * spaces are allowed). The default value is "ALG".
 * - "algorithm_info: STRING" stores the description of the algorithm. If it contains spaces, it must be
 * surrounded by double quotes. The default value is "" (no description).
 * - "number_target_triggers: VALUE" defines the number of targets between each 10**i and 10**(i+1)
 * (equally spaced in the logarithmic scale) that trigger logging. The default value is 0, which means *.dat files
 * will not be generated.
 * - "target_precision: VALUE" defines the precision used for targets (there are no targets for
 * abs(values) < target_precision). The default value is 1e-8.
 * - "number_evaluation_triggers: VALUE" defines the number of evaluations to be logged between each 10**i
 * and 10**(i+1). The default value is 0.
 * - "base_evaluation_triggers: VALUES" defines the base evaluations used to produce an additional
 * evaluation-based logging. The numbers of evaluations that trigger logging are every
 * base_evaluation * dimension * (10**i). For example, if base_evaluation_triggers = "1,2,5", the logger will
 * be triggered by evaluations dim*1, dim*2, dim*5, 10*dim*1, 10*dim*2, 10*dim*5, 100*dim*1, 100*dim*2,
 * 100*dim*5, ... The default value is "", which means *.tdat files are not generated.
 * - "number_interval_triggers: VALUES" defines the frequency for targets. The default of number_interval_triggers
 * is set as 0, which means the *.idat files are not generated.
 * - "complete_triggers: VALUE" defines the option if generates *.cdat files. If complete_triggers is equal to "TRUE",
 * "True" or "true", *.cdat files are generated to save each evaluation. The default value is "FALES".
 * - "precision_x: VALUE" defines the precision used when outputting variables and corresponds to the number
 * of digits to be printed after the decimal point. The default value is 8.
 * - "precision_f: VALUE" defines the precision used when outputting f values and corresponds to the number of
 * digits to be printed after the decimal point. The default value is 15.
 * - "parameters_name: STRING" defines the names of paramters to be logged. The default value is parameters ( if exist )
 *
 * @return The constructed observer object or NULL if observer_name equals NULL, "" or "no_observer".
 */
IOHprofiler_observer_t *IOHprofiler_observer(const char *observer_name, const char *observer_options) {

  IOHprofiler_observer_t *observer;
  char *path, *result_folder, *algorithm_name, *algorithm_info;
  const char *outer_folder_name = "";
  int precision_x, precision_f;

  size_t number_target_triggers;
  size_t number_evaluation_triggers;
  size_t number_interval_triggers;
  double target_precision;
  char *base_evaluation_triggers;
  char *complete_triggers;
  char *parameters_namet;
  char *parameters_name;
  size_t i,j,flag,len;

  IOHprofiler_option_keys_t *known_option_keys, *given_option_keys, *additional_option_keys, *redundant_option_keys;

  /* Sets the valid keys for observer options
   * IMPORTANT: This list should be up-to-date with the code and the documentation */
  const char *known_keys[] = { "result_folder", "algorithm_name", "algorithm_info",
      "number_target_triggers", "target_precision", "number_evaluation_triggers", "base_evaluation_triggers", "number_interval_triggers",
      "complete_triggers","precision_x", "precision_f" };
  additional_option_keys = NULL; /* To be set by the chosen observer */

  if (0 == strcmp(observer_name, "no_observer")) {
    return NULL;
  } else if (strlen(observer_name) == 0) {
    IOHprofiler_warning("Empty observer_name has no effect. To prevent this warning use 'no_observer' instead");
    return NULL;
  }

  result_folder = IOHprofiler_allocate_string(IOHprofiler_PATH_MAX);
  algorithm_name = IOHprofiler_allocate_string(IOHprofiler_PATH_MAX);
  parameters_name = IOHprofiler_allocate_string(5 * IOHprofiler_PATH_MAX);
  parameters_namet = IOHprofiler_allocate_string(5 * IOHprofiler_PATH_MAX);
  algorithm_info = IOHprofiler_allocate_string(5 * IOHprofiler_PATH_MAX);
  complete_triggers = IOHprofiler_allocate_string(IOHprofiler_PATH_MAX);
  /* Read result_folder, algorithm_name and algorithm_info from the observer_options and use
   * them to initialize the observer */
  if (IOHprofiler_options_read_string(observer_options, "result_folder", result_folder) == 0) {
    strcpy(result_folder, "EXP");
  }
  /* Create the result_folder inside the "exdata" folder */
  path = IOHprofiler_allocate_string(IOHprofiler_PATH_MAX);
  memcpy(path, outer_folder_name, strlen(outer_folder_name) + 1);
  IOHprofiler_join_path(path, IOHprofiler_PATH_MAX, result_folder, NULL);
  IOHprofiler_create_unique_directory(&path);
  IOHprofiler_info("Results will be output to folder %s", path);

  if (IOHprofiler_options_read_string(observer_options, "algorithm_name", algorithm_name) == 0) {
    strcpy(algorithm_name, "ALG");
  }

  if (IOHprofiler_options_read_string(observer_options, "algorithm_info", algorithm_info) == 0) {
    strcpy(algorithm_info, "");
  }

  number_target_triggers = 0;
  if (IOHprofiler_options_read_size_t(observer_options, "number_target_triggers", &number_target_triggers) != 0) {
    if (number_target_triggers <= 0)
      number_target_triggers = 0;
  }

  target_precision = 1e-8;
  if (IOHprofiler_options_read_double(observer_options, "target_precision", &target_precision) != 0) {
    if ((target_precision > 1) || (target_precision <= 0))
      target_precision = 1e-8;
  }

  number_evaluation_triggers = 0;
  if (IOHprofiler_options_read_size_t(observer_options, "number_evaluation_triggers", &number_evaluation_triggers) != 0) {
    if (number_evaluation_triggers < 4)
      number_evaluation_triggers = 0;
  }

  base_evaluation_triggers = IOHprofiler_allocate_string(IOHprofiler_PATH_MAX);
  if (IOHprofiler_options_read_string(observer_options, "base_evaluation_triggers", base_evaluation_triggers) == 0) {
    strcpy(base_evaluation_triggers, "1,2,5");
  }

  precision_x = 8;
  if (IOHprofiler_options_read_int(observer_options, "precision_x", &precision_x) != 0) {
    if ((precision_x < 1) || (precision_x > 32))
      precision_x = 8;
  }

  precision_f = 15;
  if (IOHprofiler_options_read_int(observer_options, "precision_f", &precision_f) != 0) {
    if ((precision_f < 1) || (precision_f > 32))
      precision_f = 15;
  }

  number_interval_triggers = 0;
  if (IOHprofiler_options_read_size_t(observer_options, "number_interval_triggers", &number_interval_triggers) != 0) {
    if(number_interval_triggers == 0)
      number_interval_triggers = 0;
  }

  if (IOHprofiler_options_read_string(observer_options, "complete_triggers", complete_triggers) != 0) {
    if(strcmp(complete_triggers,"TRUE") == 0 || strcmp(complete_triggers,"True") == 0 || strcmp(complete_triggers,"true") == 0)
      strcpy(complete_triggers,"true");
  }
  else
    strcpy(complete_triggers,"FALSE");
  if (IOHprofiler_options_read_string(observer_options, "parameters_name", parameters_namet) == 0 || strcmp(parameters_namet,"") == 0) {
     parameters_name = "No parameters";
  }
  else{
    j = 0;
    flag = 0;
    len = strlen(parameters_namet);
    for(i = 0; i != len; ++i){
      if(parameters_namet[i] == ','){
         if(flag == 0){
          parameters_name[j] = '\"';
          j++;
          parameters_name[j] = ' ';
          j++;
          parameters_name[j] = '\"';
          j++;
          flag = 1;
        }
        else 
          continue; 
      }
      else{
        parameters_name[j] = parameters_namet[i];
        flag = 0;
        j++;
      }
    }
    parameters_name[j] = '\0';
  }
  observer = IOHprofiler_observer_allocate(path, observer_name, algorithm_name, algorithm_info,
      number_target_triggers, target_precision, number_evaluation_triggers, base_evaluation_triggers,number_interval_triggers,complete_triggers,
      precision_x, precision_f,parameters_name);

  IOHprofiler_free_memory(complete_triggers);
  IOHprofiler_free_memory(path);
  IOHprofiler_free_memory(result_folder);
  IOHprofiler_free_memory(algorithm_name);
  IOHprofiler_free_memory(algorithm_info);
  IOHprofiler_free_memory(base_evaluation_triggers);
  IOHprofiler_free_memory(parameters_name);
  IOHprofiler_free_memory(parameters_namet);

  /* Here each observer must have an entry - a call to a specific function that sets the additional_option_keys
   * and the following observer fields:
   * - logger_allocate_function
   * - logger_free_function
   * - data_free_function
   * - data */
  if (0 == strcmp(observer_name, "PBO")) {
    PBO_observer_IOHprofiler(observer, observer_options, &additional_option_keys);
  }else if (0 == strcmp(observer_name, "WModel")) {
    WModel_observer_IOHprofiler(observer, observer_options, &additional_option_keys);
  }else {
    IOHprofiler_warning("Unknown observer!");
    return NULL;
  }

  /* Check for redundant option keys */
  known_option_keys = IOHprofiler_option_keys_allocate(sizeof(known_keys) / sizeof(char *), known_keys);
  IOHprofiler_option_keys_add(&known_option_keys, additional_option_keys);
  given_option_keys = IOHprofiler_option_keys(observer_options);

  if (given_option_keys) {
    redundant_option_keys = IOHprofiler_option_keys_get_redundant(known_option_keys, given_option_keys);

    /*if ((redundant_option_keys != NULL) && (redundant_option_keys->count > 0)) {
      char *output_redundant = IOHprofiler_option_keys_get_output_string(redundant_option_keys,
          "IOHprofiler_observer(): Some keys in observer options were ignored:\n");
      char *output_valid = IOHprofiler_option_keys_get_output_string(known_option_keys,
          "Valid keys for observer options are:\n");
      IOHprofiler_warning("%s%s", output_redundant, output_valid);
      IOHprofiler_free_memory(output_redundant);
      IOHprofiler_free_memory(output_valid);
    }*/

    IOHprofiler_option_keys_free(given_option_keys);
    IOHprofiler_option_keys_free(redundant_option_keys);
  }
  IOHprofiler_option_keys_free(known_option_keys);
  IOHprofiler_option_keys_free(additional_option_keys);

  return observer;
}

/**
 * Wraps the observer's logger around the problem if the observer is not NULL and invokes the initialization
 * of this logger.
 *
 * @param problem The given IOHprofiler problem.
 * @param observer The IOHprofiler observer, whose logger will wrap the problem.
 *
 * @returns The observed problem in the form of a new IOHprofiler problem instance or the same problem if the
 * observer is NULL.
 */
IOHprofiler_problem_t *IOHprofiler_problem_add_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer) {

  if (problem == NULL)
    return NULL;

  if ((observer == NULL) || (observer->is_active == 0)) {
    IOHprofiler_warning("The problem will not be observed. %s",
        observer == NULL ? "(observer == NULL)" : "(observer not active)");
    return problem;
  }

  assert(observer->logger_allocate_function);
  return observer->logger_allocate_function(observer, problem);
}

/**
 * Frees the observer's logger and returns the inner problem.
 *
 * @param problem The observed IOHprofiler problem.
 * @param observer The IOHprofiler observer, whose logger was wrapping the problem.
 *
 * @returns The unobserved problem as a pointer to the inner problem or the same problem if the problem
 * was not observed.
 */
IOHprofiler_problem_t *IOHprofiler_problem_remove_observer(IOHprofiler_problem_t *problem, IOHprofiler_observer_t *observer) {

  IOHprofiler_problem_t *problem_unobserved;
  char *prefix;

  if ((observer == NULL) || (observer->is_active == 0)) {
    IOHprofiler_warning("The problem was not observed. %s",
        observer == NULL ? "(observer == NULL)" : "(observer not active)");
    return problem;
  }

  /* Check that we are removing the observer that is actually wrapping the problem.
   *
   * This is a hack - it assumes that the name of the problem is formatted as "observer_name(problem_name)".
   * While not elegant, it does the job and is better than nothing. */
  prefix = IOHprofiler_remove_from_string(problem->problem_name, "(", "");
  if (strcmp(prefix, observer->observer_name) != 0) {
    IOHprofiler_error("IOHprofiler_problem_remove_observer(): trying to remove observer %s instead of %s",
        observer->observer_name, prefix);
  }
  IOHprofiler_free_memory(prefix);

  /* Keep the inner problem and remove the logger data */
  problem_unobserved = IOHprofiler_problem_transformed_get_inner_problem(problem);
  IOHprofiler_problem_transformed_free_data(problem);
  
  problem = NULL;

  return problem_unobserved;
}

#endif
#line 1 "code-experiments/src/profiler/IOHprofiler_runtime_c.c"
/**
 * @file IOHprofiler_runtime_c.c
 * @brief Generic IOHprofiler runtime implementation for the C language.
 *
 * Other language interfaces might want to replace this so that memory allocation and error handling go
 * through the respective language runtime.
 */
#ifndef IOH_PROFILER_RUNTIME_C
#define IOH_PROFILER_RUNTIME_C

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>

#line 16 "code-experiments/src/profiler/IOHprofiler_runtime_c.c"
#line 17 "code-experiments/src/profiler/IOHprofiler_runtime_c.c"

void IOHprofiler_error(const char *message, ...) {
    va_list args;

    fprintf(stderr, "IOHprofiler FATAL ERROR: ");
    va_start(args, message);
    vfprintf(stderr, message, args);
    va_end(args);
    fprintf(stderr, "\n");
    exit(EXIT_FAILURE);
}

void IOHprofiler_warning(const char *message, ...) {
    va_list args;

    if (IOHprofiler_log_level >= IOHprofiler_WARNING) {
        fprintf(stderr, "IOHprofiler WARNING: ");
        va_start(args, message);
        vfprintf(stderr, message, args);
        va_end(args);
        fprintf(stderr, "\n");
    }
}

void IOHprofiler_info(const char *message, ...) {
    va_list args;

    if (IOHprofiler_log_level >= IOHprofiler_INFO) {
        fprintf(stdout, "IOHprofiler INFO: ");
        va_start(args, message);
        vfprintf(stdout, message, args);
        va_end(args);
        fprintf(stdout, "\n");
        fflush(stdout);
    }
}

/**
 * A function similar to IOHprofiler_info that prints only the given message without any prefix and without
 * adding a new line.
 */
void IOHprofiler_info_partial(const char *message, ...) {
    va_list args;

    if (IOHprofiler_log_level >= IOHprofiler_INFO) {
        va_start(args, message);
        vfprintf(stdout, message, args);
        va_end(args);
        fflush(stdout);
    }
}

void IOHprofiler_debug(const char *message, ...) {
    va_list args;

    if (IOHprofiler_log_level >= IOHprofiler_DEBUG) {
        fprintf(stdout, "IOHprofiler DEBUG: ");
        va_start(args, message);
        vfprintf(stdout, message, args);
        va_end(args);
        fprintf(stdout, "\n");
        fflush(stdout);
    }
}

void *IOHprofiler_allocate_memory(const size_t size) {
    void *data;
    if (size == 0) {
        IOHprofiler_error("IOHprofiler_allocate_memory() called with 0 size.");
        return NULL; /* never reached */
    }
    data = malloc(size);
    if (data == NULL)
        IOHprofiler_error("IOHprofiler_allocate_memory() failed.");
    return data;
}

void IOHprofiler_free_memory(void *data) {
    free(data);
}
#endif
